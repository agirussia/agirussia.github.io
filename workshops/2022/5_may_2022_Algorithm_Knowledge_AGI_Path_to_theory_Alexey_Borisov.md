## 5 мая - Алгоритм - Знание - AGI: Путь к теории - Алексей Борисов — Семинар AGI
[![Watch the video](https://img.youtube.com/vi/nn5v-frSXMM/hqdefault.jpg)](https://youtu.be/nn5v-frSXMM)

Суммаризация семинара:

Семинар касается разработки алгоритмов и искусственного интеллекта. Основная идея семинара заключается в том, что автор семинара, Алексей Борисов, стремится не только к оптимизации уже существующих алгоритмов, но и к исследованию новых методов обучения и развития искусственного интеллекта.

Алексей рассматривает процесс обучения ИИ как итерационный и рекурсивный, где система обучается не путем прямого предъявления большого количества данных, а путем постепенного накопления знаний и опыта. Он акцентирует внимание на важности оценки промежуточных ситуаций, а не только окончательных результатов, и использует методы обучения с подкреплением для формирования алгоритмов поведения в ИИ.

В семинаре подчеркивается важность копирования обучения и использование микроспособностей для формирования алгоритмических единиц. Алексей также отмечает, что его целью было не только разработать систему обучения, но и создать инструменты для программирования, которые бы помогли ему лучше понимать процесс разработки алгоритмов.

Семинар также затрагивает тему оценивания и прогрессии ИИ-алгоритмов. Алексей говорит о необходимости обучения ИИ так, чтобы алгоритм мог самостоятельно обнаруживать закономерности и решать задачи без постоянной поддержки и указаний. В этом контексте он упоминает о создании среды, которая обучает ИИ, в частности, создает среду с подсказками для алгоритмов поведения.

Семинар подчеркивает важность практических примеров и использования синтеза биологических моделей для проектирования программных систем. Алексей говорит о том, как он использовал биологические принципы, такие как эволюция и распараллеливание функций, для улучшения эффективности его алгоритмов.

В заключение семинара, Алексей делает акцент на важности практики, предсказания событий в среде и манипуляции этой средой для обучения ИИ. Он также говорит о возможности использования обучения с подкреплением для формирования поведения в ИИ и о существующем инструментарии как элементе концепта, описываемого в семинаре.

Весь семинар направлен на то, чтобы дать слушателям представление о том, как автор видит процесс обучения и развития ИИ, как он организует свой подход к научно-техническим задачам и как он применяет биологические принципы в вычислительных проектах.








S01 [00:00:06]  : Коллеги, всем добрый вечер. Сегодня у нас Алексей Борисов будет рассказывать про свою теорию построения AGI через общую теорию алгоритмов. Довольно долгое время и довольно подробно и довольно активно эта тема обсуждалась у нас в группе. Я так понимаю, сейчас Алексей созрел до того момента, когда это можно выставить на всеобщее обозрение. Алексей, пожалуйста. 

S02 [00:00:34]  : Здравствуйте. Очень рад приветствовать сообщество «Идея Раша». Мне безумно понравилось, и до сих пор в меру сил и возможностей я участвую. Читаю всё, смотрю всё и кое-что комментирую, насколько хватает сил. Меня зовут Борисов Алексей, программист, кандидат технических наук. по специальности защита информации, информационную безопасность и по специальности устройства элемента вычислительной техники и системы управления. Но, собственно говоря, ни одна из этих специальностей по профессии и по моему заработку не проходит. Зарабатываю я в основном программированием, разработкой больших программных комплексов, разработкой архитектур, развития архитектур программ, развития разных, поддержки легоси-кода, встраивания, перевстраивания. В общем, ведение это все в основном идет с использованием среды, то есть это все взаимодействие со средой и накапливает, анализирует события. То есть вот этим основной заработок. Раньше я думал, что я останусь в плане программирования только здесь, но нет, пришлось, конечно, немножко по роду деятельности подгрузить и физики, и математики. Я вообще люблю Люблю изучать новые области, люблю научные области, научные сферы и их изучение, как они развиваются, как их процесс формирования знания. И это настолько меня увлекает, что я сейчас через биологию тоже очень погрузился. Но начать хотел я, конечно, с эпиграфов небольших, маленьких. Это были цитаты из группы в телеграм-канале «В общении». Некоторые из них, конечно, выбрали немножко вне контекста. и некоторых не хватает, но вот те, которые я здесь представил, они были самые первые, им повезло. Вообще, первое, когда я увидел, что набор нулей и единиц, которым алгоритмически придаётся смысл, это вообще как заглавие всей моей работы. То есть алгоритмы придают смысл антологиям, дитикам, единицам. Это то, что решает наши задачи, придает смысл всему знанию, которое мы накапливаем. Вторая цитата, но она просто красивая, что «управлять алгоритмом и нужно стать тем, кто им управляет». Это вообще цитата, конечно, программиста, но вообще и любого человека, который любит решать задачи. этим увлекается, зарабатывает или просто этим живет. А, собственно, перейти к докладу я хотел с цитатами Колы. Он посоветовал мне начать Это так, что доклад не претендует на роль волшебной палочки, которая способна сразу TGI реализовать и прямо сделать из мечты реальностью. Но, может быть, полезно будет кому-то для того, чтобы решать какие-то практические задачи. Конечно, волшебной палочки нам сильно не хватало, потому что некоторые события недалече до трехмесячной давности. Корридинальным образом и мою деятельность изменили, и Николой мы теперь не общаемся, но может быть, реальность, и то, как она изменяется, сделает нам какие-то подарки. Вообще, реальность тренирует. Собственно, как реальность тренирует наши знания, о том, насколько в этом участвуют алгоритмы, и каким образом это связано Как я теперь узнал с AGI, я хотел бы в своем докладе немножко поразмыслить. Это не то, чтобы будет доклад о том, что вот уже готово, реализовано, пользуйте. Но вот размышления, которые мне были интересны, мне хочется, очень хочется ими поделиться. Поэтому давайте перейдем к следующему слайду. Так. Собственно, изначально все замысливано было для того, чтобы цель основная, которую я себе ставил, это формализация способов работы с алгоритмами. в моей работе программирования, то есть это не то, чтобы вот кто-то за меня писал код, а то, чтобы я понимал сам, когда я с ним работаю, какими приемами я пользуюсь, какими методами, где я науку включаю, где выключаю, какими шажками я иду к цели, вот раскладывая все это, То есть люблю детализировать, раскладывать по полочкам. И вот в своей профессии, в ВУЗе, я так не нашел ответов на эти вопросы. То есть я пошел туда, думал, мне расскажут, как, собственно говоря, программист программирует, с какими шагами он это делает. Но, к сожалению, там показали очень много приемов разных разнообразных, как с этим работать. но кусочки, кирпичики не были затронуты, и мне этого так не хватало, что вот уже много лет, я не знаю, с того момента, как я закончил вуз обучения, я этим занимаюсь, и задачи, которые поставлены были на старте, это вот просто был разбор общих технологий разработки СПО, ОПО, программное обеспечение частного уровня, скриптового, какие-то методы. Пытался я сорганизовать в одну систему, и что мне показалось нужным и важным, это нужно было для меня уловить минимальный кирпич, каким способом вот что маленькое такое я объединяю и тем самым решаю какие-то задачки маленькие, разнообразные. Этот кирпичик был важен, и он стал целью того, что мне хотелось найти. А после, когда эта цель, которую я после чуть-чуть опишу, была уже ухвачена, выцеплена, Дальше пошли вариации о том, как эти кирпичики можно объединять, какие в них есть группировки, какие структуры, как мы пишем код, какими структурами, какими приемами используемся, объектно-ориентированными, функциональными, разнообразными. Но вот эти кирпичики, в процессе того, как я их сортировал и выяснял, как ими пользоваться, поставил кучу задач дополнительных, и там в конце этих задач троеточие, потому что они разрастаются, и чем больше начинаешь внутрикопать, тем больше у тебя способов, методов и дополнительных методик открываются новые задачи. В общем, работы мне я так запланировал, чтобы, ну, к пенсии, может быть, закончить. Так что готового результата к пенсии, может быть, это будет книжка, а не черновик уже. Это в плане перспектив, да. А по задачам, ну, вот те, которые на более важные мне показались, я пытался здесь перечислить. Это поиск способов задать то, как идет направление синтеза алгоритмов из кирпичиков для решения конкретной задачи, то есть какими способами обружается пространство решения, чтобы не перебирать все-все-все возможности, чтобы это был не эволюционный супер-мега-перебор из всех вариантов. Как используется формирование модели, для повышения синтезов, то есть разные разнообразные модели, математические, физические модели, как они встраиваются, используются алгоритмами. Соответственно, после этого необходимо было, это уже после развития, когда я разделил системы и начал выяснять, как они в совокупности синтезируется и накапливается алгоритмами, там пошел уже анализ, как это происходит в многоагентной среде, как агенты могут обмениваться выявленными, синтезированными способами, алгоритмами друг с другом. После вот этот вот способ взаимодействия многоагентного и способ копирования как мне кажется, немножко для меня открыл лично, я не знаю, как это на самом деле, я после попытаюсь рассказать, структуру вообще языкового, структуру и смысл использования языка для того, чтобы работать в решении задач, для того, чтобы разрабатывать алгоритмы. Ну и самое такая последняя крайняя вещь, на которую я сосредоточился, это использование моделей, языковых моделей, структур, символов, формальных моделей для того, чтобы как выяснение структур способов для виртуализации методов синтеза, чтобы можно было не практически решать какие-то задачи, а переносно в какую-то область, где это решать проще. Тут сложно сказать все сразу. треточие само за себя говорит и хотелось бы перейти дальше и вот поэтому слайда хочется еще завершить что это пока что путь то есть это тропинка и Она проглядывается уже, то есть там туры выставлены, есть места перегиба вершины всякие разнообразные, но в целом картинка сложилась. Именно с этим захотелось выступить. То есть год назад этой картинки еще не было, а сегодня вроде бы есть. И в угоду прошлому семинару, которым я пытался немножко рассказывать, хочется сказать, что же нового, зачем вообще меня слушать, что тут вообще происходит и к чему вообще я это все говорю. Недавно был семинар по суперкомпиляции, очень мне понравился, но подход немножко другой, алгоритмически. Моя цель и задача изначально была как... по индукции от малых алгоритмов, как они развиваются, как растут. То есть это не оптимизация готовых уже структур алгоритмических, которые производятся с суперкомпиляцией, не оптимизация, повышение эффективности какие-то. Это было исследование о том, как среда изучается, как она вот как я изучаю среду, как агент, который погружен в виртуальную среду, как он может ее изучать, каким образом он может выделять вот эти вот маленькие частички, которые может употреблять для решения своих практических задач или каких-то агентных задач, если это про агент в виртуальной среде. И эта новизна как раз в выявлении вот этих способов изучения и в том, что эти способы получения вот этого кирпичика и группировки, они были выявлены во многих, во многих местах. То есть самое интересное для меня было открытие, то что те методы, которые я использую в программировании, параллельное программирование, они очень, очень интересно за ними наблюдать, как это происходит. не совсем так, но очень сходство, то есть появилась аналогия, которая позволила мне подсмотреть за некоторыми процессами в клеточке, как они группируются, какие там производятся действия, какие-то Вот красивая картинка, очень много на ютубе роликов, которые показывают, как происходит трансляция, транскрипция ДНК, РНК, какие есть биологические процессы, энергетические, какими способами клетка решает задачи. И как программист, который постоянно делает параллельные системы, параллельно взаимодействующие, смотришь на это и видишь, что аналогия. То есть вот эта вот эврика о том, что… У тебя есть подсказка о том, как делать в твоем коде. Это было для меня очень значимым открытием. И теперь у меня самая интересная вещь. Я хочу так же параллельно, как там это все устроено. К сожалению, наша вычислительная система пока что не позволяет настолько параллельно, но это было интересно. И, в общем, кирпичиком было элементарное действие, элементарное действие в природе. Вообще, как тут можно сказать, основная вещь, которая можно выделить в среде, которую я как программист могу использовать, Это то, что повторяется. Если какой-то процесс, повторимость — это маркер процесса, который можно использовать в алгоритме и который позволяет вот эту частичку, которая в среде хоть раз повторяется, повторяется, повторяется, если я вижу, что она повторяется, я могу ее использовать и добавить к своему алгоритму. Вот этот вот структурный элемент, кирпичик, повторимость, обусловленность, можно сказать, он является ключевым для того, чтобы отделить те процессы, которые у нас есть в среде, и просто процессы, которые имеют свою структуру, но не имеют повторимости, и я их не могу использовать повторно, а тех процессов, которые помогут решить мне какую-то задачу. Вот это вот элементарное действие, которое можно выцепить в среде, которое, в принципе, можно увидеть просто по набору того, что повторилось. Вот оно повторилось, просто выявлять. И дальше пошла группировка. И группировка этих действий самая интересная в алгоритме. Дальше алгоритм – это набор действий, структурированный набор действий, который позволяет решить задачу. И дальше получается, что алгоритм – это несколько рекурсивное определение, которое говорит, что если у тебя элементарное супер-мегадействие, которое ты можешь использовать, и дальше ты эти действия, множество, или одно, или несколько, можешь некоторым образом структурировать некоторое дерево решения, очень мне нравится у Виктора Артихова это название, дерево решения, то есть ты можешь сгруппировать, выявить повторимый процесс и его организовать структурно в виде алгоритма, алгоритм, Если у тебя алгоритм есть, он уже делает так, чтобы твои структурные действия, которые ты объединил, стали повторимыми, и он становится этим действием. Его точно так же можно еще раз использовать и укрупнить. Поэтому получается, что как только ты владеешь маленькими кирпичиками, умеешь их находить, дальше, соответственно, присовокупляешь процесс возможной его состыковки алгоритмов, дальше у тебя появляется возможность из этих алгоритмов уже играться разными разнообразными структурами, и ты имеешь основу. Но это, в принципе, ничего нового от генетических алгоритмов. кроме как поиска нового действия в среде, который возможно выцепить. Но о генетических алгоритмах чуть-чуть попозже. А здесь, на этом слайде, я хотел сказать, что вот эти процессы, которые происходят, обусловленные, повторимые в биологической клеточке, когда одна химическое вещество с другим химическим взаимодействует, оно уходит, обусловлены цепочки процессов, которые повторяются раз от раза, она также происходит в процессах языковой обработки. когда разбирал разные разнообразные области, в которых есть алгоритмические обработки, находил те же самые признаки и те же самые процессы, такой же способ группировки и такой же способ выявления этих действий. Вот эти переносы в одном биологическом варианте, там это позволяло что-то подсмотреть для процессов вычислителей для того, чтобы делать программу. В процессах вычислителей кое-что можно по аналогии перенести на процессы языковой обработки. И вот эта аналогичность этих процессов позволяет в некоторых средах подсмотреть в некоторые перенести вот этот же процесс и использовать его для развития какого-то алгоритма. И этот предыдущий семинар, который был у нас, ну, закрытый, без записи, был о том, что вот эти вот, там было четыре эпохи, Эти четыре эпохи и структура, в которых имеет описание алгоритма в этих эпох, позволяет делать именно переносы аналогичные. То, чего нет в одной эпохе, можно подсмотреть в другой. Давайте перейдем к следующему слайду. Это как раз про основу и про кирпичик, и про мой любимый пример с яблоком. В общем, яблоко падает. Это вот о том, какое действие программист может использовать в своем алгоритме. То есть никогда бы не подумал, во-первых, что алгоритм в математике, чисто математически это вычисление, но мне как программисту приходится все время использовать не вычисление, мне приходится взаимодействовать со средой, поднимать что-то, что-то опускать, поворачивать. взаимодействовать, видеть, как оно что-то делает, происходит, и эти действия, они невычислимые, невычисления, неработа с числами, и получается, что элементарное вот это вот падение яблока, это тот элемент физического взаимодействия, который повторяется и который может использоваться в моей работе. Если это биологическая среда, если это дерево яблони, и оно роняет яблоко, оно решает задачу своего размножения. И что? Яблоко всегда падает, внизу есть или животные, или просто семечко. имеет возможность попасть в землю, и тем самым яблоко не размножается. Я могу яблоко поставить на конвейер, конвейер организовать таким образом, что падение яблока будет сосредотачивать яблоки крупные, отделять их от мелких, тем самым могу реализовать алгоритм, который будет сортировку яблок устраивать. На чем? На каком элементарном действии? На том, что сам, которым используется биология, биологическими организмами, как яблони или как другие плодовые. я могу использовать яблоко как ньютон, то есть вот я сижу и оно упало, а дальше это падение яблока и наблюдаемое падение яблока я могу перенести на какие-то другие явления и в аналогии увидеть вот этот вот момент повторения, который является обособленным, абстрагированным от, собственно, яблока. И основа, собственно говоря, вот этого Действие – это однородность нашего пространства, однородность того, как протекают процессы в нем в зависимости от времени, в зависимости от сдвигов, переноса, при поворотах. вне зависимости от выбора оси координат и вне зависимости от того, с какого момента ты начинаешь засечку. То есть однородность исполнения некоторых процессов позволяет в этом пространстве организовывать усложнение процессов, которые которые дают возможность усложняться, друг за другом цепляться этим процессом. Если бы не было однородности, не было бы этих одинаковых элементиков, из которых состоит наше пространство, программисту было бы сложно, я бы тоже был бы не выжить. И вот эта однородность, обособленность неотличимых элементов, возможность этих элементов сложится в конструкцию, и свойство этой конструкции зависит только от этих однородных элементов и от системы связи этих и процессов, в которых она участвует. И возможность этого локализации как раз позволяет оперировать вот этими маленькими элементарными штучками, как кирпичиками, как предметом, который можно пощупать, не пощупать, обнаружить и использовать, то есть пощупать нельзя, это не вот само яблоко, а какой-то процесс. Интересно, что в этом знании о том, что как происходит, именно процесс, то есть не онтология, не вот структура яблока, не яблоко, а именно процесс является повторимым. Сейчас дальше будет немножко понятнее на соседних слайдах. Основа в этом А есть еще и ограничения. В общем, ограничения в том, что процессы изменения, вообще говоря, в нашем пространстве разнообразны. И как ни крути, даже повторимые процессы, которые мы имеем в среде, когда они группируются, они не всегда формируют, порождают вместе друг с дружкой. в целом совокупность, повторимую последовательность. То есть можно несколько детерминированных процессов объединить, а в итоге получить хаотическое поведение. То есть маленькое изменение вот здесь, здесь уже будет совершенно другой результат, повторения нет. То есть мы вроде бы объединили кирпичики, а в результате сформировали не то, что получилось, не то, что может использовать программист. И вот этот способ группировки, он всегда для программиста точно так же, как и для яблони и для всего остального, это всегда тестирование. То есть у нас есть кирпичики, и мы их группируем, структуры, но при этом программист нажимает компиляцию, а она там не состыкнулась или работает не так, как нужно. То есть у нас всегда после того, как мы что-то сгруппировали, мы это можем проверить исполнением, и если в итоге поведение… То есть это тестирование среды на возможность группировки вот этих кирпичиков каким-то заданным образом. И в чём нюансы? В том, что это всегда гипотеза, то есть вот оно знание, которое мы уверены, которое в некотором моменте выполняется. Это знание основано на структурах, на элементах и на повторимости действия. Дальше мы применяем гипотезу как программист. Вот мы одно знание объединили с другим знанием. Знание, тут я в кавычках возьму некоторую информацию о среде. Мы их вместе соединили. Дальше, как программист, я делаю предположение о том, что данное знание позволяет мне… вот, две вместе, они будут работать и будут повторяться поведение. К сожалению, наша среда не всегда так линейно объединяется. В итоге получается, что твоя цепочка разваливается, и твоя гипотеза не верна. Элементарные гипотезы, то есть объединение маленьких элементиков, вроде бы два, должно сложиться, нет, не получается. Есть более сложные гипотезы, о них чуть попозже, но вот здесь хотелось бы упомянуть немножко. Очень мне понравилось семинар, в котором затронуто была причина следственной связи. причины, как таковое GDPR и субъективность причинных следственных связей. И я не то, чтобы раньше использовал слово «причина» в своей работе, но для того, чтобы описывать вот эти вот кирпичики, группирующиеся друг за другом, какое-то нужное слово использовать, здесь В моей работе это просто обусловленность. Это не причина, которая навязывается человеку друг за другом. Яблоко падает не по причине какой-то, не навешивается этому признак какой-то, а просто потому что физические процессы, друг за другом группируясь, некоторым образом иногда формируют обусловленную цепочку, которая приводит к конечному варианту от от исходного так есть биологической клеточки так есть физических процессах так есть часах так есть в всяких механических там головоломках которые падают доминошки и вот эти обусловленные процессы для программиста это способ как раз группировки когда один процесс другого группирует обусловленные процессы можно организовать по-разному и можно как в клеточке это сделать обусловленным появлением есть какое-то химическое соединение оно обуславливает реакцию вот такую то да это вот реакция проходит химическое соединение пропадает его больше нет она переработана и соответственно включается другая другая другая реакция другие процессы какие-то но можно соответственно Этот же процесс, то есть в общем виде, который друг из друга вытекает, можно организовывать с помощью некоторого описания. И тут вот идет конструкции, от цепочек процессов, которые обусловлены некоторыми конструкциями элементов, переход к тому, что, имея некоторую структуру, ну в клетке, на данном примере клетка, то есть имея некоторую структуру, ты можешь организовать процессы, вокруг этой структуры таким образом, чтобы была какая-то последовательность. И некоторые конструкции, например, такие как кристаллы, то есть они тоже организуют процесс, который происходит последовательно, набирается кристаллическая решетка. Некоторые конструкции линейные, они набирают транскрипт, трансляция ДНК, они набирают свои элементики последовательно по вот этой структуре. То есть есть возможность в нашем пространстве на основе структур вот этих элементов сформировать некоторое описание, которое будет руководить процессом, и из кирпичиков вот этих, которые набираются маленькими элементами, формировать некоторый процесс, который будет исполняться, решать какие-то задачи, не решать какие-то задачи, но повторяться единообразным образом. И дальше вот эта структура, которая в пространстве имеется, ее можно таким же образом группировать дополнительно, и получается, что тем самым мы имеем возможность описать процесс не просто, который обусловлен концентрациями, а именно имеем возможность описать структуру этого процесса в рамках объектов этой среды. Здесь примерами, конечно, это биологические всякие варианты повторимых преобразований. Но можно таким же образом помоделировать немножко, я игрался в программном коде, и много генетических алгоритмов очень похоже устроено. То есть по факту они играются структурами, которые описывают, разворачиваются в процессы. И дальше тем самым образом, там дальше главное для того, чтобы ваши структуры решали некоторую задачу, задать направление этому процессу. алгоритмы уже играются, а вы, соответственно, либо эволюционно отбираете из множества чего-то, либо имеете возможность каким-то другим образом отсеивать ненужные варианты. И тут вопрос о том, что вот обусловленный процесс, который у нас какой-то выявлен, он каким-то образом трансформируется в знание, и знание тут опять в кавычках, это как раз возможность среде, с помощью структуры объектов, описать этот процесс снаружи. И мало того, что он описан, он является еще и способом его исполнения. Тем самым мы разделяем процессы, которые являются повторимыми, от способа того, как можно зафиксировать это в виде знания и для того, чтобы можно было это знание каким-то образом использовать. И знание тут именно как о каком-то изменении, знание о процессе, знание о действии. Очень в предыдущем вот в семинаре было Александра Бурева, по-моему, да, что действия, да, семантическая сеть действий там для того, чтобы строить GI, да, и вот что-то об этом же, то есть очень я, когда слушал семинар, очень мне это было близко и затригерило, что вот похожая мысль о том, что знание — это о том, как процесс происходит, не только структура, а именно как вот эта структура объектов может описать и исполниться для какого-то решения, для решения какой-то задачи. И там дальше любимые мои линейные структуры — РНК, ДНК, которые имеют возможность описать некоторый процесс преобразования, и древовидные структуры, которые позволяют инсертировать, но это уже программерские термины. То есть по факту разные, разнообразные типы структур позволяют нам разным образом процессы структурировать, те, которые нужны для решения каких-то алгоритмов. И получается, когда в программировании мы читаем книжку «Структура и алгоритмы», структура – это прям часть алгоритмов, часть того, что направляет. направляет действие, направляет исполнение, и сортировка элементов деревом — это именно использование как организация знания, которая распределяется и которая может исполниться. Наиболее простыми способами, которыми могут появиться эти знания сейчас, более сложные структуры, которые появляются в нашем пространстве, они могут описать некоторые процессы. Чем более сложная структура, тем в более сложном процессе она может взаимодействовать. Но возникновение этой структуры, оно как... по единичкам, по единичкам маловероятность. Чем больше структура, тем меньше вероятность хаотически ее сформировать в пространстве так, чтобы она им была знанием о каком-то процессе. И когда мы структуру вот эту имеем в линейном виде, она имеет… сейчас. для того, чтобы знание, которое мы каким-то образом сформировали в среде, оно сохранялось со временем, а структура, которая имеется у нас в биологическом варианте, не разрушается от хаотических бронзовых движений. нам нужно иметь возможность эту структуру дублировать в пространстве каким-то образом. Более простым образом это возможно при линейной организации этой структуры. И в программировании проще всего копировать линейные списки, а не деревья. И этот способ позволяет для знаний, которые уже сформированы, иметь возможность сохраниться в будущем. Тут интересно было бы сказать про соревнования. По факту, получается, у нас есть некоторый способ в пространстве описать процесс какой-то повторимый, описать знания. И дальше в биологическом варианте тут пошло эволюционное развитие и соревнование видов. Одна информация как информация, как структура некоторая, которая исполняется в пространстве, соревнуется с другой структурой, биологические клеточки, если это на уровне клеточном. или биологические виды, которые одни разрушают, другие едят друг друга. То есть по факту получается, что есть некоторые процессы, которые развиваются в пространстве, и эти процессы, описанные структурами, которые описывают, как они должны исполняться, они друг с другом соревнуются за ресурсы, и система таких структур обособляется в элементарной единице, которая еще дополнение ко всему, должны самокопироваться для того, чтобы сохраниться в будущих состояниях системы. Такая система структур, которая позволяет долгое время сохраняться. В моей работе я ее называл ритмическая система. Это набор вот этих вот структур, объектов, которые вместе с процессами, которые их исполняют, которые имеют автономность и которые имеют возможность и развиться, и вместе самокопироваться в пространстве для того, чтобы в последующих моментах присутствовать, а не развалиться или умереть. тут аналогия опять же биологические клеточки и мало на текущий момент у меня примеров из программной области но Да и, собственно говоря, мало в программной области необходимости подобных структур сформировать, и особо нет необходимости как такового самокопирования, потому что в программных отраслях алгоритмические системы, которые имеются, они легко копируются. Это просто флешка, это просто ты скопировал файлик, набор структуру, развернула ее в оперативке, и она уже такая же, как и есть. Здесь, когда я разбирал вот эту область и соревнования именно знаний, очень интересные эффекты были по поводу соревнования знаний в среде биологической, то есть это соревнование стратегий хищник-выживший, это именно алгоритм поведения, с алгоритмом поведения соревнуются, хищник какой-то коршуны и голуби, это множество разных стратегий, которые в теории игры очень большое количество проработанных стратегий о том, как несколько терапевтической системы соревнуются с другой в эффективности. Но тут можно сказать, что про эффективность еще без там самокопирования, а в программной области просто это соревнование алгоритмической системы в эффективности о том, как она, ну, быстрая сортировка против пузырьковой выжила в плане работы, а в плане примеров пузырьковой у нас имеет место быть в объяснении, когда нам Бузя объясняют простейшие процессы сортировки. И вот это вот выживание алгоритмической структуры в биологической среде и то, как это происходит с действием, взаимодействием среды, простым образом приводит к тому, что вот эта алгоритмическая система замкнутой процессов, описывающей структур, она имеет возможность взаимодействия со средой. В среде происходят какие-то повторимые и иногда неповторимые процессы, и вот эта алгоритмическая система, она как внутри исполняется и производит какие-то биологические преобразования или химические какие-то реакции происходят в ней, так она может своими процессами, повлиять на внешнюю среду, запустить ряд обусловленных процессов, которые каким-то образом вернутся в виде признаков, и может подключить вот эти вот ряд внешних обусловленных процессов для того, чтобы алгоритмическая система, ну, чаще всего для систем, которой необходимо выживание, выживала. то есть этот вот прием о том, что направить процесс для того, чтобы алгоритмы формировались и решали какую-то конкретную задачу, вот пример, как это происходит. То есть вот она выживает, самокопируется, то есть здесь в принципе ничего сложного, сверхоткрытий никаких нет, но это… наблюдений за маленькими клеточками за микроорганизмами за амебами за маленькими жучочками за то есть ты понимаешь что они вот трубчик делает панцирь находит инструменты внешне накапливаешь и смотришь как Каждая из алгоритмических систем присоединяет среду и часть ее процесса для того, чтобы воспроизводиться друг другом, как муравьи присоединяют процессы биохимические тли и как они разносят по весне у нас на грядках разные на разных плодовых раскладывают свои свои фабрики да по веществам полезным и съедобным и собственно говоря поведение алгоритма среды дальше о чем я хотел сказать о том что вот это алгоритмическая система она формирует то есть по факту ее взаимоотношения с внешней средой, оно формируется и получается совместное существование. Алгоритмическая система организма и алгоритмических некоторых систем, алгоритмических обусловленных последовательностей среды. И алгоритмическая система организма, она знает не о всем. То есть у нее знание о том, как снаружи какие-то происходят процессы, они порционно заходят, событийно, как был тоже семинар по событийному. событийным логиком, то есть по факту получается, что есть некоторые события, которые доступны внутри алгоритмической системы организма, которые я назвал признаками, можно по-разному их событиями называть, и эти признаки позволяют организму посмотреть, какие алгоритмы снаружи, как исполняются повторимые процессы, можно ли этот процесс присовыкупить, нужно ли вот этот процесс избегать. Позволяет на основе вот этих вот внешних данных и внешних соприкосновений с внешними процессами, внешних признаков алгоритмов позволяют накопить знания внутри То есть в виде структур некоторых, которые позволяют эти знания потом использовать для того, чтобы избегать, выживать в общем случае, а также избегать, наоборот, нападать, атаковать. И как простейшая алгоритмическая система, которую, собственно, я обсуждал на прошлом семинаре, там не обсуждал, а просто пытался рассказать, что я макетировал данную штуку. То есть у вас есть некоторая алгоритмическая система, которая на основе признаков, уже ей не нужно выживать, я сам выдаю ей задания, на основе признаков и некоторых действий опорных, которые ей доступны, краничного количества, пытается в среде найти возможность своими действиями в совокупности с признаками выполнить какие-то обусловленные сложные цепочки и детектировать вот эти цепочки в виде знания описывающего. что вот эта цепочка состоялась, и она возможна в данной среде. То есть вот это вот я действие попробовал с вот этим признаком, и ничего не произошло, а вот это действие с вот этим признаком, с вот этим признаком сделал, и в среде повторилось кое-что. То есть вот это вот кое-что повторилось, это можно использовать в качестве, даже без награды этого организму, он кое-что уже выцепил из, узнал. Узнал о среде то, что можно использовать впоследствии. Здесь даже в некотором роде я отпускал его на собольное хлеба, он просто изучал ее. То есть не стимулировал, не обучал, он просто кое-что делал на некоторых признаках. Я, конечно, подготавливал вот этот семинар про обучение. Действительно учи сад ясельки. И получается, что вы кидаете в некоторые условия, которые моделируют ситуацию, которая ему попроще будет. То есть ты некоторым образом формируешь. какие закономерности проще будет этому алгоритмической системе выцепить. И дальше эта алгоритмическая система, согласно вот этим вот простым довольно-таки, без прикрас, методом, случайным поиском, то есть она по факту случайно генерирует действия, некоторые признаки генерируются самим средой, среда каким-то образом описывается алгоритмически, как она взаимодействует сама, как функционирует, что в нем какие-то закономерности есть, какие нет, это описывается в макетировании, я просто кодом это скриптами писал. И алгоритмическая система, которая ведет она случайным образом в этой среде ищет повторимости, ищет те действия, которые позволяют ей достигать каких-то маленьких результатов. Она имеет возможность внутренними структурами группировать те действия и те повторимости с признаками, которые позволяют ей достигать некоторых результатов и ранжирует то, уже наказаниями или поощрениями, можно сказать, что вот это вот тебе точно не понадобится, то есть это внешние признаки, которые я дополнительно генерирую для того, чтобы чуть-чуть направить. И в чем основа того, чего там есть, вот самая большая из того, чего я моделировал, это в том, что… как сейчас… потому что группировка маленькое действие – это просреда, о которой я уже рассказывал. То есть у нас есть возможность с действия сделать одно, потом с действия сделать второе и вместе их соединить. И два соединил, возможно, вероятнее всего они сделаются и станут общим алгоритмом. Если соединил 25, которые у тебя попробовал, у тебя вероятнее всего окажется что-то бесполезное. И самая вот из того чего прогрессивного, то есть возможность того, что у тебя вот условленные вот эти две, они группируются в действии, и дальше вот это вот устойчивое сочетание, которое нашлось, оно уже является как накопителем, то есть накопитель дополнительный, который может с краев или внутренними действиями разрастаться деревом для того, чтобы формировать сложный алгоритм. И именно в поиск алгоритма вот для вот этого макета был из трех способов, которые в конце концов дополнятся еще вот на следующем слайде еще несколькими. хорошими способами, которые более интересны и менее тривиальны. Вот эти вот, которые я обозвал, это, в принципе, все сводится к генетическим алгоритмам. Эволюция в данном списке не является эволюцией-отсылкой прямо к биологической эволюции. Этим словом, я назвал в своей системе именно накопление алгоритмиков по полнорастающий, когда у тебя есть основа-база, которая точно работает, и когда ты дополняешь ее маленькими микромодулями. Таким же образом, собственно говоря, я в своей работе точно так же многократно делаю, то есть у меня есть база, я ее наращиваю маленькими модулями проверяю что в функциональном работает гораздо сложнее соединить сразу 25 модулей это всегда куча тестов которые ты будешь делать и которые не смогут тебя выгрести эволюция еще раз повторюсь это термин, который не биологический, а придуман в рамках алгоритмической теории, которую я сделал, пытаюсь проработать. И, собственно говоря, о чем дальше хотелось бы рассказать. о том, что этими способами все не заканчивается, о том, что вот это вот простая тривиальщина по поводу дерева и о том, что группируются маленькие кирпичики, это, конечно, хорошо, но те наблюдения, которые по биологической клеточке у меня Я пытался сделать сейчас это проще и интереснее и с YouTube, и с энциклопедиями, доступными в любой момент. Есть способы синтеза алгоритмов новых поведений, нового, повторимого способа преобразования, нового исполнения, которые не сводятся к предыдущему. чаще как оно сводится, но не непосредственно, то есть это дополнительный признак. И как способ… ну, можно по порядку. Из того, что самое явное, то, что программист многократно использует, это способ, когда ты разработал алгоритм для одного чего-то, а потом взял и перенес его в другую область, и он там тоже работает. То есть тем самым ты не изобретаешь его в новой области с новыми кирпичиками, а пытаешься применить его по аналогии. То есть это в научном формате, это аналогия познания перенос в химической области, это перенос перенос действий, которые, например, окислители, восстановители химические, имеют общие, редкоземельные металлы, и у них общие свойства, и ты можешь, зная, что это металл такой-то, перенести алгоритмы, которые используют этот металл, и попытаться с другим редкоземельным металлом те же самые операции выполнить и ту же самую задачу решить. Второй способ из сложных – это трансляция. Трансляция на основе чего происходит? Есть некоторая структура, которая преобразует поведение, повезует структуру в какое-то поведение. Вот эта структура, она описывает, она длинная, сложная, дерево линейное или что-то происходит. И вероятность того, что если мы каждому элементу этой структуры сопоставим нечто свое, и из этого последовательно соберем вторую структуру, вторая структура опишет нам некоторое поведение, некоторое исполнение больше гораздо, чем если мы будем вот это вот по элементам собирать вторую структуру. Это тоже как своеобразный перенос, но получается, что мы формируем на основе одной структуры вторую из комплементарных элементов, то есть элементарным соединением. Дальше я там на слайдах поясню. И крайний способ — это совокупность из двух Это интерполяция, это тоже термин я тут в кавычках ввел. Вообще это моделирование. Мы обсуждали с Алекс Буркентом, что создание модели и способ создания модели с использованием нескольких трансляций. Дальше я тоже лучше опишу на следующих слайдах. что, собственно говоря, хотелось повторить. есть элементарные кирпичики, они группируются, есть способы синтеза переносом или трансляции или с сопоставлением моделей обратной трансляции, потом расскажу. в любом случае, когда мы выполняем вот это преобразование, мы готовим гипотезу о том, что в новом виде, соединенном, перенесенном, транслированном, структура будет исполнение то есть она это не всегда так но это всегда гипотеза то есть у нас есть некоторые опорное знание мы на основе этого опорного знания какими-то методами группируем транслируем и формируем новое знание кавычка да о том что вот так вот тоже будет работать и Как в научном познании у нас есть основа, у нас есть гипотеза, а дальше экспериментальное подтверждение. И так, собственно говоря, практически всегда бывает с программированием. То есть ты вот все счел, модельки слепил, вместе соединил, а дальше смотришь и проверяешь набором тестов, набором экспериментов. А есть ли повторение? Повторяется ли твой эксперимент? Работает ли это? перенос, трансляция, перевоз на следующий язык, да, на другой иностранный, у тебя носитель языка понимает, не понимает. И вот этот знание, синтез из этих знаний нового и потом проверка на то, что новое это тоже знание, стоит его вообще оставлять, он как Путеводная звезда о том, что работа сознанием вот такими кирпичиками и группировкой, оно состоится. Во всяком случае, в моем сознании так точно, а как у каждого тут интересно. Вопрос дальше, конечно, будет интересно послушать. Тут хотел просто немножко про каждый метод. Но проще всего, больше примерами, более эффективного метода, чем примеры, очень сложно придумать. Перенос и в разных местах. уже рассказывал про химические реакции и то как металл да если это химический элемент металл независимо от того да какой он конкретно то это совокупность реакции и реакция это можно применять к одному металлу, к другому металлу, к третьему металлу, к четвертому можно попробовать применить, но не применяется, потому что у него там что-то другое. То есть это в любом случае перенос, проверка, будет ли оно работать на новом металле и фиксация знания о том, что да, такой процесс возможен. Математические действия. Это перенос подсчета, вот у тебя большое стадо коров, эти коровы. Много-много посчитать не можешь, и, соответственно, перенос можно в каждую корову сопоставить с камешком, а после считать камешки и действия вот этих камешек и коровам или собакам дальше впоследствии. Они переносятся с одной системы на другую. Шаблоны человеческого поведения – это ярлыки, которые мы навешиваем, когда человек, видим, у него разрез глаз или цвет волос, и дальше вздёрнутый, нос не вздёрнутый, улыбается, он цибели не очень. А аналогия как таковая, как основа того, чего чего вот эта система позволила мне пытаться раскопать аналогия научного познания позволяет одну отрасль знаний и алгоритмов, которые у тебя сложились в этой отрасли, перенести в другую, примерить и посмотреть, гипотезу проверить, насколько они сходны. Если гипотеза срослась, то этот перенос позволяет, если один алгоритм на области перенес, то есть возможность и вероятность того, что и другие алгоритмы тоже перенесутся и будут там работать. Это опять гипотеза и опять проверка. То есть и в этой области, в физическом падении яблоко, яблоко, молоко, планета друг на друга падает. Это всегда… гипотеза, проверка о том, что алгоритм, который ты уже использовал в одном месте, он поможет тебе в другом. Это экономия твоих усилий в новой отрасли для того, чтобы решать задачи, которые у тебя уже в какой-то другой были решены. И самое интересное и самое такое примечательное в плане переноса, это объяснение, олицетворение любимых художественных приемов. Это то, когда мы человеческие эмоции, человеческое поведение любим очень переносить. Ладно, сейчас не любим, вообще исторически переносили человеческое поведение, объясняли некоторые природные явления. И тем же приемом. То есть мы узнали, какой человек грозный, дует, швыряет молнии. И вот это молнии и грозность перенесли и туда, и обратно. То есть перенос поведения, алгоритмов, которые мы встречали с человеком, на какое-то физическое явление и попытка его объяснить таким образом, применить другие алгоритмы, которые мы применяем к человеку, задабривание Перуна или других каких-то божеств. Дальше тут еще несколько методов, а я так сильно разговорился. трансляция тоже интересная штуковина в плане здесь примерчик пересборки до белка и способ о том как есть некоторая структура и комплементарно каждые элементы этой структуры восстанавливая в той же последовательности с теми же связями, мы имеем возможность формировать друг другу структуру, которая будет ну как минимум проще меньше, например, то есть вот если вспоминать семинары первые, из которых я, собственно говоря, начал просмотр, это картирование, то есть по факту у вас есть некоторый объем местности, да, который вы элементно можете в виде объектов или в виде каких-то чертежа перенести, а дальше алгоритмически те алгоритмы, которые вы имеете в большом объекте, свести к маленькому пространству, в котором вам удобнее работать, проработать в этом пространстве некоторые алгоритмы, которые крупнее, вам проще синтезировать, потому что вам проще случайно перебирать, проще группировать, проще каким-то образом. И потом есть возможность транслировать ее в обратную область и тем самым реализовать алгоритм, который вы никогда бы не реализовали в исходной области. Есть возможности трансляции. Это трансляция, которую я рассказал с переносом, это скорее к следующему методу, когда трансляция двухсторонняя. А в односторонней трансляции у вас есть возможность иметь некоторую структуру, которая описывает вам поведение более сложное, которое разворачивается в процессе. Например, ДНК формирует маточную РНК, по РНК формируется белок, и белок уже формирует поведение, исполнение, которое нет исходно в в ДНК, то есть оно как бы описано там внутри, но поведение не исполняется. И тем самым получается, что трансляция не всегда дает тот же самый комплементарный, картографию, то есть она не всегда дает те же объекты, которые также функционируют, как и исходные. Это способ перевоплотить структуру, чтобы она исполняла нечто новое, и это нечто новое иногда может, если это направить вот этот вот процесс синтеза новой структуры, он может решать задачи, которые исходная не решала и не могла решать. и тут любимая моя компиляция программы в бинарный код и исполнение как таковое, то есть когда мы берем интерпретацию программы, она комплементарно, поблочно просматривает таким же образом как белок и сразу же воплощает ее в исполнение какой-то действия, которая может, например, сортировать массив или что-то там управлять каким-то двигателем, поворачивать часы, например, или стрелки, что-то такое. Самое ограничение, не ограничение, а вот в трансляции, то, что вот отличает ее от следующего метода, в трансляции нет гарантии того, что после того, как структура будет оттранслирована и породит новую структуру, те же алгоритмы, которые работали со старой структурой, будут работать и с новой. То есть этот метод, он не предполагает то, что перенос алгоритмов станет возможным. А в следующей системе порождения алгоритмов и способов синтеза именно об этой и постулируется. То есть когда у нас есть способ синтеза модели, как я себе его представляю, Тогда у нас есть некоторая алгоритмическая система, набор ее объектов, структур и алгоритмов, процессы, которые в ней могут протекать, или, возможно, протекают, или в текущий момент протекают, в зависимости от того, это биологическая клетка или мы уже рассматриваем какие-то модели более формальные, например, математические модели. И есть возможность вот эту вот алгоритмическую систему, алгоритмами трансляции, сформировать по ней некоторую описательную структуру, которая будет точно так же функционировать. не факт, что эта система трансляции сразу сформируется. Есть способы трансляции, которые, возможно, преобразуют структуру не именно объектов, а, например, структура процессов, развернутых в пространстве. Тем самым мы, по факту, получаем комплементарно сопоставляя некоторые события, разворачивающиеся во времени, с структурой, записывающей эти события, записывая эту структуру, имеем возможность транслировать некоторый процесс в среде и дальше работать с этим процессом на уровне обработки структуры, которая имеет описание этого процесса. Если она имеет только прямое, то есть мы можем развертый процесс каким-то образом описать внутри структуры и все и дальше анализировать внутри повторимость там это полезность или что-то внутренние признаки какие-то это одна Если по этой структуре, которую мы можем сформировать внутри описания процесса, мы можем этот процесс впоследствии еще и породить, то есть обратно транслировать в исполнимое пространство, то вот это вот описание структуры является у нас моделью этого процесса внешнего, если это процесс. Это может быть процесс, может быть преобразование развернутого в пространстве процесса в структуру и обратно в процесс. Это может быть преобразование в структуру. То есть трансляция не всегда идет не ограничена тем, что это именно объединение и сообставление какого-то объекта и объекта в новой структуре. Это может быть какое-то событие, развернутое в пространстве, и объект. Что в этом двойном преобразовании полезно? Если это преобразование в алгоритмической системе запустить таким образом, чтобы эволюционно направить его чтобы те алгоритмы, которые есть во внешнем процессе, во внешней среде, мы описали во внутренней алгоритмической системе, и те алгоритмы, которые исполняются во внешней среде, можно перенести было бы туда и обратно, то тем самым мы формируем некоторую алгоритмическую систему, которая позволяет нам Чаще всего в упрощенном виде, и это самое эффективное, если это такое получается, в упрощенном виде моделировать, предугадывать поведение некоторой среды тем самым, что мы манипулируем структурами, а не временем. а не временными наблюдениями, а именно описываем структурно то, что наблюдаем. Тем самым мы можем манипулировать в рамках ритмической системы, которая является пространством, мы можем манипулировать знаниями о том, как идут процессы, о том, какие в них есть обусловленности, и тем самым на модели прорабатывать, разрабатывать, синтезировать алгоритмы, которые впоследствии мы сможем попробовать реализовать в среде. Тем самым получается, что у нас есть две алгоритмические системы, мы и в той, и в той можем синтезировать алгоритмы привычными методами, которые были раньше, но в некоторой алгоритмической системе, которую мы обусловили двумя трансляциями, во-первых, трансляции обужают область поиска, То есть не все-все-все-все-все-все алгоритмы из среды, они описываются. Она, как называется, обужает поиск алгоритмов именно целенаправленно, позволяя выделять только то важное, которое необходимо. в данном каком-то месте. И это обужение экономит нам усилия, тем самым еще предоставляет возможность быстрее выполнять какие-то задачи в плане именно поисковое. Поисковое построение дополнительных решений. 

S01 [01:04:55]  : Алексей, можно я тут пару слов встряну? Тут сейчас прозвучало несколько важных вещей. Во-первых, про предугадывание событий в среде. Во-вторых, про манипуляцию этой средой. А в-третьих, я услышал нечто такое, что позволяет сделать вывод, что обучение – это, по сути, есть трансляция. В том числе обучение, как обучение подражанием, так и обучение с подкреплением. Это я к чему говорю? Хорошо, что это прозвучало, потому что у некоторых слушателей вопросы возникают. А когда мы подойдем к общему искусственному интеллекту или к интеллекту, то, что вы рассказываете, позволит построить этот самый интеллект или понять, как он работает, с одной стороны. А с другой стороны, особенно учитывая то, что вы решаете практические задачи как программист, можно ли как-то выйти от абстрактных рассуждений каким-то практическим примером и практическим приложением. Чтобы просто успели, если у вас есть что на эту тему сказать, чтобы оставшиеся минут 20-25 успеть это осветить. 

S02 [01:06:22]  : Я услышал вас, да, конечно, именно так все и запланировано. Все правильно, согласен. Мало было «проезжай», сейчас немножко. постараюсь добавить это было в основном это было та и теперь дальше перехода переходы но собственно это к тому что уже собственно говоря я макетировал пытался играться модельками о том как вот эти все методы которые были раньше описаны как можно их выстраивать в использует для построения какой-то системы, которая разрабатывает свое поведение, которая предугадывает какие-то поведения среды, которая разрабатывает обусловленные цепочки вне и контролирует их каким-то образом, которая строит иерархии признаков по тому, что она наблюдает, которые можно обучать обучать последовательно. вот предыдущие все мои ранние работы, они были на том, что она сама самостоятельно искала поведение, о том, как она сама там совместила алгоритмы, пыталась выжить и пыталась выжить максимум из того, что ей в цели полагается. постепенно Я пришел к тому, что необходимо упрощать эволюцию и мало того, что просто она сама подбирала, необходимо формировать, обучать и транслировать ей некоторые знания, которыми я обладаю. Да, тем самым я, конечно, делаю её не суперэффективной, но подсказывает о системе, собственно говоря, последовательность событий, с которыми она сталкивается. Был некоторый разговор про Кваля, про то, как иерархические у неё структуры на признаки друг за друга цепляются, то есть если некоторые события она переживает таким образом, а не другим, у неё иерархические признаки по-разному состыковываются и разные алгоритмы формируются в зависимости от этого. Очень похоже на термин «психологический», но не психологией необходимо он был, а для того, чтобы посмотреть, как вообще это иерархическое выявление признаков и совокупности внешних инструментов, которые получается выделить в среде, как позволяет этой системе строить сложные алгоритмы для того, чтобы для меня, не для того, чтобы вот она выживала, то есть по факту цель выживания вообще это биологическая штука, а для того, чтобы она разрабатывала алгоритм, который мне необходим. И это было отчасти это Обучение примерами. Обучение средой, обучение последовательностью примеров. Не массовостью, не супер-мега-выборками, а именно тем, какие она события переживает последовательно. Это немножко, конечно, делать неприменимо ее к анализу визуальных образов, если там не выстроить это в линейку. Но там поиграться тоже можно, особенно если рулить алгоритмом внимания, который будет по экрану, по области визуальной выделять границы и следить за ними, смотреть, каким алгоритмом можно это покрыть. На этом слайдике я хотел, собственно, об этом и сказать, о том, что алгоритмическая система организм в том виде в котором есть его можно некоторым образом дрессировать вне биологической среды и внутри вот там вот этот вот признак его области памяти и актер на области памяти которые Я их несколько видел и у сообщества Дмитрия Саликова, что-то очень похожее. Есть признаковые такие же штуки, были chain model. Несколько работ из группы AGI сообщества, AGI Russia сообщество, там очень сходная была признаковая, разбор пространства. Очень часто такой признаковый разбор, который используется в этом макете, был в разборе текста. Текстовый разбор, последовательность, закономерность, срыв образца. Я демонстрирую примеры алгоритмической системы, которую она отрабатывает и запоминает. Очень похоже на текстовую обработку. знаю как это характеризовать с какой стороны но хочется перейти и к следующему следующему слайдику а именно коммуникации и коммуникация здесь не не только как многоагентная система которые там рекламировал, но как способ вот эту систему, которую разрабатываю, чтобы она со мной коммуницировала. То есть чтобы я имел возможность дать ей символ, когда какой-то важный признак в среде наблюдается. То есть пытался эмулировать то, как обучается какая-то система. То есть вот есть знаковая последовательность и мой важный символ важности. или символ важности, или символ того, что нужно выполнить какое-то действие. Сейчас. попытки того, чтобы эта система работала быстрее, мало того, что пришлось использовать последовательности обучающих ситуации, то есть сначала спускаешь робота без лабиринта, потом стеночки с одной стороны устраиваешь, так еще дополнительно к этому и хотелось иметь возможность подсказать это системе не подсказать не количеством опять же статистическим примеров до стенок с разных сторон а вот в живом режиме когда она пытается какой-то алгоритм предпринять или какой-то символ выцепить то подсказка моя с моей стороны дополнительными символами как как коммуникация с ним но уже впоследствии это синхронизация именно коммуникации это уже отдельно уже я уже это мне макетировал просто разбирал каким образом вообще может возникнуть коммуникация и как как что, как обучение, как подсказки другой алгоритмической системы, родственной, о том, как ей лучше действовать, как способ формирования коллективного алгоритма, который полезен каждой отдельной особи. И в одно из дополнительных способов, тем основным, способ коммуникационного синтеза алгоритма, когда одна из алгоритмических систем уже знает некоторую структуру, которая знания, описывает какой-то важный процесс и пытается совместно с другой структурой передать эту структуру в виде символов. в виде трансляции, трансляции вот этих важных знаний, кусочков признаков, по которым она сработала, кусочков действий. Пытается это выполнить, сейчас скажу, подражанием, методом подражания, методом трансляции живого поведения, очень классный Например, я в прошлом году в мае гулял по Ковиду пешком, и на реке уточка и маленький утёнок. Утёнок уносила течением, и утка учила утёнка выплыть из этого течения, как она могла сказать, ни голосом, ни звуком. Она становилась рядом с утёнком и плыла в правильную сторону. Она не понимала. Она возвращалась к нему и плыла в правильную сторону. То есть по факту она учила его стороне, и впоследствии сразу с четвертого, с пятого он выплыл к моей радости и к радости обучающей системы, которую я в этот момент обдумывал. как способ комплементарно действиями научить какой-то некоторой иерархии действий, которые одна алгоритмическая система уже изобрела, и второй пытается транслировать. Этим способом можно интерпретировать то, что внутри. Был у нас семинар про интерпретацию, то есть нейронная сеть таким образом не может оттрансферировать то, что она хочет. А здесь по факту каждая особь эволюционно достраивается до поведения для того, чтобы иметь возможность описать алгоритм, как она его изобрела, по признакам. и отранслировать. В биологическом виде, то есть, естественно, часть логаритмов ребенка данного отождения, это никому не секрет и понятно. Другие он с посредствами коммуникации, средствами, он их от взрослой особи набирает постепенно, пока он в младенчестве, в детстве, и потом сейчас мы до университета учимся и все еще не доучили все алгоритмы, которые произобрели другие особи. Способы, в принципе, все те же самые, а там Вот там на предыдущем рисунке иерархия была. И способы трансляции алгоритма, которые одного способа постигла, это способ указать на те признаки значимые, которые в этой иерархии понадобились для того, чтобы выцепить момент, когда действие выполнено. И способы восстановить дерево действия, которое оно выполняло, Ну, простейшим образом это показывает действие, то есть, когда вторая особь рядом сопереживает и выполняет все то же самое. Взрослая особь демонстрирует момент, когда нужно, способом, признаком, крякой, когда нужно ползти, когда нужно плыть, и действиями, которые дочерняя особь тем самым дублирует алгоритм, который в коммуникации дублирует алгоритм, который изобрел другой особь, чтобы не перезабредать его заново. И тут, собственно говоря, это я пытался рассказать, а это был второй слайд. Ну, подражание, выделение самостоятельных признаков, то есть каждая особь, по факту получается, как я себе это вижу, представляю, точно так же формируют алгоритмы, но с подсказками. моими, как человека, который знает, где роботу по стенке лучше ползти, или особи, которая была более воспитанная и была взрослее, больше обитала, которую научили предыдущие поколения. Также она передает опыт своих знаний, кусочки своих действий, кусочки последовательности действий, способы эти действия выстраивать так, чтобы можно было, то есть очень неожиданно для меня было открытие, сказки, русские сказки, и то, как в них итерационно пытаются маленькому ребенку описать способы, как можно группировать действия для того, чтобы решать сложные задачи, сложнее, сложнее, сложнее. То есть взрослые особи коммуникации мало того, что могут сформировать конкретный алгоритм поведения там вставай когда молча ешь или что-нибудь такое, они могут еще ребенку методом навязывания образца, да, они могут продемонстрировать способ, как из маленьких действий, которые они еще ни разу не столкнулись, как из них можно сформировать алгоритм, чтобы ребенок не перебирал многократно эту штуку. Итерационные там, рекурсивные, ладно, это я, наверное, сильно удалюсь, если начну про сказки рассказывать. И практические примеры. Практические примеры мало-мальские. Я много чего рассказывал. Очень мне помогли в плане практики сходства. сходство биологических организмов, как они внутри формируют функциональные органы, как они обособляют, какими способами он пытается функционально разграничить и увеличить возможность эволюции системы, увеличение сложности системы, каким образом распараллеливая, распиливая границы ответственности модулей можно это все развивать, и на сходство я дальше начал это просто пользоваться, применять в программных проектах, когда подсмотрел, что это вообще биологически возможно. Возможно, это не моё первое открытие, я даже наверняка уверен, что, почитав хорошие книжечки по программированию и развитию архитектурных проектов, это можно найти всё и везде, но для меня было удивительно, что я к этому пришёл после того, как почитал биологию. и книжки по внутренней микробиологии. Для меня это было интересно. Тут я немножко хотел рассказать про накопление в алгоритмических системах. 

S01 [01:19:49]  : Алексей, на всякий случай, наверное, надо минут через 10-15 уже завершаться. 

S02 [01:19:53]  : У меня 5 минут осталось. Я вот как раз слежу за временем. Где-то пять минут осталось. В апреле этого года я, окинув взором свою деятельность профессиональную, обнаружил, что очень часто я занимаюсь развитием системы, которая близка очень к тому, что макетировал и моделировал с поведением. То есть, по факту, на работе Чаще всего это программно-аппаратные системы, которые работают в режиме приема потока некоторых событий. У этой программно-аппаратной системы всегда есть возможность выполнять некоторые наборы действия. с влиянием потока входящих событий. То есть действие влияет на поток входящих событий. И самый большой выхлоп из этой системы о том, что она должна всегда формировать описание значимых внешним пользователям, но это не самой системе, некоторых образов событий. И в работе у нас это было давно и крепко. Чаще всего никак не застряли мы внимание на том, каким способом мы этим делаем. Сейчас я окинул взором. Сначала это была статистика, разделение образцов, статистические значения, классификация, разделение на классы косредными и другими методами. и нейронные сети в плане классификации и выпиливания некоторых образцов, которые заранее можно было предобучить. А в последнее время все больше моделей являют собой запись образцов с проверкой повторимости, как система, описанная, которая была описано в поведении, то есть система осуществляет некоторый процесс записи, структурированный не в виде не видя звуковой записи, а структурированно разбирает некоторым образом поток событий, и из этих образцов при их повторном наблюдении, сопоставляя, коррелируя эти образцы, она уже выцепляет на основе повтора вот эти образцы, и еще лучше она работает, если ее при этом заставлять образцы подавать ей последовательно с увеличением сложности но это о том что на работе в принципе я делаю то же самое можно было об этом совсем не говорить а вот на следующий слайдик я давно хотел Не то чтобы хотел, я рекламировал то, что я сделаю статейку обзорную по поводу моих нокетирований, по поводу программных изысков. К сожалению, времени после февраля стало категорически меньше. Вся вот эта статейка выразилась в вот этот вот набор скринов, которые я, собственно, начел уже где-то в январе. изначально я работал по вот это вот слева система это еще винтовая система когда набор структуры вот та вот структура взаимодействия алгоритмической системы которая была на предыдущих схемках это набор слоев которые от желтой среды environment до некоторой обработки соединения в слое. в слое формируется набор алгоритмов и группируются иерархически. эти алгоритмы разрабатываются, синтезируются и дальше обратно взаимодействуют на среду. внутри environment у меня в принципе изначально было некоторое логиническое описание среды, но впоследствии я понял, что сложно каждый раз писать описание и расплодить его в C++, и перешел на систему, в которой можно просто на питоне сформировать некоторые пространства среды, которые внаружу кидает события, принимает некоторые действия и ведет себя некоторым образом внутри, задаю, например, узоры повтора, например, или реакции на некоторые действия, или цепочки действий, то есть некоторым образом описываю. В итоге в целом получилась система, я пытался ее сделать максимально универсальной в плане того, что простые условные рефлексы, чтобы вот слой, который строит алгоритмы, маленькая простая ситуация, два, три, четыре элемента события, которые друг за другом завязаны, чтобы система могла отработать ее. Если нужно какую-то более сложную ситуацию, то, соответственно, скриптово обрабатываю, описываю среду, подключаю ее к такой же самой системе набрасываю некоторое количество блоков которые крутят там вот эти алгоритмы и самое печальное во всех этих собственно говоря уже об этом рассказывал всех этих моих то, что я думал, что они продемонстрируют, что это будет круто, наглядно и всему подобное, в итоге получается, чем сложнее я туда систему погружаю, то есть не робота, а какое-то там визуальное поле, тем сложнее внутри Но не по готовленному так точно, а в конце концов при возросшей сложности даже мне было сложновато. И впоследствии проект направился к тому, чтобы я внутри сам понимал, как все это устроено. Какой-то там алгоритм друг за другом завязало. где она сгруппировала признак, то есть больше чем год я дорабатываю эту систему, чтобы было внутри понятно, что происходит, а не дополняя новыми алгоритмами, то есть не новыми алгоритмами, а новыми средами, которые она может повладеть. И крайняя доработка моя была именно в плане коммуникации, то есть для того, чтобы можно было системе некоторыми признаками подсказать в условиях, обучить ее, довести, чтобы она не 25 раз об стенку тыкалась, а поняла с одного раза. Это доп. коммуникация. Вот такая вот большая штуковинка, которая заняла у меня кучу времени, а демонстрации из неё, ну, так себе. Я её демонстрации не считаю. По чесноку, если... Для себя она была мне полезна, она мне кое-что устаканило. И самое важное, что она сделала, что мне захотелось описать это формально, как внутри это все происходит, и привела меня к тому, что нужно математику написать. И, собственно, крайний слайд. Я тут на одну минуту. Здесь наконец появилось слово AGI. Я, наверное, мало что тут поэтому сильно скажу. Скажу, что очень много мне в разговорах, в общении вообще о том, что вот я рассказываю, как это все происходит, очень часто борюсь с мельницами о том, что я всегда имею в виду алгоритмы поведения, И всегда, если человек занимается теорией алгоритмов, он рассказывает не про вычислительные алгоритмы, они отличаются функционально, отличаются кирпичиками, отличаются методами, отличаются… много разговоров было в группе о том, где же у вас эффективность, и все остальные методы математические, о том, как считать доказуемость эффективности алгоритмов. Я тут, собственно, пытался на крайнем слайде перейти к темам, которые уже звучали. Некоторые звучали в форуме, в телеграм-канале. Я боюсь, что время уже заканчивается. И самое большое, что хотелось здесь сказать, это три точки о том, что тема интересная, и она про GI. Про то, как алгоритмическая система может накапливать знания, может делиться этими знаниями, может группировать, может делать некоторые гипотезы, в кавычках, может экспериментально их проверять, может практически из среды вычленять некоторые новые зависимости, закономерности. Это то, что я называю знанием. буквально полгода назад, я понял, что это очень похоже на DJI. Если это не так, то я рад выслушать. Выслушайте вас. 

S01 [01:29:27]  : Спасибо, Алексей. Давайте я пойду по вопросу. У меня единственная просьба, поскольку там вопросов много, я предлагаю сделать так. Когда доходит речь до вопрошающего, то вопрошающий может подключиться и все свои запросы паровозиком задать, чтобы нам пройти по всем вопрошающим, успеть за оставшийся час. Первый вопрос, я тут его объединю от нескольких участников, это как то, что вы рассказали, соотносится с, если не всем, опытом прогрессивного человечества за его многодесятитысячелетнюю историю, хотя бы с частью какой-то. Вы как-то можете соотнести свою работу с предыдущими работами по теории алгоритмов, теории информации, искусственного интеллекта? Например, есть работа... Алексей Шкотин прислал общая теория оптимальных алгоритмов. Джитрауб, экс. Вожняковский. В чате потом будет ссылочка. Вот, например, с этой работой вы знакомы или еще какие работ книжки по этой теме вы читали и как-то с ними можете соотнестись? 

S02 [01:30:48]  : Сейчас сформулирую. Нет, эту книжку конкретную и автора я не читал. может быть и читал, но не помню, по поводу теории алгоритмов и вычислительных. Это как раз первый пункт моего дивного слайда крайнего заключительного. Вычислительные алгоритмы и алгоритмы, то что я назвал алгоритмом в этом докладе, пересекаются и соответственно на основе алгоритмиков, которые в ВТАА сформированы, есть возможность вычислительные алгоритмы описать. И дальше в описании, которое формируется внутри теории ВТАА, есть возможность все те же самые результаты использовать в плане вычислений и вычислительных методов, в плане вычислимости как таковой, как это в теории алгоритмов указывается. Единственное, для того чтобы уже об этом рассказывал, для того чтобы себе область задать именно того, что мне необходимо от алгоритма, я на текущий момент выпилил из всего чего, из доклада, из книжки, выпилил все математические, как наиболее сложные варианты алгоритмов. и все вычислительные способы нахождения. И сосредоточился исключительно на микроспособах, которые позволяют вот еще нету ничего и уже сформировать какую-то маленькую единичку алгоритмическую. Возможно, время дойдет и до вычислительных алгоритмов в том виде, в котором описано было в той книге, которую Вы упомянули. 

S01 [01:33:05]  : Спасибо. Следующий вопрос от Сергея Терехова. Сергей, я Ваш вопрос задам, а Вы потом, может быть, сами голосом включитесь и оставшиеся вопросы зададите. Вопрос такой. Достаточно ли только об условленности? Условие может далее быть совместимым с большим числом следствий, а они далее все еще более широкий набор непротиворечивых условий следствий. В итоге сильно ветвящийся процесс. Как из него выделить полезную повторяющуюся цепочку? Насчет полезных повторяющихся цепочек только небольшой спойлер. Спойлер про выделение полезных повторяющихся цепочек я буду на своем семинаре рассказывать через три недели или через две недели. В конце мая. Поэтому приглашаю. К вам вопрос. Как вообще выделять повторяющиеся полезные цепочки в сильно ветрящихся процессах? 

S02 [01:34:02]  : Хороший вопрос. Мне он нравится. Как я себе это представляю для того, чтобы систему, вот мою, которую я анекдотировал, для того, чтобы выделять эти последовательности, ее нужно по факту не предъявлять ей сразу большие обусловленные последовательности. То есть нельзя зашумлять сигнал обучения, которое состоит сразу из большой сложности структурно-последовательства обусловленной. Оно рассредотачивает и не дает выцепить маленькие части. То, что я делал, я по факту последовательно предъявлял системе сначала маленькую структурку, потом другую часть структурки, потом объединенные структурки. Это позволяет, с одной стороны, уменьшить сложность, если предоставить ей сразу всё, обучиться. С другой стороны, это часть обучения как копирование обучения. чтобы не впадало в это, когда экспоненциально распространяется. То есть граф большой, чтобы весь его проанализировать, чтобы уменьшить этот разрост, ей нужно предоставлять маленькие образцы. Возможно, данный подход не гарантирует полного изучения системы всех вариантов дообусловленности для качества обусловленных сложных графиков, структур, но все за бесконечное время возможно сделать, а время всегда ограничено. Вот как вариант вот такой. Возможно, да. 

S01 [01:36:00]  : Спасибо. Сергей, вы будете еще задавать вопросы? Ну, если позволите. Да, давайте, Сергей, давайте вы, так сказать, выбирайте. Ага, хорошо. 

S00 [01:36:11]  : Я начну, Алексей. Во-первых, большое спасибо вам за доклад замечательный. И потом отдельное большое спасибо за замечательную ссылочку на работы Лучана о Флориде, которую у вас в конце, в вашем вики, в вашей книге. Я, кстати, ссылочку на эту часть вашей вики еще раз сюда бросил в чат, для того, чтобы коллеги тоже посмотрели. Вообще, я очень рекомендую всем почитать эту статью Лучанова в Флориде по поводу информации, по поводу ограничений в теории философских вопросов, связанных с информацией. Он и аналитически интересный материал, и, так сказать, комплексный очень и так далее. И Алексей, это просто респект. Я, что называется, вот без вас бы я это не увидел. Оказывается, вот такой большой пласт. Так что это вот, я начал со спасибо. Теперь вопрос, собственно, вот у меня группа вопросов, я тогда, с вашего позволения, пройдусь по ним. Антон, а вы модерируйте, если наша беседа затянется, то, пожалуйста, жестко отсекайте, потому что я могу улечься. У меня вопрос касается обусловленности, он был задан неспроста, потому что вы упомянули работы по причинности и Джуди Пирла, и потом как-то так сказали, что причинность это нечто субъективное, а вот нам достаточно обусловленности. Фактически получается так, что обусловленность это гораздо более мягкая вещь, чем причинность. А вот причинность-то, она позволила бы вам вообще-то семимильными шагами двигаться по вот этому графу. То есть если бы вы не просто позволяли происходить всему, что не противоречит условиям. То есть в мягкой форме, значит, ветвиться так вот не противоречит условиям. Например, факт известен, человек мужчина. Ну окей, значит, там 50% всего, что на свете происходит, сразу автоматически у вас этому условию не противоречит. И так далее. Это слишком мягко получается. А причина, если она позволила бы двигаться дальше. Но это вопрос о том, зачем она нужна. В этом смысле обусловленность может оказаться не... Ну, вы, собственно, ответили на этот вопрос. Она приводит к сложным задачам. Хорошо. Да. Теперь вот смотрите. Вот там еще вы упомянули о том, что... Фактически вы помещаете нечто в некий бульон, в котором происходит соревнование знаний, систем знаний, и, соответственно, там выживает определенная система знаний. Но хорошо известно, что более широкая система знаний далеко не всегда выигрывает соревнования в более узкой системе знаний. Но при условии, что это вторая более узкая система знаний, она более приспособлена к конкретному условию. А соревнование, как вы сами понимаете, оно всегда происходит в конкретных условиях, не бывает абстрактных соревнований. Соревнования всегда конкретные. И получается, что эта более широкая система знаний, она становится фактически беззащитной. Мы это видим в том числе и в нашей сегодняшней социальной жизни. Например, буквально я приведу простой пример. Обратились руководители на уровне правительства ученым к нашим, так сказать, Академии наук в отношении новых разработок фундаментальных. Те сказали, что нам обязательно нужны разработки на десятилетнем масштабе развития и так далее. На что мудрый зам предправительства сказал, коллеги, но если бы у нас при борьбе с ковидом, при создании вакцины, мы бы вот так вот рассуждали, то где бы мы сейчас с вами были? То есть получается так, что более узкое, более конкретное знание, какие-то наработки быстро примененные, они побеждают в конкретных условиях. И вот я хочу в этом смысле сказать, что если вы просто хотите соревноваться на уровне знаний, то это тоже опять путь, который может вести к очень большим ветвлениям и так далее. Но это, наверное, комментарии, если вы потом можете на него ответить. А вот тут дальше у меня есть уже конкретный вопрос. А именно, вот вы говорите, как ремедлить, как средство для лечения вот этой задачей сложности, которая здесь возникает. Использование отдельных небольших фрагментиков, маленьких порций, которые вы постепенно наращиваете и так далее. Но здесь возникает очень важная проблема. Как независимо оценивать полезность этих маленьких порций, этих маленьких модулей? Ведь, на самом деле, по-настоящему полезность результата возникает только в конце, когда они объединились в какую-то большую существенную цепочку, и тогда мы можем, условно говоря, приписать им какое-то состояние их ценности, полезности или, по крайней мере, небессмысленности. А вот пока они на уровне элементарных маленьких фрагментиков, какой механизм придумать, кроме Учителя, кроме Supervision? Какой механизм придумать, который мог бы их оценить? А вам ведь это нужно для того, чтобы отпор дальше проводить? Вот это уже вопрос. Есть еще дальше потом вопросы. 

S02 [01:41:12]  : кирпичик все как таковое эволюционная в том смысле как маленькая сейчас сейчас сформулирую когда сложный эволюционное развитие именно в том формате я его постулирую когда вы имеете возможность систему из одного рабочего состояния перевести в следующее рабочее состояние маленьким изменением. То есть это не набор алгоритма быстрой сортировки, единым образом Ops сгруппировал, выпилил из него один оператор, он сломался и не работает. то есть вот когда слово там эволюция у меня произносится это именно то как я проекты программы делать вот у меня есть некоторые маленькие рабочая штука и и я к этой маленькой рабочей элементами добавляю проверенный, проверенный повторимостью, проверенный уже полезностью, например, если это вот маленький кирпичик, выявленный только что из среды, то это способ на основе того, повторится в следующий раз это или не повторится, если я его выполню, точно так же приведет к тому же поведению или нет. 

S00 [01:42:29]  : Вывели-то вы его как? Вот то, что если он уже у вас выявлен и находится в вашем арсенале, тут вопросов никаких нет. А вопрос у нас у всех состоит в том, а как его выявить изначально. 

S02 [01:42:41]  : Выявляется на основе того, что у вас яблоко все время падает. То есть вы имеете возможность наблюдать за внешней средой и уже в ней есть некоторые процессы, которые повторяются, то есть даже просто транслируя. 

S00 [01:42:59]  : Но это простые только вещи, так только простые вещи вы можете открыть. 

S02 [01:43:04]  : В том смысл, что получаются маленькие кирпичики, именно в том их и суть, что они просты, что они выявляются из среды простым способом. а сложные способы формируются группировками или смещением этих выводов. 

S00 [01:43:20]  : Алексей, я здесь, к сожалению, вынужден немножко такой вопрос корректирующий для себя и для вас задать. Дело в том, что вы же прекрасно понимаете, что существует так называемая сложная система. Такие системы, которые не сводятся к свойствам простых. Не получается ли, что таким способом вы можете создать простые алгоритмы? которые не будут решать проблемы сложных систем, выявления внутренней степени свободы, которые не сводятся к отдельным элементам. 

S02 [01:43:57]  : Интересный переход к первому вопросу этого слайда. Вычислительный алгоритм и алгоритм поведения. Вопрос очень важен и нужен. Насколько действительно можно сложный алгоритм вычислительный? развить из маленьких, вот теми шестью методами, случайный поиск, накопление, группировка, перенос и перенос, трансляция и моделирование. Насколько данная система позволяет порождать сложные вычислительные алгоритмы, не отвечу. Я очень… Как это сказать? Гипотеза у меня, что есть такая возможность. И еще вторая гипотеза о том, что если добавить к этим шести методам, может быть, еще седьмой какой-то, то есть такая возможность. То есть это гипотеза перехода от элементарных алгоритмов поведения, формируемых вот этими шестью методами, и в итоге самым большим в развитии это, естественно, учительные алгоритмы сложные, которые не формируются разово. алгоритм сортировки быстрый, разделяя властвую метод, власть, перенос и дополнительные методы. и в сложных алгоритмах есть возможность переносом из нескольких маленьких сложить его. 

S00 [01:45:24]  : Ну да, но на самом деле фактически вот утверждение, оно на самом деле вот так вот расширительно может быть понято так, что коллеги, а на свете-то и нету сложных алгоритмов. Это нам кажется, что у нас есть сложные алгоритмы, а на самом деле... 

S02 [01:45:37]  : Имеется. Знаете, самый сложный алгоритм, который я себе видел, это те, которые, например, функционируют в искусственных нейронных сетях. То есть есть некоторая структура, которая исполняется, которая внутри взаимодействует, внутри обусловлено вычислительными, детерминированы все процессы, а снаружи алгоритм сложен настолько, что он не сводится к тому, что его можно эволюционно развить, но он сводится к тому, что его можно создать, создавая INS, интерпуляция, моделирование и создавая тем самым, то есть вот она вроде сложность, она не формируется эволюционно, но при этом создать ее можно методом, когда ты собираешь ее по частям, собирая инвес, а не алгоритм, который она реализует. 

S00 [01:46:35]  : Ну да, но там есть тоже свои комментарии о том, что мы там получили ИОНС, а потом говорят, а потом говорят, а ну-ка вот попробуйте собрать и алгоритм, не получится. Ну конечно, а по стереоре не получится, а как бы, ну хорошо, окей, это философия. А вот еще последний вопрос, смотрю, Антон уже начинает нервничать, поскольку я просил его тормознуть меня, значит, вот как бы. смотрите начать алексей только вот ну это никто не тому что я как-то там критикантом занимаю люблю критику да но просто данном случае просто хочет структурировать немножко для для для для для себя но и может быть и поскольку юрия бобуров похоже опросы то вот какой у меня вопрос у смотрите вот существует вполне себе очень хорошо проверенно надежно Такая зафиксирована область под названием абстрактные контейнеры, алгоритмы C++, стандартная библиотека классов C++. Там продумано на уровне абстракции настолько широко и настолько глубоко. один класс там хрона чего стоит где там абстракция времени продумана там плод там чуть ли не знаю там можно инновационные там представление любую философию времени вложить вот от хрона там все устроено хотя вроде как это если так просто это квинтэссенция потрясающая совершенно да да красота вот есть вот это вот начистоте вот вот это вот есть такая вещь да такая утра знаний Есть второе разознание, которое тоже очень широкое, это генетическое программирование. о котором вы тоже многократно говорили, это фактически мы когда не просто функцию оптимизируем, выбирая код, а мы строим алгоритм, который и там огромный, тоже совершенно безбрежный пласт, совершенно каких-то таких достижений, как это делать. Простейшие вещи на дереве знают все, а на самом деле это очень большая гибкая конференция, можно посмотреть там тоже очень много чего. Вот мы берем эти два столба пограничных. Первый столб условно говоря назовем оси плюс плюс, а второй столб назовем генетическое программирование. Последние ваши слайды, примерно шесть, собственно вы и назвали шесть этих слайдов, они при таком взгляде, скажем так, при каком-то взгляде могут вообще-то рассматриваться как некоторые очень специальные, но все-таки операторы, которые применяются в генетическом программировании. Интерполяция между этими вещами, смещение и так далее. И вот отсюда возникает такой философский вопрос. Если это не C++ с его абстракциями или если это не генетическое программирование, то осведите, пожалуйста, вот ту новую третью составляющую, которую вы сюда добавляете своим докладом, в сравнении с тем, что мы все хорошо знаем, что существует C++ и знаем, что есть генетическое программирование. И еще раз спасибо за ссылочку, чтобы потом не возвращаться к этому разговору. Спасибо огромное. 

S02 [01:49:33]  : Спасибо большое. Очень хорошо. Мне нравится. 

S01 [01:49:39]  : Хорошо. Сергей, вы свои вопросы еще упали, да? 

S02 [01:49:42]  : Отвечу. 

S00 [01:49:43]  : Нет, я... Последний вопрос еще пока не задан. Я его задал, но ответа не получил. 

S02 [01:49:51]  : Очень, да, реально похоже, что это развитие генетических алгоритмов. Возможно, даже вот не возьмусь, насколько оно пересекается, насколько полностью. К этому, к этой части, как я себе вижу, то, чего вот я в генетических алгоритмах не нашел, это то, что из среды как выделить то, что будет алгоритмом, то есть как при взаимодействии некоторой алгоритмической системы или просто агента со средой, как маленькие кирпичики для генетических алгоритмов, как их выцеплять. То есть, да, генетический алгоритм хорошо, оно их группирует, оно их перетасовывает, оно работает с ними, усложняет и решает задачи. Но среда изначальная и то, как из нее знания достаются, ну, знания алгоритмические, да, и как вот этот кирпичик с ним работать, я не видел. Есть возможность, что плохо искал. 

S00 [01:50:57]  : Да, там есть направление, когда сами среды тоже эволюционируют. И более того, там есть много компонентные вещи. То есть, скажем, часть агентов формирует в среду консепт, а какая-то другая часть агентов в этой среде научается там работать. И что-то еще. И в результате получается, что там вот эти все аспекты, они там на разных планах рассматриваются. Я просто думаю, что генетическое программирование – это очень широкий такой термин. Просто вот хотелось услышать, нет ли вот тут какого-то такого, ну совсем вот несводимого, не знаю, вот я в качестве гипотезы там в чате бросил такой вариант, что вот вы рассматриваете, условно говоря, там, значит, некую посылку, алгоритм, потом некое действие, потом пробу применения этого действия в новых условиях, и если повезло, то запоминание этого дела, да, вот такой процесс как бы, да? Но если теперь этот процесс рассматривать как мета-процесс и применить его к самому процессу, мудриться это сделать, то вы уже получаете какую-то рассуждалку. То есть вы получаете уже способ на мета-уровне вот этим своим процессом, так сказать, работать. И если вы дальше будете двигаться по рекурсии вот на таком образом, то это, возможно, вас придет к чему-то очень интересному. Вот вы на эту тему не размышляли, применить то, что вы делаете, к самому процессу. 

S02 [01:52:14]  : Я понял, да. думал факту получается там схемки чуть не было блок алгоритмов он размыкается и внутри формируется такая же штука которая является средой то есть нет Вот эта вся штука внешняя вместе с алгоритмами, которая получилась, она уже является средой для внутреннего блока, который манипулирует данными алгоритмами уже как средой, позволяя выполнить манипуляции уже теми действиями. Как это сводится к способам? К иерархии-то. Я про иерархию мало что рассказал. Получается, 

S00 [01:52:58]  : Вопрос кодирования вам надо решить. Кодирование этого процесса. Ну окей. Хорошо, Алексей. Но это уже обсуждение того, чего не было во время доклада, поэтому я прошу прощения. Коллеги, извиняюсь. Всё, Антон, я закончил. 

S01 [01:53:14]  : Хорошо. Спасибо, Сергей. Есть еще пара вопросов от Игоря Пивоварова. Во-первых, зачем алгоритм обучаться? Копировать что-то или подражать? 

S02 [01:53:27]  : Алгоритму самому по себе мало что необходимо. То есть алгоритмической системе обучаться необходимо, если она нужна если ей необходимо выжить, если это биологическая предметка, если это алгоритмическая система, которая находится в моем макете, то ей необходимо обучаться для того, чтобы я ее не удалил с диска, для того, чтобы она решила мою задачу, я ей направляю необходимости, рулю необходимости. Я надеюсь, что она никогда не будет рулить сама свои необходимости. Это был как раз один из вопросов, цель AGI. У меня, в моем представлении, системы, которые решают задачи, которые обучаются, они решают мои задачи, они сами для себя что-то делают. 

S01 [01:54:25]  : То есть, цели полагания у них, получается, нет. Получается, что если система обучается, то она выживает, а если не обучается, то не выживает. 

S02 [01:54:35]  : Хороший был семинар в январе про то, как AGI выпустит в реальный мир. Да, целеполагание ее. С одной стороны, оно необходимо для того, чтобы решать задачи, то есть цели, подцели, ну, там как структуру, алгоритм, чтобы выстроить, а с другой стороны, если она начинает ставить себе цели, то сложно их контролировать. И очень классно, безусловно, мне очень понравилось тогда, действительно, как задать, как обучить ее таким образом, чтобы она чтобы она стала не джинном, а тем, что будет решать мою задачу. Алгоритму обучаться не нужно, если вы отвечаете на вопрос так. А мне нужно. 

S01 [01:55:22]  : Хорошо. Следует еще пара вопросов от Игоря. Во-первых, как, на ваш взгляд, связан алгоритм с интеллектом? А точнее, как выглядит переход алгоритм-поведение-интеллект-мышление? в моем порядок мышления потом интеллект я вот ваши вопросы горячий алгоритм поведения интеллект мышления 

S02 [01:55:52]  : Поведение – это набор алгоритмов, доступных некоторым организмам для того, чтобы выживать. Дальше, мышление – это способ модельного развития, с использованием моделирования, развития системы алгоритмов. с возможностью чуть было о том, чтобы предсказать среду про иногда неосознанно даже, то есть это способ с помощью моделирования внутреннего разработать алгоритм, который поможет тебе выживать. И дальше мышление. А интеллект, я бы сказал, что я бы добавил сюда язык. Язык и озвучивание, осмысление, символическое Я бы сказал, что интеллект – это там, где начинается язык, и там, где модели, которые используются в построении алгоритмов поведения, умеют использовать символы для означения некоторых процессов и для моделирования символического. Наверное, вот в моем словарике это где-то такая вот ступенчатая иерархия. 

S01 [01:57:14]  : Ну и вот здесь сразу же Игорь задаёт вопрос, подводящий или наводящий. А зачем алгоритму вообще обучаться? Я так понимаю, на него вы ответили, что алгоритму обучаться вообще не нужно. А мышление ему нужно? 

S02 [01:57:35]  : В системе, которая использует, есть система алгоритмическая, которая сама исполняется, сама развивается, сама функционирует и сама себя сохраняет или решает какую-то задачу мою внешне, она имеет необходимость сохраняться, а для этого она может использовать некоторые алгоритмы среды, алгоритмы поведения для того, чтобы это исполнить. Вот в такой системе необходимо ей наиболее эффективно строить алгоритмы для этого необходимо использовать все возможности и символическое моделирование и если это возможно научиться у родственника обучиться или обучиться в среде то есть для того чтобы выполнить некоторую внешнюю цель. Для биологических организмов это цель, понятно, сохранить самого себя и оставить потомство. Для системы, которая в моем инкубаторе делает какие-то задачи, задача вот эта приоритатива для нее. дальше вольности получается, насколько предоставить ей возможности манипулировать чем-то вне контекста задачи, потому что иногда, собственно, не только внутри задачи есть решение этой задачи, но и, например, в биологической клетке есть подсказки, насколько снаружи изучение и знания могут помочь ей решить эту задачу. В общем, интересный вопрос. 

S01 [01:59:15]  : Спасибо. А еще вопрос. Вот меня здесь наткнулся. Когда мы говорим алгоритмы и связываем в связи с эволюцией, вообще в какой момент алгоритмы появляются? То есть, начиная с вируса или начиная с клетки, когда можно говорить о алгоритмах? 

S02 [01:59:34]  : Тоже хороший очень вопрос. И этот термин, я его спускал в разные места, и в итоге Вот этот кирпичик я в итоге тоже в рамках теории алгоритмом называю. То есть элементарное преобразование повторимое в среде, которое возможно. я его тоже в ВТА называю алгоритмом, но это условность рекурсивная, то есть алгоритм состоит из алгоритмов, и вот минимальные кирпичики – это тоже алгоритмы, можно так назвать. Можно назвать нижнюю ярусь кирпичиками, действиями, например, тогда действия состоят из алгоритмов. Где начинается алгоритм в плане вируса? Вирус – это структура, которые способны исполнить алгоритмы своего копирования. Это знание в структуре, которое способно запустить исполнение, выполняющее вот тот процесс самокопирования. Это вирус. 

S01 [02:00:42]  : То есть, начиная с вируса алгоритмы начинаются? 

S02 [02:00:45]  : Меньше есть. 

S01 [02:00:46]  : Что-что? 

S02 [02:00:47]  : Меньше тоже есть. 

S01 [02:00:49]  : Где, например? 

S02 [02:00:51]  : Для алгоритма как такового неважно самокопирование. 

S01 [02:00:58]  : В природе, в эволюции, где есть алгоритмы более простые, чем вирусы. 

S02 [02:01:04]  : То есть, там тоже есть алгоритмы? По факту повторимые взаимодействия. 

S01 [02:01:11]  : Окей. Хорошо. Ответ принят. Спасибо. Дальше группа вопросов от Юрия Бабурова. Юрий, если вы еще с нами, просьба тогда, может быть, подключиться. Давайте. 

S03 [02:01:21]  : Я не буду задавать все вопросы, потому что на часть вопросов докладчик частично ответил. Задам, поэтому начну. с середины. значит, вот ваша система, в общем-то, по сути дела, вы говорите про теорию вычислимости, хотя и не затрагиваете вопрос проблемы останова хоста, значит, именно так. не затрагиваете, да. По сути говорить, что вот есть у вас виртуальные машины, в которых крутятся какие-то алгоритмы. Говорите о том, что есть какой-то или генетический алгоритм, или какая-то технология для получения более сложных алгоритмов. Но вот вопрос, будет ли система генерировать более сложные и более полезные алгоритмы вообще? Или алгоритмы будут зацикливаться, выдавать всякую чушь? Ну и в продолжении этого же вопроса, на чем основана вообще ваша уверенность в том, что сложный полезный алгоритм складывается сам из простых под действием естественного отбора среды? 

S02 [02:02:42]  : Почему нет? Есть алгоритмы? 

S03 [02:02:45]  : Если в ответ почему нет, то это пока что вера просто. 

S02 [02:02:51]  : По факту у нас есть набор алгоритмов каким-то образом синтезируемых генетически, генетически. Мои теории еще каким-то образом произведены. И дальше некоторые из них полезны, а некоторые нет. Полезные останутся. Подождите, что значит некоторые полезны, а некоторые нет? 

S03 [02:03:15]  : А кто судит, какие из них полезны, а какие нет? 

S02 [02:03:19]  : Например, я, если я снаружи наблюдаю за системой. 

S03 [02:03:24]  : Тогда мы получаем просто программирование. То есть вы как программист берете и пишете алгоритмы. Пишите программы. 

S02 [02:03:32]  : Что тогда нового у вас? Я пытаюсь сделать систему, которая будет писать программу вместо меня. Она будет исследовать… Язык программирования может написать программу вместо вас. 

S03 [02:03:54]  : Компилятор может написать программу вместо вас. 

S02 [02:03:56]  : В среде. Каким образом подавать, если задать текстовым заданиям есть возможности. Предоставляю некоторой системе набор возможностей исследования среды. Среда каким-то образом устроена, и в этой среде, по факту, система изучает эту среду и пытается в ней сформулировать алгоритмы, которые я выбираю полезны или не полезны. 

S03 [02:04:30]  : Окей, но не значит ли это, что у системы уже должен быть интеллект, чтобы она могла все это делать за вас? 

S02 [02:04:38]  : откуда он возьмется? в смысле, если она умеет выявлять действия, сгруппировать их в алгоритмы, она уже имеет делать алгоритмы. с интеллектом в моей трактовке она еще языком не владеет, поэтому, наверное, Интеллектом она еще не обладает. Когда она сможет со мной общаться с естественным языком, наверное, она будет обладать интеллектом, если это будет для решения задач. 

S03 [02:05:07]  : То есть, говорите, если она будет работать, то она будет обладать интеллектом? 

S02 [02:05:13]  : Если бы был готовый образец того, что будет уже общаться по-человечески, я бы говорил не «если», а «если». Говорю именно по этой причине. 

S03 [02:05:29]  : Да, я понимаю. Давайте я еще раз переформулирую немножко по-другому тогда. Надеюсь, время у меня еще минутка есть. значит, смотрите, есть древняя такая мысль о том, что у искусственного интеллекта есть некоторые градации мощности, крутости. так же, как у классических алгоритмов, есть более сложные алгоритмы, которые сделаны из простых, следовательно, более сложные алгоритмы, у них больше участвительная какая-то мощность. у вас получается, что более сложный, вычислительно более мощный алгоритм может написать более простой. а вот гипотеза о том, что вычислительно более простой алгоритм может написать более сложный алгоритм, это вообще гипотеза, которую вы пока что ничем не обосновываете. то есть вы по сути говорите, что ваша система сама магически научится писать сложные алгоритмы для решения сложных задач. я говорю, что получается, что вы вначале должны написать более мощную систему, а ее никто не может написать, более сложную систему или сравнимую уровнем с человеческим, чтобы она писала хотя бы более простые алгоритмы и решала более простые задачи. 

S02 [02:06:58]  : Я вас услышал. Единственное, не совсем пойму, как я такое говорю. Говорил ли я такое? Я пытался сформулировать, что есть возможность автоматически, без моего вмешательства, некоторым образом заставлять маленькие систему из маленьких алгоритмов создавать большие и сложные. И проверять, являются ли они алгоритмами. 

S03 [02:07:33]  : Учислительно сложными они будут, но будут ли они интеллектуально сложными. Что такое интеллектуально сложные? Это вопрос, который вы совершенно пока что не затронули за последние полтора часа. 

S02 [02:07:50]  : действительно интеллектуально сложные сортировки? 

S03 [02:07:58]  : как пример такой задачи, которую вашей системой, мне кажется, не получится решить, я предлагаю задачу такую, что вы берете кубик-рубик, казалось бы, очень простая среда. делайте так, чтобы ваша система, не зная про теорию групп и не зная про то, как собирать кубик Рубика, научилась его собирать. и не зная про промежуточный состояние, которое опять же человек на своем уровне формирует, научилась собирать кубик Рубика. нет, крутить она может, а в смысле понятие близость кубика Рубика к концу сборки 

S02 [02:08:41]  : вот это понятие ваша система, мне кажется, не сможет сформировать. если я ее снаружи буду спонсировать? 

S03 [02:08:50]  : вот, если вы снаружи скажете, что есть такое понятие, что система ближе теперь к концу сборки, то да, но вы же хотите, чтобы она без вас работала? 

S02 [02:09:00]  : нет, не хочу. не хотите? 

S03 [02:09:02]  : то есть вы хотите инструментарий для поддержки вашего программирования? 

S02 [02:09:09]  : в смысле, зачем мне система, которая будет бессмысленно какие-то делать? 

S03 [02:09:15]  : Нет, я скорее про другую, что вот вы даете ей задачу, она дальше самостоятельно по этой задаче работает. Или же вы даете ей задачу, она снова у вас спрашивает, а как мне эту задачу решать? А вы ей говорите, вот первым шагом сделай то-то, вторым шагом сделай то-то. Она такая, ага, поняла. Первым шагом я делаю то, вторым шагом я делаю... Все, задача решена. Спасибо, создатель. 

S02 [02:09:36]  : не совсем в основном случае в моем моем Я себе по-другому это представляю. Зачем обучать ее всем действиям последовательно? Когда я рассказываю, что мне необходимо было увеличить скорость ее обучения тем, что я ей подсказываю, мы и детям подсказываем. то есть я своему ребенку не говорю сразу кубик рубик пожалуйста реши да или что-нибудь вот смотри кубик рубик смотрите с ним дальше что и что значит, что мой ребенок странный, неинтеллектуален, то есть я ему тоже внешне даю за это. 

S03 [02:10:26]  : ну да, интеллект ребенка меньше интеллекта взрослого как раз, потому что взрослый, ну не всякий взрослый, может научиться в книжке или где-то. алгоритмы кубика-рубика сборки найти, например, или придумать теорию группы изучить на основании этого, разложить по теории группы механизм, которым может собираться кубик-рубик, или придумать, поделить все алгоритмы движения кубика-рубика каким-то образом. 

S00 [02:11:01]  : Алексей, ну вот Юрий на самом деле вот спрашивает, он такую четкую мысль хочет от вас услышать. Фактически получается, что вот ваш вот этот способ оценивания, в том числе промежуточных ситуаций, не только окончательных, которые можно оценить по факту достижения успеха, а еще и промежуточных ситуаций, он включен в вашу систему. То есть он у вас является неотъемлемой частью вот всего того концепта, которого нам рассказывают. И в этом смысле должен быть кто-то, кто вот этим способом оценивания уже обладает. Вот то, о чем говорит Юрий. Вот он просто ждет, если вы скажете да, то тогда он задаст вопрос, откуда возьмется вот тот первый оценщик, который правильно мог его оценивать. 

S02 [02:11:42]  : Я понял, вас услышал. 

S00 [02:11:44]  : Юрий, я правильно формулирую то, что ты спрашиваешь? 

S02 [02:11:47]  : Абсолютно верно. Я теперь понял и пытаюсь теперь ответить. В моей системе, моя система, то есть как я себе ее вижу для того, чтобы я ее продуцировал, для того, чтобы она решала задачи, которые необходимы мне. Поэтому я могу задать эту задачу в свойствах среды, для того чтобы среда сама каким-то образом… я ставлю задачу. То есть не система ставит задачу и спонсирует себя каким-то образом, биологическим способом, выживая или что-то такое. Я ставлю задачу, я кое-где помогаю, кое-где не помогаю. Кубик Рубик, если мне нужно решить, я буду кормить его больше... не буду кормить, Среда будет кормить. А чем Среда будет кормить? Поместить этого агента в Среду, которая будет его спонсировать каким-то образом. 

S03 [02:12:51]  : Смотрите, вот чтобы Среда его спонсировала каким-то образом, Среда должна его понимать, чем его спонсировать. вот чем вы будете спонсировать при сборке кубика-рубика алгоритм? даже, например, да, вот вы реализуете, на самом деле, придумали эвристический метод. то, что вы будете выступать в качестве эксперта, а ваши эвристики вы будете вкладывать в алгоритм. хорошо, но вот как вы конкретно эту задачу будете решать? вашего метода. 

S02 [02:13:21]  : давайте рассмотрим. 

S03 [02:13:33]  : не будем углубляться в детали, просто то, что когда в качестве этого эксперта выступает человек, когда компьютер решает задачи, и потом мы переносим его в знание, это называется версическими. не будем углубляться дальше. вопрос, как конкретную задачу решить с помощью вашей теории, с помощью вашего подхода. задача сложная. 

S02 [02:14:02]  : с простыми задачами все понятно. когда кубик Рубик собирал в детстве, она будет точно так же решать. гонять кубик, смотреть закономерности, выстраивать одну грань, действия в алгоритме… выстраивать одну грань, то есть вы будете компьютеру говорить, что вам нужно… компьютеру надо выстраивать одну грань, цель выставлять. 

S03 [02:14:25]  : если среда будет оценивать… откуда среда узнает, что алгоритму нужно первую грань собрать? 

S02 [02:14:35]  : она будет радоваться четырем вместе рядом стоящим двум. 

S00 [02:14:40]  : нет нет нет, это вы будете радоваться, она не будет. 

S02 [02:14:43]  : у нее есть собранный кубик и все, больше ничего. если я создаю среду. то есть вы сразу будете создавать среду с подсказками. агенты, которые манипулируют этим кубиком, рубиком. я имею возможность в эту среду подкрепление завязать на то, какое количество грани. 

S03 [02:15:05]  : ну то есть у вас тогда получается обучение с подкреплением и вы сами задаете за что штрафовать, за что награждать. 

S02 [02:15:13]  : ну а почему нет? почему мне такое нельзя что ли делать? 

S03 [02:15:17]  : да нет, можно, только при чем тут то, что вы до этого рассказывали полтора часа? пока что совершенно ни при чем. 

S02 [02:15:25]  : почему ни при чем? система подкрепления обучения и подсказок и всего-всего она работает на базе того, что внутри крутятся и способами, вот теми, которыми я описывал, эти вот штуки слепляются таким образом, можно назвать генетическими алгоритмами хорошо, хорошо развитыми генетическими алгоритмами с несколькими способами. 

S03 [02:15:50]  : У генетического алгоритма нет понятия функции, там награды, промежуточных наград. 

S02 [02:16:00]  : И что мешает мне добавить в моей системе, если ее нет в бюджетном уровне? 

S03 [02:16:05]  : Ничего не мешает, это просто не будет называться бюджетной системой. 

S00 [02:16:07]  : Алексей, да, это будет называться близко к Supervision вообще. Вот понимаете, Юрий про кубик говорит просто образно. Представьте себе, что задача стоит следующая. Создайте новую экономическую систему, которая на планете более хорошая, чем сегодняшняя экономическая система. Я не знаю, какие промежуточные состояния правильные. Я тоже. Понимаете? Вот если вы знаете, какие состояния промежуточные правильные, можете, так сказать, их оценить либо прямо прямой оценкой, либо косвенной оценкой подкреплением, что на самом деле не очень большая разница. Вот. Тогда да, тогда фактически вы решаете решенную задачу, будем так говорить. Решение решенных задач. А мы здесь сейчас, и вот Юрий прежде всего спрашивает постоянно, и Игорь, который ушел тоже на эту тему спрашивает. Мы здесь все про сильный искусственный интеллект, то есть про решение задач, решение которых мы, в общем-то, не знаем. И не знаем, какие промышленные шаги приводят к решению этих задач. И вот возникает такой вопрос. Ваша методология, она вообще, в принципе, вот в эту сторону она может двигаться или что-то ей надо помочь? Либо же она находится в области вот этого, будем так говорить, в области обучающих систем, адаптивных систем, которые адаптируются под Supervision. 

S02 [02:17:16]  : Я ещё раз услышал, ещё раз спасибо. Как я себя вижу, она находится в зоне, в той же самой, что и человек находится. То есть, если ещё раз переведя, даже мне, взрослому человеку, сказать задачу, реши мне, пожалуйста, экономическую систему построить супермегаидеальную, с промежуточными состояниями, Буду думать и не придумывать. В виде того, что специализации у меня нет в области, я это и не изучал, и не имею сведений и знаний. И дальше начну изучать, смотреть, сопоставлять кирпичики мелкими. Если готового решения нет, я буду его собирать маленькими порциями. подкреплением будет а чтобы подкреплением вот мы вот сейчас в экономической ситуации экономическая ситуация такая какая есть давайте попридумаем какой способ исправить ситуацию если дальше переходить, я понял, в направление движения, то есть есть некоторая система, которая позволяет крутить алгоритмы, из маленьких создавать большие, некоторым образом ее двигать, некоторым образом направлять движения, отсеивая какие-то неправильные или ложные несрабатывающие решения. Есть способ направлять эту моделью, обужая область некоторым образом трансляциями. Но нет, как это, волшебной палочки нет. Если вернуться к первому слайду, эта система не позволяет лучше, чем человек, строить алгоритмы. Даже я сажаюсь за компьютер, когда у меня какая-то задача есть, муки, подкрепления, зарплаты или еще чем-то. А иногда задача нерешаема, как в курочке ряда. 

S03 [02:19:22]  : Зарплата – это верхнеуровневое подкрепление. Вот как раз и вопрос, насколько сложный. 

S02 [02:19:27]  : У меня тоже такая ситуация есть. Если вы думаете, что любой алгоритм реализуем, нет. Нет того, что все алгоритмы возможно построить. 

S03 [02:19:41]  : Нет, конечно нет. Вопрос в том, насколько алгоритм работает самостоятельно и насколько вы ему помогаете. то есть если вы ему каждый шаг практически помогаете и вот прям вот подробно-подробно ему подсказываете, что делать, это одна система. 

S02 [02:19:56]  : правильно вы сказали, каждый шаг помощи это практически я сижу и пишу текст программы. смысл конечно не в каждом шаге, а в том, чтобы он имел возможность самостоятельно проработать что-то без моего участия, без того, что я ему говорю, что вот за А в среде следует Б, чтобы он это сам увидел, задетектил и в некоторых случаях попользовал, в некоторых, если не пригодится, не попользовал. если он увидел три рядом и четвертая переползла грань он следующий раз четвертую грань перепридет приведет и но найдет ли он решение вот я могу я могу сказать что некоторые алгоритмы решений даже я не буду я не найду я 

S03 [02:20:48]  : это понятно. для великой теоремы фирмам вообще никто не найдет, условно говоря, решение. более того, известно, что есть алгоритмы, есть задачи, которые не решаемы. не могут быть все задачи быть решаемы. так что это нормально как раз. Вопрос именно как раз в том, кто кого больше поддерживает, алгоритмы или алгоритмы. 

S02 [02:21:13]  : Я когда изначально мыслил об этом, думал, что эта система не будет круче человека. То есть это миф, что она будет прямо супер всемогущей. Вас не слышно? Вас не слышно. Микрофон выключил. Антон, вы нам говорите. 

S01 [02:21:39]  : Да-да, извиняюсь. Я просто хотел сказать, что нам уже надо закругляться. И тут есть еще один вопрос от Владимира Смолина. Он его, правда, явно не задал, но я хочу задать. Вы, Алексей, знакомы с понятием quick learning QL или deep Q-learning DQL? Читал. Читали. То есть, оно вам не представляется полезным или, наоборот, вредным? 

S03 [02:22:07]  : Антон, давайте на этот вопрос, может, я отвечу. 

S01 [02:22:10]  : Нет, у меня вопрос все-таки к Алексею, не к вам. Почему не надо на этот вопрос отвечать? Ой, Юрий, можно я все-таки задам вопрос спикеру, хорошо? 

S02 [02:22:23]  : Очень полезно. Всё полезно. Всё, что повторимо, всё, что можно попользовать в качестве элементов и кирпичиков для решения задач, даже если это как-то угодно реализовано, полезно и может быть употреблено и в моей системе, и просто для моих задач, которые приносят денежку. 

S01 [02:22:47]  : Хорошо. Юрий, пожалуйста, ваш ответ на наш вопрос. И заодно, может быть, вы хотите заключительные какие-то напутствия нашему докладчику, чтобы нам запомнили? 

S03 [02:22:59]  : значит, почему про dql тут не стоит говорить. dql, дело в том, что dql, как и все алгоритмы, то есть, с одной стороны, policy network — это очень клевая штука, так же, как и a-звездочка алгоритм — это тоже очень клевая штука. в общем, просто там все это на новом уровне повторяется. но у Алексея есть новая часть, действительно. Он говорит не в терминах нейронов и внутреннего представления информации, он говорит в терминах алгоритмов как базовой частички. Поэтому ему dql в этом плане не поможет напрямую. Но с другой стороны, он сам говорит, что reinforcement learning он в общем-то не против использовать и собирается использовать, поэтому тут все окей. в первую очередь мы разобрались с AI-hard и как раз с различием узкого там узкого и слабого искусственного интеллекта и его отличие от сильного, да, будет ли вот этот помощник сильным или слабым искусственным интеллектом. То есть пока что на текущем этапе скорее выглядит, что это какой-то все же помощник и какой-то слабый искусственный интеллект, да. То есть по классу задачи АДИ это как раз система, которая предполагает, что обладают собственным каким-то целеполаганием. соответственно тут вопрос, есть ли вот этот переход от слабого к сильному, никто не знает для него пожалуй сейчас ответа. то есть может быть это одно и то же, а может это совершенно две разные вещи. то есть может слабый просто при нарастании внутренних возможностей становится сильным, а просто потому что внутренний планировщик становится просто планировщиком, целеполагающим планировщиком заданий. Может быть там что-то у них есть все же, отделяющие друг от друга. В общем, что хочется сказать, взгляд интересный, но меня несколько смущает слишком большое количество теории, которая, казалось бы, повторяет основы компьютер-сайенса. Если компьютер-сайенс переводить на русский, все же это будет, пожалуй, в основном теория вычислимости, а не просто информатика. То есть именно как наука компьютер-сайенс это в основном теория вычислимости и все, что с этим связано. И поэтому интерпретируемость тут только одно из понятий. не был соответственно затронут вопрос, вопрос сложности получаемых алгоритмов, вопрос их вычислительной мощности, скажем так, то есть то, что они способны будут делать. И, соответственно, после этого нужно понимать, за какое время они способны будут делать. потому что такая система теоретически может работать способно, а на практике она будет совершенно неподъемна по существующей вычислительной архитектуре. Соответственно, из этого все следствия. Основное следствие – надо пробовать, надо делать. 

S00 [02:26:35]  : Можно или завершаем? Заниматься. 

S01 [02:26:38]  : да, давайте, Сергей, пожалуйста. 

S00 [02:26:40]  : я хотел просто вот еще дополнительно сказать, что в принципе, вообще-то говоря, если так вот совсем честно, то алгоритмы подключения с подкреплением, когда на лету происходит подкрепление еще не окончательного результата, они не обязательно должны быть рекурсивные, типа DQN. в генетических алгоритмах все то же самое может быть. вы запросто можете оценивать, можете устраивать турниры между пробными решениями, где условием победы в турнирах является какое-то промежуточное состояние, которое вы тоже можете задать. в этом смысле генетическое программирование как таковое, оно в себе обучение с подкреплением тоже содержит. вы не обязаны подкреплять только окончательные результаты, можете промежуточные тоже ставить цели, тоже задавать их и тоже помогать ему таким образом. в этом смысле это тоже общая вещь. Но я-то просто хочу сказать вот такую штуку, Алексей. Похоже, вы на самом деле очень близки к подходу. И один из шагов, который мог бы быть, это если бы ваши алгоритмы научились минимальной рефлексии. То есть они бы попытались создать модель той задачи, с которой они работают, и вот с этой моделью начать по пути сами себя оценивать. На предмет, насколько я сейчас хорошо решаю некую модельную задачу, а вот сама рефлексия. И тогда это было бы уже... Вам ничего не мешает это делать. Вам только надо ввести в систему новую сущность, нового участника, который устроен так же, как и главный участник. Вот эта модель, вот эта рефлексия, она тоже альгоритмизирует. Но тогда вы получаете уже агентов с рефлексией. А это уже шажок очень приличный, потому что вы все реже и реже можете его подкреплять. он все более и более сложной задачей потенциально может решать если модель до если вот эти вот модели самой рефлексии их можно так сказать и передавать друг другу одни агенты могут свои модели отдать другим и тогда когда их много параллельности они могут уже более эффективно работать то есть в принципе на этом пути можно двигаться но действительно агносиологическую проблему происхождения того самого первого кто даст правильную оценку вот этого, ну там, как бы почти божественного того, кто знал ответ с самого начала. Она вот в этом направлении, но она вами не подчеркивается, вы ее не ставите как главную, что вы хотите разрешить. Вот, но она все время у нас имеется в виду в голове у всех, которые здесь присутствуют. И поэтому, когда вообще не видно ничего на эту тему, то мы задаем какие-то вопросы предметные, а внутри, на самом деле, в головах у нас вот та проблема, как же нам того, который знал с самого начала, как надо действовать, как его создать, и может ли он сам себя создать инкрементально, из простого в сложное, без чего-то такого. Еще раз спасибо. Спасибо вам. 

S01 [02:29:33]  : Хорошо. Алексей, большое спасибо. Несмотря на отсутствие практических примеров, большое число вопросов и мнений. Всем спасибо за участие, коллеги. До новых встреч. До свидания. До свидания. 










https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

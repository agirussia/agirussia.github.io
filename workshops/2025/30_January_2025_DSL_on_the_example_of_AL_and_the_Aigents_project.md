## 30 января 2025 - DSL на примере AL и проекта Aigents (продолжение семинара 23 февраля) — Антон Колонин (AGIRussia, Aigents, НГУ, SingularityNET) — Семинар AGI
[![Watch the video](https://img.youtube.com/vi/AGcSQ7KukVs/hqdefault.jpg)](https://youtu.be/AGcSQ7KukVs)

## ВНИМАНИЕ: СЛЕДУЮЩИЙ ТЕКСТ СГЕНЕРИРОВАН ИИ, РАЗРАБОТАННЫМ УЧАСТНИКАМИ НАШЕГО СООБЩЕСТВА!

##Суммаризация семинара:


Основные темы и выводы:

1. Контекст и предыстория:
- Семинар завершает цикл обсуждений про онтологии
- Является частью серии встреч русскоязычного сообщества разработчиков общего и сильного ИИ
- Докладчик делится опытом создания проекта Aigents и специального языка Aigents

2. Ключевые выводы из предыдущих исследований:
- Двухмерные и трехмерные редакторы знаний и семантических графов оказались непрактичными
- Более эффективно работать со знаниями через:
  - Табулярные или древовидные интерфейсы
  - Специализированные языки (DSL)
  - Универсальные языки
- Выявлена проблема удаления знаний в распределенных системах

3. Разработанный язык (Aigents):
- Создан как промежуточный между естественным языком и формальными языками
- Основные характеристики:
  - Использует упрощенную грамматику
  - Поддерживает разные словари (английский, русский и др.)
  - Имеет универсальный синтаксис и пунктуацию
- Типы выражений:
  - Интеррогативные (вопросы)
  - Декларативные (утверждения)
  - Директивные (команды)

4. Практическое применение:
- Использовался для создания агента, работающего в интернете
- Поддерживает интеграцию с:
  - Социальными сетями
  - Мессенджерами (Telegram, Slack)
  - Блокчейн-платформами
- Позволяет анализировать:
  - Социальные взаимодействия
  - Репутационные графы
  - Поведенческие паттерны пользователей

5. Основные выводы из проекта:
- Пользователи неохотно учат новые языки, даже упрощенные
- Предпочитают либо привычные интерфейсы, либо общение на естественном языке
- Проект оказался сложным для монетизации

6. Современный контекст и LLM:
- Обсуждалась возможность интеграции с современными языковыми моделями
- Рассмотрены три подхода к работе с LLM:
  - Использование Tool Framework
  - Работа через промпты и контекст
  - Инкрементальное обновление моделей

7. Аналитические возможности системы:
- Анализ социальных графов
- Выявление лидеров мнений
- Отслеживание изменений репутации
- Анализ финансовых транзакций
- Определение поведенческих типов пользователей

Семинар завершился анонсом будущих встреч, включая обсуждение дифференциальных онтологий и доклад о развитии AGI с помощью больших языковых моделей.







S01 [00:00:12]  : Коллеги, всем добрый вечер. Начинаем очередной семинар русскоязычного сообщества разработчиков общего и сильного искусственного интеллекта и завершаем цикл разговоров про онтологии. Сегодня мы закончим мой рассказ о своем собственном опыте. в этой области, которая была на предыдущих двух семинарах. А в понедельник у нас будет новый спикер, который будет рассказывать про дифференциальные онтологии, проект активный, который сейчас у них в разработке. Поэтому в понедельник вечером в то же время Можем здесь снова встретиться, а в четверг, все на той же неделе, то есть плотно у нас сейчас идут семинары, Татьяна Шаврина, которая занимается разработкой Лямы, является главным… раньше была главным разработчиком Сберия систем, искусственного интеллекта и обработки естественного языка и больших языковых моделей. Она будет рассказывать про свое видение перспективы, куда мы ушли в сторону AGI большими языковыми моделями. Итак, сейчас мы возвращаемся к теме онтологии, о чем мы наговорили в прошлый раз. О том, что на основе нашего проекта по распределенному редактору антологий. Мы пришли к заключению, что двухмерные и трехмерные редакторы знаний, антологий, семантических графов – они не очень практичны. Вот, ну и один из выводов заключается в том, что со знаниями все-таки надо работать либо в каких-то графических пользовательских интерфейсах табулярного или, в крайнем случае, древовидного вида, либо же на каком-то языке, либо естественном, некоторым DSL-е, либо некоторым мета-DSL-е, либо на универсальном языке, как мы в частности предложили, язык URL, который в своем синтаксе все включает семантику и прагматику, связанную как с мета, конструкциями, которые позволяют определять собственно конструкции предметной области, так и с мета-мета конструкциями, которые позволяют определить сами мета-конструкции, которые позволяют описывать конкретные предметные области. Еще один урок, который мы тогда извлекли, это то, что удаление знаний в распределенной системе является проблемой. Мы можем, имея распределенное представление знаний в виде графов, добавлять знания в систему, распространять их по системе, но если вдруг нам какое-то знание нужно удалить, то возникает проблема, как удалить какое-то отношение или какую-то вершину с кучкой связей вокруг них, когда оно расползлось по сети. Может быть, там пользователи уже к ней прицепили свои собственные связи и вершины, и что мы с этим будем делать. И, соответственно, родилась некоторая концепция, что знания… Да, и это первая проблема. Вторая проблема, что когда мы, собственно, решаем задачу которая была в нашем проекте изначально описана как «обмен разумами», и главная процедура в процессе обмена разумами – это сопоставление некоторой взаимно непротиворечивой картины мира между как минимум двумя, возможно, и более участниками, то возникает Проблема с выравниванием этих карт знаний или систем веры, belief systems по-английски, или структурированных представлений об окружающем мире или семантических моделей окружающего мира, сопоставление их и получение некоторой усредненной модели, приемлемой для всех участников. И для того, чтобы это сделать, возникает некоторая процедура, связанная с выявлением противоречивости в собственной модели, либо непротиворечивости в собственной модели, выявлением противоречивости, либо непротиворечивости модели оппонента или контрагента, сопоставление двух этих моделей и возможно некоторое усреднение моделей. Более того, если участников много, эта процедура должна происходить с моделями всех участников. А если эти участники имеют равный вес, точнее разный вес, кто-то является другом, кто-то является подчиненным, кто-то является ребенком, а кто-то является гуру и наставником, то очевидно модели знаний с разными авторитетами, их источников, они могут иметь разные веса. Таким образом получается, что по одному и тому же поводу, по которому мы хотим составить свою собственную картину мира для того, чтобы записать ее в системе или поиметь ее в системе для последующего практического использования, нужно на самом деле иметь у себя в голове картины мира всех оппонентов, иметь веса. некоторые этих компонентов в своей собственной картине мира, и когда мы выстраиваем некоторое свое понимание о том, что есть жизнь, что такое хорошо, что такое плохо, и что вообще нужно делать в такой ситуации, мы строим некоторое усредненное знание, а удаление является просто частным случаем. Если мы выясняем, что нечто как это является противоречиво, противоречит вот этой вот всякой конструкции, этот кусочек просто естественным образом удаляется или забывается. Но как это может быть реализовано, мы поговорим чуть-чуть дальше. Так вот, вернемся. Да, ну и, собственно, вот то, что тут на этом слайде называется Account for Evidence and Social Reference, это вот как раз речь пойдет о том, что когда мы храним знания, мы должны хранить знания не просто всех участников, банкета мы должны их атрибутировать этими участниками, чтобы понимать, кто что сказал, и кто во что верит, и кто что думает. И, соответственно, давать некоторую оценку социальной значимости этих знаний в контексте собственной жизненной перспективы. Но мы сейчас поговорим в начале языке. Для того, чтобы проверить, насколько успешно мы можем использовать язык Как интерфейс к системе управления знаниями и основанной на званиях, мы решили взять в качестве подопытного акваровика свой собственный проект, который предназначался который предполагал создание агента искусственного интеллекта, который живет в интернете и помогает пользователю решать его повседневные проблемы в интернет-сетях, помогает находить, мониторить и извлекать информацию с сайта в социальных сетях, в мессенджерах, взаимодействовать со всеми этими сайтами, соцсетями, мессенджерами. Вот проект под названием Aigents, который я сейчас более-менее активно развиваю, поддерживаю. Ну и в качестве вот такого основного интерфейса для работы с этим агентом был призван явиться так называемый E-AIgents Language или Aigents. Идея которого заключалась в том, что агент это вот Некоторый агент, который живет где-то в глубине интернета, у него нету своего интерфейса, кроме как канал, по которому мы с ним можем обмениваться сообщениями. Но вот эти сообщения, семантика этих сообщений, она может быть некоторым образом отображена на любых пользовательских интерфейсах. То есть получается, что у нас система пользовательского интерфейса с одной стороны, и сам, как бы, вычислительный агент, который осуществляет, вот, когнитивные, скажем так, функции или функции по работе со знаниями, получению знаний, извлечению знаний, обмена знаниями, они общаются между собой, как два независимых агента. То есть один агент эти знания хранит, получает, собирает и отдает другому агенту, а другой агент эти знания отображает для пользователя, используя тот или иной графический интерфейс, и в свою очередь он получает эти знания от пользователя на том же самом языке и передает в систему. Вот. И пользователь, естественно, может общаться с этим агентом просто тупо в терминале, да, либо там открыть в веб-интерфейсе, либо в мобильном приложении графическое окно, ну, изменяюсь, терминальное окно, значит, как в чате, либо он просто может телнетом или ссшем к этому агенту подключиться и общаться с ним на этом же самом языке. Вот. А если ему не хочется в чате с этим агентом общаться он, Общается через пользовательский интерфейс, но все, что происходит на пользовательском интерфейсе и в ту или другую сторону, оно все равно отображается в тот же самый язык и происходит общение с агентом на том же самом языке, а агент даже не знает о том, кто с той стороны. То ли пользовательский интерфейс пользователем, то ли сам пользователь. И в качестве агента было принято решение взять не доменспецифический язык, а взять то, что называется контролируемый язык, или семантический язык, или промежуточный язык. Какова была мотивация? На этом слайде показана мотивация. Дальше расскажу, к чему это все привело. С одной стороны, есть большой соблазн общаться с агентом на естественном языке. Но когда проект затевался, это было уже 10 лет назад, тогда не было современных систем на основе трансформеров, позволяющих общаться на естественном языке. Надо сказать, что наш агент предполагалось, что будет работать на любом устройстве, в том числе на мобильном смартфоне или на пользовательском десктопе. И там, конечно, не будет никаких кластеровых графических карт, которые требовались до недавнего времени большим языковым моделям. А для инференсов, для обучения, они требуются и сейчас. Вы можете какую-нибудь ляму или какой-нибудь Гвен-2 запустить на своем лаптопе, даже без графической карточки, но обучать вы его не сможете. Вы не сможете менять эти знания. У нас предполагалось, что агент, естественно, может формировать, динамически обновлять свою структуру, свою базу данных и общаться на естественном языке по поводу этой изменяемой своей карты или структуры обладая тех знаний, которыми он обладает. Поэтому как естественные языки, вроде английского, так и искусственные языки, вроде лачбана и эсперанто, они не рассматривались, с одной стороны, потому что слишком сложно и амбициозно. Еще, значит, проблема Как предполагалось, что эти языки амбициозны, для них очень важен контекст. Одно и то же в разных контекстах может иметь разный смысл и для того, чтобы строить какие-то системы. вообще передачи непротиворечивых знаний от агента-пользователя агенту системы, английский язык не подходит. С другой стороны, наверху использование семантических и прочих языков для хранения структурированных данных, типа старых LISP XML, SparkQL, GraphQL и тому подобного тоже предполагалось как неприменимые, потому что они слишком сложные. Как мы можем простого пользователя, который хочет общаться с простым агентом, проект предполагался для массового использования, Что мы будем заставлять учить простого пользователя JSON-LD или SPARQL, или LISP, чтобы он на экране скобки считал внимательно, с лизящимися глазами. Turtle еще можно заставить пользователя использовать, но там тоже возникают вопросы. Пример с тортлом, кстати, будет. Больше всего то, что у нас получилось, похоже на торт в каком-то смысле. Поэтому была в итоге выдвинута гипотеза, что мы можем построить некоторый псевдоестественный язык со словарем, состоящим из обычного языка человеческого, причем он может быть любым, то есть мы можем словарь языка в рамках одного и того же стандартного синтакса и пунктуации. Словарь наполнить как английскими, так и русскими, так и китайскими любыми словами. Словарь, может быть, переопределяем. А грамматика и пунктуация, как правило формирования предложения, они универсальны. И предполагалось, что это будет язык типа широко известного в узких кругах Air Control Language. То есть, есть такой специфический язык, который используют диспетчеры в аэропортах и летчики в самолетах, где используется ограниченный набор грамматических конструкций, ограниченный набор выражений. Борт такой-то запрашивает посадку. Роджер. Башня борту такому-то посадку разрешает Роджер. Таким образом, на таких отрывочных коротких предложениях общаются летчики и авиадиспетчеры. Соответственно, предполагалось, что мы сделаем такой язык и пользователи будут общаться либо с агентом с помощью этого языка, либо с помощью этого языка мы будем реализовывать пользовательские интерфейсы. Всё это было сделано. Вот пример реализации данного языка для некоторого протокола общения с устройством умного дома. Один и тот же разговор между агентом и пользователем по поводу температуры в доме. наполненный как английским словарём на верхней половинке, так и русским словарём. Напоминает это язык, на котором говорил известный российский комик Галустян. Сейчас, по-моему, он мало выступает. Моя – это прибор. Моя – иметь место. Моя – иметь температура. Как твоя самочувствие. Моя самочувствие хорошо. Вот как-то так. То есть, у нас местоимения не склоняются. Они фиксированы, как в английском. В английском это звучит не так дико. Но на русском это звучит, на самом деле, диковато. Важно, что мы любую информацию можем любому устройству или любому агенту передать. так и запросить эту информацию, так и изменить эту информацию. И все это используя один и тот же язык, не перепрыгивая из OEL в RDF или из мета-языка в язык. У нас все определяется в рамках одной и той же языковой парадигмы, в том числе работа с мета-данными. Вот так вот выглядит, разбирается на кусочки, собственно, выражение на этом языке. Язык выглядит следующим образом, что у нас идет чередование некоторых вершин и отношений графа. То есть, мы имеем дело с графом. То есть, у нас любое выражение на языке, это представляет собой некоторый подграф, который предполагает наличие некоторых вершин и некоторых связей между ними. Допустим, вот описание того, что у некоторого конкретного термостата под номером 13 датчик влажности показывает некоторое значение, описывается следующим образом, что есть конкретный термостат, у которого есть некоторое свойство влажности. И это свойство влажности является числом. Это number. Соответственно, мы можем вот эту графовую структуру, которая записана в памяти агента как подграф, Мы этот подграф можем выразить текстовым языком. Если у нас в настройках пользователя сказано, что у нас язык русский и для всех вершин Узлов и отношений этикетки есть... Для всех узлов и этикеток и отношений есть переводы на русский язык. Соответственно, получается выражение в русском неймспейсе. Моя иметь влажность, а влажность – это число. А если у нас словари определены английские, то тогда my has humidity, humidity is number. Это в английском namespace. И предполагается, что у нас может быть четыре типа выражений. Есть выражение типа interrogation. Это вопросительное выражение. Что такое вопросительное выражение? Это выражение, где есть какие-то отношения и есть какие-то вершины, но не все вершины. Например, зеленым цветом показаны элементы подграфа, которые задают вопрос. Мы говорим, что есть термостат. что абстрактная сущность, к которой есть отношение ИС, но кого это отношение ИС мы не знаем. Дальше, есть некоторое место, которое называется кухня, к которому есть отношение локэйшн, того же самого, у чего есть отношение ИС к термостату. Да, но вот это вот зелененькое, оно под вопросиком, мы не знаем. То есть, есть 2 отношения, 2 вершины. И есть 2 отношения, которые идут вот к этому неизвестному. Вот. И с другой стороны у них тоже неизвестность. То есть, вот смотрим на вопрос. Термостат. Значит, что это термостат Location. Вот она Location. Термостат, термостат, локейшн, локейшн, китчен, китчен. Риэл температча – реальная температура. Таргет температча – средевая температура. Какая сейчас температура, какая должна быть. Соответственно, мы просто выплевываем в текст вот эти сущности отношения, про которые мы что-то хотим узнать, и спереди у нас вот в конце у нас вопросик. Соответственно, мы задали вопрос. Соответственно, задача системы сейчас осуществить поиск в графе и заполнить недостающие значения. В результате исполнения запроса у нас возникает высказывание второго типа. Это декларативное выражение, декларация, что вот этот вот термостат, у которого Location Kitchen, RAigents Temperature, у него 30, вот значение 30 поставляется, Target Temperature, у него 25, вот она 25. Эта вершинка у нас тоже обозначилась, но она анонимная, потому что имени у этого термостата нет. У него есть только расположение, тип и два свойства. Обращаем внимание, что если бы мы писали это дело, к примеру, на SQL, то здесь бы бирюзовым цветом у нас SQL-запрос, а тут бы у нас просто была табличка Excel-овская, или просто некоторый список картежей переменного состава. Ну и третий тип высказывания – это директивы, директивные высказывания, когда мы не просто сообщаем какую-то информацию, а мы хотим ее изменить. То есть мы говорим, что вот у того термостата, у которого location kitchen, у него target temperature должна стать под 20. Вот выскочила, извиняюсь, из-за оранжевого. Прямоугольничка 20, вот оно 20. Соответственно, мы даём команду, что эту связь нужно создать вместо вот этой. То есть, мы меняем значение узел на этой вершине с 25 на 20. Соответственно, грамматика и пунктуация этого языка определяется исчерпывающим образом вот этой формы, форменной ИБНФ. Из каких-то, так сказать, зарезервированных слов есть только Вот и иф, которые на самом деле не являются обязательными. То есть на самом деле мы можем в принципе все разрулить либо вопросительными знаками, либо точками, либо восклицательными знаками. То есть мы можем не писать ни ифов, ни вотов, ни ду. То есть в директиве у нас ду еще спереди можно записать. Но мы можем ограничиться либо вопросительными знаками, либо точками пунктуации. Соответственно, вопросительный знак в конце – это директива, точка – это декларативное выражение, вопросительный знак – это вопросительное выражение. Вот примеры того, как на нашем языке строятся различные коммуникации. Вот, например, на английском. Как ты себя чувствуешь? Чувствуешь ли ты себя хорошо? Декларация, что ты чувствуешь себя хорошо. И пожелание – чувствую себя хорошо. Вот тоже самое по-русски. На русском модуляция осуществляется повышением или понижением тона. Помимо вопросительного исключительного знака. Вот так это на нашем языке описывается. Одна и та же. Разная пунктуация. Либо точки, либо вопросительный знак, либо восклицательный знак. Ну и там, где идет вопросительная фраза, там не хватает одной вершины. Соответственно, ее в результате выполнения надо заполнить. При этом предусмотрено два варианта. формирование выражений на этом языке более компактный с использованием скобок, где круглые скобки обозначают конъюнцию, а фигурные скобки обозначают дизюнцию. Либо без скобочек есть форма записи, когда мы используем end и or. для того, чтобы соединить то, что у нас идет в списке конъюнктивном. И используется end. Соответственно, eat, sleep в круглых скобочках можно переписать как eat and sleep. Eat, sleep в фигурных скобочках можно переписать как eat or sleep. Дополнительно в языке есть еще возможность использования квадратных скобок для описания значимой последовательности каких-либо действий то есть мы предполагаем что идет описать некоторые деятельности да то есть ключевое слово next которая говорит о том, что что-то следует за чем-то. Но мы можем избежать сопряжения фраз через next объединением их в квадратные скобки. То есть квадратные скобки это то, что называется последовательная или упорядоченная конъюнция. Ну и в качестве примера того, что мы можем делать с помощью скобок, показано как различные термы могут быть описаны на нашем языке со скобочками. Чему они соответствуют на термлоджик. И вот здесь, чему они соответствуют на тортле. Видно, что из пяти конструкций, две конструкции мы на тортле просто не можем описать. Но у нас они получаются наиболее компактными. Что в итоге было сделано? В итоге мы антологию, всю мета-антологию, которая, как из прошлого доклада, кто был, должен помнить, она очень простая. Мета-антология у нас ограничивается тем, что есть некоторые вещи. и у них есть некоторые свойства. С помощью этих двух сущностей описывается все остальное. Была описана соответствующая предметная область, где есть пользователи, у которых есть поклонники, где есть сайты, которые связаны между собой. Есть некоторые шаблоны, которые описывают темы интересов на этих сайтах. Вот есть топики, которые мы на этих сайтах идентифицируем, пытаемся идентифицировать. Есть связи этих топиков с теми юзерами, которых эти топики интересуют. И есть связи этих топиков с временами, с некоторой иерархией времен, когда это произошло, когда это происходило, когда это будет происходить. И, соответственно, эти же топики, вещи и сайты связаны с некоторыми текстовыми, по сути, шаблонами или грамматическими структурами или регулярными выражениями, которые описываются для идентификации соответствующих тем на соответствующих сайтах. Соответственно, была построена система взаимодействия между пользователями. То есть, на этом языке можно было описывать социальные сети, можно было описывать с коммуникацией пользователей друг с другом, кто кому что сказал, кто кому что написал, кто кому перевел какие деньги. Если это происходит на блокчейне, а мы поддерживаем три блокчейна – это «Эфир», «Стим» и «Голос». Или что пользователь написал или что пользователь прокомментировал в социальной сети или в мессенджере, а мы поддерживаем мессенджеры Slack, Telegram, Facebook, Messenger. И всё. Также поддерживаем социальные сети ВКонтакте. Поддерживали Google и Facebook, пока они имели API. Google загнулся, Facebook и поддержку извлечения информации по текстовым коммуникациям из себя убрал. Анализируя всю эту информацию, мы могли строить модели пользовательского поведения, модели самого пользователя, модели его друзей. Но это тема другого немного проекта. Точнее, тема немножечко другого рассказа. С помощью этого языка, естественно, можно было строить пользовательский интерфейс новостного агрегатора. То есть то, что мы видим, это на самом деле некоторая отрисовка того, что получает агент пользовательского интерфейса во взаимодействии с агентом бэкэнда. И тем самым на этом языке реализуется интерфейс новостного агрегатора, хотя, в принципе, всю ту же информацию пользовать ему получится не скроллируя агрегаторы, не переключаясь между табами, а в процессе взаимодействия с бэкэнд-агентом на этом языке. Тут всякая графовая аналитика социальных сетей. Но сухой остаток такой, что на данном этапе развития проекта на основе этого языка мы пришли к выводу, что, к сожалению, люди не любят и не хотят учить новые языки, не только если это языки программирования, но даже если это какие-то упрощенные, контролируемые языки. То есть, если пользователь привык склонять и спрягать глаголы, даже если ему предлагают разговаривать с системой на упрощенном языке, где эти глаголы спрягать не надо, Он их пытается все равно спрягать, а в итоге система его не понимает и ломается. Пользователь не готов упрощать свою речь до уровня какого-то тупого агента. Люди хотят использовать либо приятный и юзабельный пользовательский интерфейс, либо они хотят говорить системой на своем народном языке, чтобы она их понимала. Отдельная история. Значит, подобный продукт достаточно трудно продать. То есть, нам не удалось этого самого агента как новостного агрегатора монетизировать. Но это тоже немножечко другая история. Ну вот, про язык я, наверное, рассказал. Если есть какие-то вопросы или обсуждения, типа для обсуждения можно поговорить. Если нет, я двинусь дальше к резонерам и представлениям данных. так у нас там какие-то вопросы в чате так ambiguous двусмысленный да спасибо так так так что-то там так я вот а вот 

S03 [00:30:41]  : Ну, давайте, Антон Германович, если никто не хочет, у меня тут целая книжка. Я написал пару вопросов, если можно, по коду слайдов. Давайте только откройте слайды обратно. Я уж не буду с самого начала, как говорится, только с последнего. 

S01 [00:31:04]  : Сейчас, секундочку. Тогда вышел. 

S03 [00:31:10]  : Там, где вы рассказываете про контролируемый язык. Давайте со слайда про контролируемый язык. Камера сегодня дурацкая. Нет, пораньше. Еще выше. Ну, да. Ещё-ещё-ещё. Несколько. Когда вы рассказывали про язык... Да, вот отсюда можно начать. Оказывается, канланги живы, и канлангеры, они обитают во всех индустриях. Это очень радостно слышать. Ну, люди, которые создают искусственные языки, если вы не знаете, есть такой устойчивый термин — «конланг» — это «constructed language», и у этого есть огромное международное сообщество, да, и очень много людей этим увлекается. То, что вы упомянули здесь, там, ложбаны, спиранты, интерлингвы — это, как говорится, как раз туда, в эту тусовку, вот. Там есть разные роды люди, вот, но приятно, что и вот Здесь любители такого обитают. Вот. Вы упомянули о том, что давайте сделаем какие-то достаточно контролируемые языки для того, чтобы там на нем можно было универсально описать метаданные, уровни грамматики, которые нужны. Ну, давайте дальше. Прокрутим сейчас следующие. Я сейчас тут зацеплюсь. Когда вы сказали о том, что у нас не было тогда еще LLM, поэтому мы выстраивали связь, делали для того, чтобы разные агентские системы, допустим, Facebook, предоставить единый интерфейс. Вот первый вопрос у меня сразу возник, а вот, допустим, если есть разные метаданные, структуры у языка, У одного там такая конструкция, у другого другая. Допустим, Facebook может там отобразить такого рода сообщение, в котором есть какие-то поля, метаданные конструкции, а другой не может их отобразить. Как вы в этот момент, когда вы думали о таком взаимодействии разных систем, и чтобы им сделать какой-то язык общий, как вы тогда думали это преодолеть, о том, что есть разные так скажем, языки, на которых они говорят. Ну я не знаю, даже разные средства представления, что ли, в разных системах, на которые вы не влияете. 

S01 [00:33:48]  : Я понял, да. Смотрите, давайте тут сразу два момента. Во-первых, насчет ЛЛМ. Я все-таки вернусь. Глядите, я сейчас непосредственно на одном из проектов, в котором участвую, я как раз очень активно использую ЛЛМ. Не я, а команда, в которой я. работаю, которой я руковожу. Мы занимаемся пресловутыми рагами. Какими только рагами не занимаемся. Есть разные виды рагов. Мы почти все из них делаем. Я понимаю, что строить системы То есть, сейчас бы я бы тоже не смог построить то, что мне было нужно 10 лет назад, и что здесь показано на этих слайдах. Я бы с помощью LLM этого сейчас не сделал, даже если были бы нужны вычислительные ресурсы. Потому что все равно есть неоднозначность. И даже для того, чтобы прикрутить какой-нибудь граф-рак к системе, все равно нужно делать кучу настроек. Нужно инженерировать промпты. И всё равно ты никогда не уверен, что система правильно поймёт, что ты ей сказал, и вернёт тебе именно то, что ты хочешь. Поэтому в моём понимании вопрос всё равно остаётся актуальным. Теперь по поводу унификации онтологии. Смотрите. Когда я говорю «разные системы, с которыми мы работаем»… Это, по-моему, на другом слайде было. Вот в своем проекте мы работаем и с мессенджерами, и с соцсетями, и с блокчейнами, и со всем, со всем, со всем. Значит, вот эти системы, они просто являются частью предметной области. То есть, вот у нас предметная область включает соцсети, блокчейны и мессенджеры. А, и интернет-сайты, и РССВИДы. Вот это вот все некоторая предметная область. И мы эту предметную область описываем в какой-то модели. То есть мы ее накрываем какой-то моделью и эту модель мы описываем в терминах своего языка. Допустим, там есть message, там есть сайт, там есть транзакция, там есть цена, там есть время, есть subject, есть body. И вот эту предметную область мы натягиваем, строим таким образом, чтобы она накрывала все информационные источники. То есть, грубо говоря, если у нас структура JSON, которая выдается, допустим, по API Facebook, по Аппи Телеграма и по Аппи этого самого какого-нибудь Реддита, да, Реддит еще мы поддерживаем, то мы, естественно, эти разные JSON на уровне, так сказать, своего собственного интеграционного протокола мы отображаем на вот эту вот самую предметную область. То есть, грубо говоря, сейчас нельзя просто вот так вот без кодирования на Java, на который это все написано, взять и подключить новую сеть. Гипотетически можно было бы с помощью этого языка программировать адаптеры. Можно было бы сделать некоторый дополнительный слой, который бы понимал мета-язык написания адаптеров для парсинга JSON. И соответственное подключение любой сети можно было бы описать на нашем языке в качестве скрипта для разбора джессонов какой-то сети. Но этого сделано не было. Отображение на предметную область посты и транзакций. На самом деле предметная область выглядит примерно так. Точнее, есть транзакция. То есть, есть транзакция, и у этой транзакции есть разные поля. В среднем у транзакции могут быть такие свойства. У нее обязательно есть время. То есть, у любой транзакции есть время. Потому что время есть как у финансовой транзакции, так и у поста, так и у комментария, так и лайка. У каких-то подвидов вот этой транзакции есть еще и текст, допустим, если это комментарий или пост. У каких-то есть еще атрибут субджект, если это пост, а у каких-то есть атрибут, допустим, сумма, если это транзакция, но нету там субджекта и текста. Вот как-то так. 

S03 [00:38:43]  : Да, спасибо. Мы еще в прошлый раз с вами обсуждали про то, что действительно, когда нужно из одной модели в другую, то есть можно ли это делать автоматически или трансформировать это нужно вручную, как говорится, при преобразовании из одной, допустим, системы в другую. То есть это понятно. Вопрос у меня как раз был про сообщения. Вот у вас универсальная Какая-то информация, допустим, есть возможности там отображения, а у каких-то возможностей нету. Ну, как говорится, будем, допустим, отправлять информацию. И, допустим, какие-то информации, допустим, есть возможности отображения, а у каких-то возможностей нету. И, допустим, какие-то информации, допустим, есть возможности отображения, а у каких-то возможностей нету. И, допустим, какие-то информации, допустим, есть возможности отображения, а у каких-то возможностей нету. Базовая модель у вас была Entity и Relation. Или у вас сообщение у него есть время и какие-то дополнительные варианты? 

S01 [00:39:41]  : Базовая модель, не Entity и Relation, а String и Property. Это эквивалент. Соответственно, кроме вещей и свойств нет ничего. Просто у вещи есть разные классы. Есть класс «Вещи-сайт», есть класс «Вещи-сообщение», и у этих разных вещей-классов есть «Вещи-экземпляры». У вещей экземпляра транзакции есть стоимость, а у вещей экземпляра сайт есть URL, а у вещей экземпляра пост есть текст и subject. 

S03 [00:40:25]  : Да, да, спасибо большое, потому что как раз в прошлый созвон у нас был Карпов, и как раз он спрашивал, потому что у него в проекте как раз вопрос стоит о том, как, допустим, сделать какую-то модель преобразования сообщений из разных систем. Жалко, его сегодня с нами нет на созвоне. 

S01 [00:40:48]  : Давайте я сейчас просто вам покажу, потому что на самом деле вопрос хороший. Сейчас я просто найду. Я просто недавно как раз… Сейчас я просто найду. Недавно как раз рылся. Вот. Вот, вот, вот. вот там просто картинка есть на эту тему так вот картинка так и мне нужна подавка так сейчас как же мне подавку найти так сейчас я сверну это так вот вот подавка вот Например, у нас в частности была сделана такая история. Для промежуточного формата представления данных и синхронизации во всяких внутренних задачках и для всякого тестирования, то есть больше для внутреннего использования, был разработан некоторый унифицированный формат. Куда в виде некоторой плоской структуры, которая могла сохраняться в виде некоторой ЦСВшки, и обмениваться штуковиной можно было между различными частями системы. И все вещи, которые ходят именно в этой предметной области, они эту структуру загоняли. Соответственно, что там есть? И как раз разными зелеными стрелочками описывается вся атрибутика. То есть, у нас есть ссылка на родительский пост или комментарий. Это один атрибут. Есть ссылка на некоторые так, к которому это относится. Есть ссылка на то, голосом чего. То есть, если транзакция является голосом, она ссылается на некоторый пост. Если транзакция является упоминанием, Она связывает некоторые комментарии и некоторый аккаунт. Если это транзакция между какими-то аккаунтами, то она связывает, соответственно, два аккаунта. Если это, например, перевод денег. то вот есть перевод денег, а нет, фоллоус – это последование. То есть, если кто-то становится последователем кого-то и наоборот отписывается от кого-то, то это связь между аккаунтами. денежные переводы между аккаунтами, между аккаунтами и смарт-контрактами, операции создания смарт-контрактами, конкретными аккаунтами. То есть, вот как множество исходящих и входящих стрелочек на этой картинке как раз показывают все множество тех атрибутов, которые использовались в системе, в том ее функционале, который был связан с работой с исходными источниками информации. Вот эта вот структура, это была только структура, которая описывала саму исходную информацию. А из этой информации могла возникать новая информация. То есть, как бы основным функционалом агента было то, что анализируя вот эти вот посты и комментарии в тех источниках, которые система имеет доступ. предоставленной, соответственно, пользователям, она могла, ну не могла и может, то есть это существующий функционал, она может обнаруживать интересующие ее объекты, извлекать оттуда эти объекты, атрибутировать их, вот, как датой, так и теми атрибутами, которые этому объекту определены пользователями, и таким образом создавать новое знание. Пользователь сам мог создавать эти объекты. 

S03 [00:44:53]  : Да, спасибо, я понял. По сути, вы делали здесь какой-то DSL для этого уровня, в котором есть вот такой набор отношений, как другие ситуации, сводить к этому набору понятий, чтобы все могли... То есть это и есть какой-то уровневый DSL. То есть тот, на котором уровни разные системы могут взаимодействовать. Супер. Это очень хорошая тема. Здесь вы очень много рассказали в исходной презентации про ваш подход к языку. Там есть слайд «Моя иметь прибор»? когда вы там говорите. «Моя медь прибор» — это вот у нас там был в чате последователь Лашбана, очень активный, да, то есть «Моя медь прибор» — это, по сути, это глосса, да, такой был проект. искусственных языков. Это лидепла санкт-петербургская, кстати, очень популярная была в свое время. Вот это как раз моя иметь прибор. То есть это максимально близко к китайскому языку, к изолирующей грамматике. И вопрос здесь на самом деле о том, что Вот мы делаем технический язык. Почему мы так выбираем изолирующую грамматику? Потому что нам легко ее как бы перевести в техническую плоскость. И вопрос, как вы считаете, вот о том, что вот такой подход, о том, что мы вместо того, чтобы понимать То есть сами мы, допустим, в гуманитарных науках, когда мы анализируем, как человек проходит вот эту градацию между слабо формализованным знанием и сильно формализованным знанием. Мы фактически говорим, давайте научим людей, то есть будем создавать системы и стратегии. То есть если мы говорим про AGI или про LLM, про контролируемый язык, мы как будто бы изначально говорим, давайте мы людей просто подгоним под тот сразу уровень формализации, на который мы можем перевести в код. Хорошая ли это по-вашему стратегия? Я вот еще сейчас добавлю, в этот же вопрос, хорошая ли это стратегия, потому что, следуя такой же стратегии, мы могли бы, грубо говоря, 20 лет назад умели писать только определенные коды на существующих тогда языках программирования и сказать, все, думайте вот так, и все, и на этом остановитесь. То есть, может быть, стратегия оптимальнее была бы наоборот, То есть сейчас как будто все идет вот в этой сфере с LLM, с развитием вот этого коммуникации, в том, что давайте мы сделаем более формализованный язык, то есть более понятный машинам, чем более, так скажем, понятный людям, что ли, или из этой гуманитарной какой-то сферы. 

S01 [00:47:41]  : Вот мое понимание как раз для меня один из, скажем так, наиболее важных, может быть он ошибочный по-прежнему, но пока что я пришел к тому выводу, что как минимум массового пользователя заставить пользоваться более структурированными языками идея бесперспективная. Тем более заставить его делать это бесплатно. И тем более заставить еще платить за это деньги. То есть, как бы из вот того, как это называется, из тех пользователей, которые попытались стать моими пользователями, которых мне не удалось удержать, большим фактором отторжения было то, что они не могут общаться на естественном языке с одной стороны. С другой стороны, система вроде как им предлагает на этом языке общаться, но когда они пытаются ей отвечать на вот этом языке, она их не понимает. И, соответственно, мои попытки объяснить, что это же упрощённый язык, вы с ней говорите на упрощённом языке, есть примеры, как на нём разговаривать. Это, в общем, никакого энтузиазма в пользователях не вызывало. 

S03 [00:49:02]  : Да, вот я как раз про это тогда прокомментирую. Я вот скинул картинку там, я буквально еще 5 минут, больше не займу времени. Скинул картинку, которая про формулы, где там вот формулы написаны. Когда вы говорите язык, допустим, им не нравится графический или контролируемый, это как толстовка. Толстовка кому-то нравится, кому-то не нравится. Почему она не нравится? Она не нравится, потому что она или не сидит, или не подходит тебе по стилю, или под формат мероприятия. То есть, соответственно, когда вы говорите, что язык не подходит, он не понравился. Он не понравился по нескольким причинам. Или он не подходит, то есть вы пытаетесь людей, которые думают, допустим, на одном уровне формализации, заставить их сразу думать на таких формальных категориях, которыми они сейчас не понимают свой объект. Ну, допустим, когда приходишь к предпринимателю и говоришь, ну-ка, давай-ка мне карту процесса своих нарисуй, он еще даже не понимает, что у него, какие процессы, карта, какие там агенты, гейты и прочее. когда мы даем, допустим, на практике, создаем какие-то очень инструменты, ну, вот я возьму пример, допустим, управление у меня было школьными процессами муниципальных школ, то есть мы сначала изучали, допустим, как у них там что-то происходит, а потом, исходя из того языка, которым они уже работают, мы делали им дополнительный уровень языка, вот как то, что вы показывали, примерно вы делали для сообщений, то есть мы только делали для каких-то процессов, сделали вспомогательный уровень. И, естественно, мы его отягощали всякими интерфейсными решениями, то есть полями и прочим. Это сейчас непроцесс. Когда новый уровень им дает как синтаксический сахар бенефиты, люди очень с удовольствием им пользуются, то есть он должен быть для них прагматический. Здесь есть определенные законы, что должно соблюдать, чтобы толстовка вам понравилась или чтобы язык вам понравился. Он должен быть вам доступен по уровню формализации, он должен быть полезен прагматически и прочее. То есть тут нельзя сделать просто формальный язык и сказать, блин, вот у нас есть ассемблер, на нем можно написать все, чему им никто не пользуется, что-то мы делаем не так. Дело не в этом, там есть целый спектр законов, по которым язык или пользуется, или не пользуется. Он им полезен прагматически или не полезен. Даже вот этот пример я вот сейчас показал, да, это формулы, но что-то типа как Excel'евские формулы, только платформа кода, а ее в свое время сделала Некоторые, такой синтаксический сахар, когда там объекты, они там, вот она тебе делает красивую подсветку, она там делает отладку. Очень удобно, то есть большие там длинные в страницу А4 формулы, такие как для Excel, очень удобно ими пользоваться. То есть они придумали какой-то свой язык, и когда люди у нас вот коду изучают, они сначала в шоке, но потом, когда они понимают, какие сложные там вещи можно писать, вот у меня опыт, Такое, что про интерфейсы. И дальше вернёмся к теме… Всё, я заканчиваю. Вернёмся к теме LLM. Вы сказали о том, что вы создавали… Давайте я отвечу. 

S01 [00:52:02]  : Можно? Да, конечно. Вот на эту тему и этого слайда я просто… Так, я уже забыл. В общем, я расскажу конкретную историю. В 93-м году, в районе 93-го, плюс-минус несколько лет, был, когда пошел бум клиент-серверных решений, появился и попытался стать очень популярным появилась и попыталась стать очень популярной технология и программа, которая называлась Gupta SQL Windows. Гупто – это фамилия человека с одноименной компанией. SQL Windows – это программный продукт. SQL Windows – компания человека по имени Гупто. Суть заключалась в том, что для того, чтобы разрабатывать клиент-серверное приложение, вы не пишете код. на плюсах перемешку с SQL или на Java перемешку с SQL, а вы на деревьях развешиваете листики. Вот здесь у тебя листик if, вот здесь у тебя листик do, вот здесь у тебя листик else, вот здесь у тебя листик switch, вот здесь у тебя листик формочку нарисовать, вот здесь у тебя листик event, на эту формочку прицепить, а тут у тебя, значит, веточка, значит, с SQL-запросом, а вот на этой веточке листики это колоночки, которые надо запросить, а вот тут у тебя ифчик, и вот ты вот это вот все эти деревья разукрашиваешь. Вот. Значит, у нас целая компания на этом продукте работала, и в середине девяностых про него уже никто не вспоминал, и люди вернулись в унылые текстовые редакторы и стали дальше писать всё сначала на Плюсах со вставками Искуэля, а потом на Питоне со вставками Искуэля. То есть, простой, брутальный текст в конечном итоге побеждает. И это же касается истории, с которой я, по-моему, прошлый доклад начинал, или уже позапрошлый, я не помню, про кейс-технологию. Что вот была прекрасная идея, а вот давайте мы будем все программы рисовать. значит да да да вот значит как и то что вы показываете а потом будем их компилировать вот а потом когда их уже скомпилировали они превратились текст их уже подхачили и обратно их уже в красивые формочки не засосать вот эти технологии они к сожалению не приживаются единственная вот success story вот этого визуального программирования вот имеет место быть на сегодняшний день Значит, ну вот, да, значит, если мы пытаемся, да, это вот история с low-code, no-code. Она, у неё сейчас, кстати, да, значит, сказать, новый взлёт, новая популярность. Посмотрим, куда это выйдет, да, может быть, массы приучились и, может быть, там с очередного раза история полетит. Но есть одна интересная предметная область, где вот это вот low-code, no-code. программирования используются достаточно широко. Это область автоматизации технологических процессов, где в основном вся логика описания вот этих технологических процессов и языки описание этих технологических процессов, визуальные языки. Они у нас изнаследованы из отрасли микроэлектроники, где разрабатывались дизайны соответствующих радиотехнических изделий. И там царят языки, стандарты от IEC 61131 и IEC 61499. И вот там визуальное программирование Причем на разных языках визуальных оно процветает в полный рост и есть несколько широко известных в узких кругах продуктов, которые вот это визуальное программирование в разных стилях в виде деревьев, либо в виде прямоугольников со стрелочками используют. Но вот все-таки брутальный простой текст на конкретном языке программирования для программистов или брутальный простой текст для массового пользователя, он на рынке пока что в среднем большинстве приложений побеждает. Я это так вижу. Рано или поздно. 

S03 [00:56:40]  : Ну да, тут я с вами соглашусь, потому что действительно мы видим, что есть уровень, на котором это адекватно, есть уровень, на котором неадекватно. Первый скриншот, который я скинул, называется язык Scratch. на котором детей учат. Обычно у нас создатель портала Интеграм, он все время говорит, вот это ваше визуальное программирование, это самый кринжовый пример. И второй, допустим, скриншот, это уже как раз пример другой платформы. По-моему, она занимается оценкой оценка кредитной истории, кредитного рейтинга. То есть там они предлагают бизнес-пользователям, допустим, писать формулировки в виде каких-то блоков условно, а внутри, если нажать, там просто тупо код. То есть они используют как вспомогательный слой. Да, то есть всему вот этим всем инструментам, они все по законам, как говорится, опять же, возвращаемся к языкам, то есть они адекватно своей размерности. Не везде все. И вот третий скрешет как раз упомянули, автоматизация, да. Это как раз платформы типа Make.com, которые нашли уровень представления языку, свое четкое понимание, как его использовать. Мы просто поэкспериментировали в свое время, чтобы глубже понять внутреннюю химию процесса. Вот последний вопрос, самый важный. Выражение. Ваш слайд про типы выражений. Вопрос, дефиниция и прочее. Вот сейчас мы... О, да, кстати, это вот тоже. Это как раз очень похоже на диаграмму, принятую в ASUTP. 

S01 [00:58:19]  : Да. 

S03 [00:58:30]  : У вас слайды про типы выражений. 

S01 [00:58:34]  : Так, сейчас попытаюсь вернуться. 

S02 [00:58:39]  : Так, это я закрываю. 

S03 [00:58:43]  : Так, дальше. Да, вот здесь про типы выражений. Вот, соответственно, сверху вы раскладываете на какую-то, то есть, такую конструкцию, то есть, ну, неважно, этот язык у нас буквально там люди на нем пишут или в него там конвертируются, или интерфейс он решается, это сейчас отдельный вопрос. Но просто мы хотим изложить какое-то сообщение, ну, допустим, KLLM тоже, да, сейчас самый насущный вопрос. Как правильно задавать там вопросы KLLM, чтобы она поняла, что мы от нее хотим? И казалось бы, здесь мы могли бы применить вот этот язык, когда мы можем с ней, как говорится, забиться, что мы под чем понимаем, какая конструкция моего выражения. И вот здесь вот эта история, когда вы показали первый пример с вопросом, о том, что я показываю место, про что у меня будет вопрос. То есть показываю некоторую конструкцию, что у меня есть такой бизнес, у него там есть то-то, то-то, то-то, и пустой у меня остается, грубо говоря, квадрат. Я говорю, вот это предмет моего вопроса. Я правильно понял вот эту идею, что вы предлагаете? То есть вы дефинируете некоторую конструкцию в своем выражении, А потом указываете, грубо говоря, место, к которому у вас вопрос. То есть что вы, недостающий элемент граф, хотите найти. Вот такая здесь конструкция подразумевала? 

S01 [01:00:01]  : Я, может быть, не совсем понял вопрос и не совсем понял связь все-таки с ЛЛМ. Давайте я попытаюсь сформулировать, что я здесь хотел сказать еще раз, а вы потом уточните тот вопрос или те вопросы, которые у вас есть. То есть, идея языка заключается в следующем, что у нас любое выражение – это всегда подграф который либо является полным, то есть, полным подграфом является такой, который, во-первых, является замкнутым, то есть, у которого нет разрывов. А, во-вторых, у всех связи определены и источник, и цель. С обоих концов известны значения. Вот. Соответственно, если у нас имеет место вопрос... оранжевый, то у нас есть недостаток разрыва. То есть, этот граф является неполным. Вот эта зелененькая часть болтается с одной стороны, а вот эти две связи, они тут вообще сами по себе ни к чему не привязаны. И нам нужно этот граф как-то связать, найдя вот эти три вершины, которые позволят этот граф сделать замкнутым. 

S03 [01:01:24]  : Я понял. Тут на самом деле просто аналогии с графами не очень мне знакомы, поэтому я немножко тут, может быть, спутался. Сама просто вы до этого про искусственные языки говорили, просто есть вот в этом ложбане, у него как раз была похожая конструкция, там нет графа как такового, там есть выражение. Вот если представить, что там есть законченное выражение, допустим, если аналогия адекватная, и там мы указываем какую-то точку, которой поменяем знак вопроса. Условно говоря, вот этот блок, у вас здесь это кружок посередине, недостающий элемент. который, собственно говоря, нам нужно найти. Он и есть предмет нашего вопроса. Про LLM я спрашиваю, потому что сейчас мы, собственно говоря, с такими же вещами и обращаемся. То есть мне нужно как-то сформулировать такой сложный вопрос, допустим, к нейронной сети, который бы показал бы, что это термостат из кухни, который находится там-то, и который там термостат, и вот я хочу узнать температуру. То есть я конструирую некоторое выражение. Мы сейчас обсуждаем как раз языки. Какие языки, какие конструкции. Может быть это контролируемый язык, может быть это вот такие выражения, псевдокод. Фактически в конце вы уже показали некоторый псевдокод, в котором есть некоторые операции. И вот по факту сейчас все, мне кажется, крутится вокруг того, Как человеку лучше всего сконструировать вот это сложное выражение, допустим, когда он хочет задать вопрос о своем бизнесе, и там много всяких переменных. Там много переменных, там много всяких аспектов, да, и вот как мы вот это балансируем, что мы задаем там, допустим, надо в контекст кинуть, что там нужно внутрь сообщения. И вот эта конструкция, кажется, что когда мы берем за основу ну, нечто опирающееся, вот там вы EBNF упомянули, да, нечто, что-то, что имеет там в себе достаточно плоскую такую конструкцию. Что дальше? Вот есть ли у вас мысли, как мы вот двигаемся? То есть, ну вот мы это конструируем, вот как вы показали, с колобками, ифом там и прочее. Или какие у вас, есть ли у вас мысли, допустим, как мы сейчас двигаемся? в эту сторону конструирования вот сложных представлений. По сути, мы же хотим описать то, как я понимаю бизнес, какие у меня там сотрудники, и задать вопрос, сколько мне им платить. Потом я хочу там упомянуть, сколько у меня, допустим, всего денег, из чего у меня складывается оборот, какая у меня нагрузка. Я вот хочу это запихнуть в какое-то сообщение или сначала в контекстное сообщение, а потом в мой вопрос. Как мы это все делаем? Ну, если мы это... Мы что это все? Хардкодом будем писать? Мы сейчас придумываем какой-то суперформализм для того, чтобы... Какой вы видите сейчас путь? Или кто вообще сейчас... Какие там трендовые идеи в этом направлении? Вот в составлении именно вот таких сложно... сложно сочиненных многомерных выражений, да? 

S01 [01:04:19]  : То есть вот как... Смотрите, да, я понял, вам кажется, вопрос. Вот в моем понимании это... выходит за рамки того, о чем я сегодня хотел говорить. Я хотел просто поделиться некоторым опытом, а вы в свой вопрос задаете будущее, что совершенно правильно. Как я вижу, эта проблема решается сейчас. Она решается примерно так, как В прошлый раз, по-моему, про это говорил Александр Балдачев, или это позапрошлый раз, по-моему, было, когда мы про эллилембки говорили. И сейчас она решается с помощью пресловутого граф-рага. Или есть модная аббревиатура, недавно появилась, KG, Knowledge Augmented Generation. Когда у нас есть граф, в котором хранятся семантические данные, представляющие суть вашего бизнеса, которые при этом могут пополняться. И у вас есть LLM, которая должна каким-то образом эти графы С одной стороны, когда вы спросите ее о чем-то, грубо говоря, как вариант, чтобы было понятно, некоторую гипотетическую конструкцию сделаю. Что у вас есть LLM-ка мультиагентная, в которой есть агент, который текстовый запрос транслирует в GraphQL или в AL. или в URL, в зависимости от того, какой язык работы с графами поддерживает ваш графовый движок. После чего делается запрос к графовой базе данных, и получается подграф из этой графовой базы данных в качестве ответа. То есть, грубо говоря, вы сформировали вот этот вопрос, а какая температура моего термостата на кухне, на русском языке, в свободной форме. Система его перевела на такой запрос, запунила в систему, система вернула вот эту моя термостата, температура 30, и вот этот корявый ответ другой агент вашим мультиагентом-фреймворке перевел уже на английский язык, на русский язык, на котором вы разговариваете, и вы получаете уже ответ. Если вы опять-таки хотите изменить какое-то значение, то опять-таки вы говорите, значит, твоя термостат, локейшн, кухня, целевая температура 20, вот, это, точнее, нет, вы говорите, поставь 20. Система, зная, что контекстом является конкретный термостат на конкретной кухне, дополняет ваш запрос информации о том, про какой термостат и расположение какого и где его расположение. Формирует запрос на том языке целевом, который поддерживает ваш движок, отправляет его в систему. Если система возвращает окей, она вам транслирует этот окей, допустим, в эмоджи с большим пальцем кверху. Причем я это вижу только так. И на самом деле вот те разработки, которые работают на основе графовых, на основе технологии подхода типа GraphRack или как, они вот что-то такое пытаются делать. И вот в том проекте, в котором я говорю, мы вот такие вещи сейчас как раз пытаемся делать. 

S03 [01:08:18]  : Я понятно объяснил? Да, я понял, что вы хотите сказать. Контекст подкладывается как граф. Граф какой-то базы данных подкладывается как контекст. 

S01 [01:08:32]  : Нет, смотрите, все-таки нет, это не контекст. Про контекст вы правильно сказали. Есть два способа сделать то, что я сейчас сказал. Как минимум два, может быть больше. Точнее три. Первый способ. Вы используете Tool Framework. Вы используете лангчейн, где вы можете создавать некоторых тулов или функций. с которыми лангчейн сможет взаимодействовать. То есть лангчейн извлекает из вашего текста на естественном языке аргументы функций и параметры, которые нужно в эти функции передать. Дальше вы исполняете эти функции, то есть вы предусматриваете все функции на все виды запросов, эти функции исполняются, функции возвращают вам результаты, и дальше ваш агент результаты этих функций транслирует в текстно-естественном языке. Это один подход. Второй подход. Вы можете. Это тот подход, который мы сейчас в паре проектов используем. Другой подход, который я, насколько я понимаю, Александр Балдачев рассказывал в предыдущем докладе. И вот он будет в конце февраля снова рассказывать о своих достижениях на этом поприще. В предыдущей версии он был основан как раз на контексте. То есть, что он делал? Он все правила работы со своим языком, он забивал в промт. То есть, он системе объяснял в процессе сессии предыдущей то, как работать с его языком, как транслировать текст в семантические примитивы. И эта информация лежала в контексте. И в этом смысле да. Вот это как раз тот случай, про который вы говорите, что граф подкладывается в контекст. Соответственно, если граф меняется, то нужно обновлять контекст. Но у нас граф может быть большой, у нас он в контекст может не влезть. Если у вас база данных, например, база данных предприятия, где тысячи сотрудников и сотни тысяч позиций в номенклатуре, она у вас может просто не затолкаться в контекст. И каждый раз, когда у вас будет обновляться номенклатура, как вы будете этот контекст обновлять? Поэтому пока мы не получили возможность каким-то образом строить эллилемные, условно говоря, архитектуры, которые мы могли бы в качестве контекста иметь некоторую динамическую проекцию, некоторые базы данных, Ну, я сейчас просто спекулирую, значит, о некоторой гипотетической архитектуре. То есть, чтобы был некоторый механизм динамически поддерживать вот этот вот LLM-ный контекст из какой-то там либо реляционной, либо графовой, либо векторной базы данных, чтобы он все время был актуальный. Может быть, что-то такое возможно. И последний, третий подход, который гипотетически мог бы быть, но я думаю, он просто нереален в существующих условиях. Это просто, если бы у нас были Лелемки с инкрементальным обновлением, чтобы их можно было периодически подтренировать на новой информации. Допустим, мы получили базовую лилемку, мы подтренировали ее на использование нашего языка. Вот как мы тренируем лилемку на перевод с английского на русский, или с английского на китайский, или с картинок на текст, или из текста в картинке. Мультимодальную лилемку мы натренировали. Точно так же мы можем эту лелемку дотренировать на работу с каким-то DSL или с какой-то семантической базы данных или с какой-то реализационной базы данных, дотренировать ее на соответствующих примерах или инструкциях. которые описывают структуру этой базы данных и ее содержимое, и каждый раз, когда база обновляется, ее потренировать. Но для этого нужны вычислительные ресурсы, которые, по-моему, еще на порядок увеличивают стоимость этой технологии в том виде, в котором она есть сейчас. 

S03 [01:13:17]  : Как-то так. Да, спасибо большое. Спасибо. 

S01 [01:13:22]  : Так, давайте, значит, мы... Хорошо, разговор пошел. Давайте мы тогда сейчас пробежимся еще по вопросам. 

S00 [01:13:30]  : Добрый день. 

S01 [01:13:32]  : Как вы выражали сложноподчиненное предложение в вашем языке? Значит, здесь примерно так же, как они строятся в Искуэле. То есть в SQL вы можете писать многостраничные SQL-запросы совложенными. SQL-ами, объединенными через Union, а потом тоже куда-то вложенные другие SQL-запросы. Возможность построения сложных SQL-запросов, включая вложенные SQL-запросы, она ничем не ограничена. только вычислительными ресурсами, которые требуются на обработку этих SQL запросов. Точно так же в нашем языке. Вы можете вкладывать одни запросы в другие. Вы можете говорить, что вместо target в качестве вместо 20 у нас может быть другой запрос. Мы можем написать Установи у термостата, который находится на кухне, такую же температуру, как у термостата, который находится в том же самом месте, где находится мой любимый холодильник. Ну и дальше вопрос в том, что система должна правильно произвести поиск по графам и найти сначала тот термостат, который находится в том же месте, где находится мой любимый холодильник, потом должна определить его температуру, а потом эту температуру должна подставить в термостат, который на кухне. Может оказаться, что это будет тот же самый термостат, Тем не менее, суть от этого не поменялась. Был ли тест извлечения данных из нейросетей? Это отдельная история. Это боль. Как извлекать знания из нейросетей? На самом деле у нас был проект. где мы пытались извлекать грамматические данные, я вспомнил, из нейросетей. Мы даже называли процесс «выдаивание». Мы натренировали нейросеть, конкретно BERT, на некотором корпусе и дальше пытаемся из нее выдаить грамматику. Как-то эта грамматика выдаивалась, но на том этапе не очень хорошо. Качество этой грамматики оказалось не лучше, чем качество той грамматики, которую мы выдаивали просто символьными методами, вычисляя взаимную mutual information или взаимную информацию между совместной встречаемости различных токенов по предложениям. Убедительного преимущества знаний, извлеченных из нейросетей, по сравнению со знаниями, извлеченных без применения нейросетей Получить не удалось. Только методами статистическими и стандартными мы получали данные за 12 часов из этого корпуса, а нейросеть с последующим выдаиванием те же знания за пару месяцев давала. Но это было давно. С тех пор извлечением данных из нейросетей не проводили. Хотя тема интересная. Как раз на предыдущем докладе у меня первый слайд был на тему того, что у нас знания могут быть представлены в символьном или структурированном представлении. С правой стороны они могут быть представлены в виде нейросети, и с одной стороны мы можем загружать знания в нейросеть. и заставить НИР выполнять запрос в контексте этих знаний, это вот с одной стороны, а с другой стороны мы эти знания из нее как бы можем извлечь. Как извлечь из нее, это пока открытая тема. Так, как написать на ИЛ, например, перед тем, как СТМТ, было СТМТ? Тут есть разные варианты. Либо у конкретных СТМТ время указать. Это один пример. И дальше апеллировать ко времени. Допустим, вчера stmt.timesyesterday.stmt.timestoday. Это один вариант. Второй вариант, там есть ключевое слово then. На самом деле слово next было предусмотрено спецификацией, но в существующей версии оно так и не дошло дело до его реализации, но тем не менее оно есть. То есть можно просто последовать упорядоченную последовательность стейтментов. Как раз используется структура упорядоченная последовательность, где мы можем, собственно, некоторый сценарий, исполняемый во времени, разложить как раз по этой последовательности. То есть, два метода. Либо через время, либо через явно заданную последовательность. Дальше. Есть ли у вас парсинг данных из Telegram-канала с визуализацией данных? Конечно. Давайте я сейчас кину ссылочку. Вот, то есть, вот, собственно, к сожалению, к сожалению, Medium у нас не очень доступен, но, соответственно, либо через VPN-у, либо через Fast Proxy. Прокси. Через Fast Proxy можно заходить. Вот этот вот сайтик, где у меня Fastproxy, вот есть Fastproxy. Он у меня включен, соответственно, на Medium можно заходить. И вот тут описано, как мы с Telegram работаем. У нас есть реализация для слэка, но там со слэком не полностью сертифицирован клиент, поэтому, чтобы под слэком работал, нужно там некоторую легальную работу проводить, но в принципе слег поддерживается. Поддержать ВК проблем нету, просто не было сделано, а Телеграм работает давно, и там из Телеграма анализируются и сообщения, и модерацию можно делать сообщений, и репутационные графы на основе коммуникации в Телеграме строятся. Это все есть. 

S04 [01:20:27]  : Я извиняюсь, а это можно только через этот сайт? Или же есть какое-то приложение? 

S01 [01:20:33]  : Смотрите, давайте я покажу. Вы можете либо нашего бота, давайте я покажу, либо через этого бота. можете подключить свой сайт. То есть, грубо говоря, вы сами в этом боте регистрируетесь и делаете его, добавляете его в свои группы, которые вы хотите анализировать, и делаете его там админом. Тут это все описано в статейке. Это вы можете делать через нашего бота, но в принципе ничто не противоречит. Сейчас. так вот вот но никто вам не мешает никто вам не мешает Никто вам не мешает развернуть… Вот интеграция со слаком, интеграция с телеграммом описана. И никто вам не мешает развернуть собственный… Вот integration for telegram. Описаны все нюансы по интеграции с телеграммом. И никто вам не мешает, что характерно, развернуть свой собственный сервер и на этом сервере создавать своих собственных агентов. Я должен сказать лишний раз, воспользоваться тем, что Дуров большой молодец с точки зрения возможностей. Сейчас я кину ссылочку на наш чат. Вот, что конечно у Телеграма совершенно замечательные возможности по автоматизации и по разворачиванию ботов по сравнению с кем-либо то ни было. То есть в отличие от всего остального вы можете развернуть своего бота на Телеграме, хоть у себя на столке. арендовать для этого выделенный сервер не нужен, заводить сайт для этого не нужно. Скорость реакции, конечно, если вы развернете бота на сайте, будет больше, потому что Telegram сможет ваш сайт через колбыки дергать. Но если скорость реакции для вас не критична, то вы можете развернуть его на своем собственном сервере или на любой машине. и через полинг периодически высасывать всю нужную информацию и соответственно на нее реагировать. 

S04 [01:23:19]  : Звучит шикарно. 

S01 [01:23:22]  : Сейчас давайте я вернусь в наш разговор. Мне не хватает возможности задавать LLM скриптовым языком. Думаю, продвинутый пользователь. Буду использовать DSL. Как раз один из способов, который, насколько я понимаю, Александр Балдачев использует. Он учит LLM разговаривать на своем собственном языке семантическом. И на нём с ними работает. Через месяц, по-моему, он, возможно, про это сможет рассказать. По-хорошему, должна была бы быть возможность для решения этой задачи. Возможно, она есть. Где-то недавно промелькала какая-то статейка с похожими словами. Я её не помню. что это что-то про фиксированный кэш, когда мы вроде как можем зафиксировать какой-то некоторый кэш, сказать Лилемке, чтобы она его никогда не выкидывала, и забить туда все, что нам нужно, и оно там будет как бы постоянно, и мы сможем в рамках текущей секции с этим всегда пользоваться. Ну, вот да. Before thermostat temperature is below 30, I go outside. Ну, как-то так. Как-то так, но before не было. Я вот не совсем понял. Вопрос Крио Де Банк задал. Можно ли описать следующее? Before thermostat temperature is below 30, I go outside. Это мы программируем. На самом деле, я вижу здесь программирование продукционных правил. Да, что-то такое было. Я сейчас точно не помню. Есть пример в статье. Я ссылку на статье кукину. Там как раз подобный пример есть. Только там, по-моему, не before, а через than используется. Там еще было кроме ключевого, так сказать, в продвинутой версии языка, кроме слова next, которое говорит последовательность, было еще слово than, импликация. То есть, если выполняется какое-то условие, то потом идет than, которое должно инициировать то действие, которое произойдёт, если произойдёт выполненное условие. Поэтому правильное выражение было бы так – thermostat temperature below 30, then go outside. Скорее так это выглядело бы. Какие задачи стоят в аналитике этого графа? Ну, задачи аналитики графа, давайте сейчас тогда раз по аналитике графа вопросы возникли, я сейчас туда вернусь. Так, я сейчас туда вернусь, в аналитику графа. Значит, какие задачи стояли в аналитике графа? Так, это они у нас ниже. Вот, соответственно, что мы делали и делаем? На основе в этом приложении. Желтеньким показана та информация, которую мы можем черпать из источников, перечисленных выше. У человека могут быть явно заданы какие-то топики, которые он предпочитает. и у его окружения также могут быть явно заданы эти топики. А, нет, наоборот, серое – это те данные, которые мы черпаем, а желтенькое – это то, что мы как бы выводим на основе серенького. То есть, серенькое – это информация, которую мы черпаем. универсальном транзакционном представлении, значит, описывали следующие отношения. Во-первых, конкретный человек, как я, так и любой из участников моего окружения, может, значит, комментировать что-то, значит, где комментарии, может быть, как оригинальный пост, То есть я комментирую в пустоту. Я комментирую в пустоту. Это вот пост. Либо это может быть комментарий на пост. Соответственно, текстовые сообщения либо в виде постов или сообщений в социальной сети. Либо комментариев на какие-то чужие посты. Либо сообщения в социальной сети. Текстовые сообщения. Дальше. Это могут быть некоторые лайки. Или голосование, или вот. То есть я либо лайкаю что-то, либо голосую за что-то. И это могу делать как я, так и пользователи. Это вот то, что мы фиксируем. Дальше, соответственно, в каждом посте или комментарии могут использоваться какие-то слова и фразы. которые я могу использовать для анализа. И дальше между пользователями происходят следующие отношения, которые мы тоже фиксируем. Кто-то стал кому-то последователем, кто-то перестал быть кому-то последователем, кто-то кому-то что-то заплатил. Если мы информацию из блокчейна берем, либо кто-то на кого-то комментарий повесил, либо кто-то кого-то упомянул. Да, еще упоминания тут на самом деле есть. Вот все серенькое это то, что мы анализируем. И все эти стрелочки проиндексированы временем. То есть, на любую серенькую стрелочку у нас есть таймстэмп, мы знаем, когда это происходило. Ну и дальше из этого всего мы выводим следующую информацию. Мы анализируем, что было предметом моего внимания за те или иные периоды и что было предметом внимания моих друзей, поскольку у нас есть календарь. Вот здесь мы говорили про лыжи, тут мы говорили про горы, тут мы говорим про работу, тут мы говорим про лилиемки, тут мы говорим про новый год, тут мы говорим про отпуска. Вот, значит, поиск людей близких, поиск единомышленников. Опять-таки, во времени. Кто был единомышленником вчера, кто больше похож на единомышленника сегодня. Соответственно, интересы друзей, мои собственные интересы и их изменения по времени, все проиндексировано по календарным периодам. Дальше, значит, люди по рейтингу друзья, да, то есть не просто похожи на меня друзья, это кто не просто похож на меня, а с кем мы поддерживаем более-менее тесные отношения. Значит, фанаты или поклонники. уделяет мне существенно больше внимания, чем я им. То есть, кто лайкает мои посты и комментарии, кто лайкает меня, кто комментирует мне, кто упоминает меня, моя аудитория. Авторитеты – это противоположное фанатам и поклонникам. Это авторитеты или лидеры мнений. То есть, кого я лайкаю, кому я комментирую, кого я упоминаю. Дальше. Моя репутация или карма по периодам. То есть, на основе всех этих взаимоотношений сетевых мы вычисляем то, что называется репутацию или карму, которая как и у меня, так и у любого участника сообщества может меняться по периодам. Соответственно, на основе Этих графов мы также в рамках сообщества можем осуществлять выделение различных поведенческих типов. Допустим, вот у нас вот это вот узелок, вот каждый кружочек здесь – это определенный узел, это определенные пользователи. Вот здесь вот пользователь типа последователь, у него много лидеров мнений, репутация по вертикали или карма по вертикали. на каждом из четырех графов. Вверх репутация выше, вниз репутация ниже. Соответственно, человек, которого мы рассматриваем, находится в середине. Соответственно, у всех наверху репутация больше, чем у этого участника. Соответственно, они все являются его авторитетами. Вот внизу слева у нас опинион лидер. Выше его никого нету, зато все за ним ходят табуном, все его лайкают, все его комментируют, все его упоминают. Социальный тип равный или пир. У него куча контрагентов или партнеров с репутацией на одном уровне рядом с ним. Соответственно, они имеют примерно одну и ту же репутацию и поддерживают симметричные связи. Социальный тип-коннектор, или социальный хаб еще его называют, у которого и в данном случае есть несколько, в данном случае два лидера мнений, и некоторая небольшая, но тем не менее имеющаяся аудитория поклонников. Соответственно, стрелочками в обе стороны здесь показаны интенсивности коммуникаций. и в другую сторону, где коммуникации можно показывать, как настраивать либо это только текстовые коммуникации, либо только финансовые коммуникации, либо и текстовые и финансовые. Кружочками здесь показано как раз сходство. В данном случае облачка вокруг кружочков показывают семантическую или смысловую или, так сказать, по топикам интереса, близость между тем, кто в центре, да, это, условно говоря, я или выбранный пользователь, и всеми остальными. То есть, вот мы видим, что для этого товарища в центре максимально близким по интересам является вот этот вот лидер мнений. А вот у этого лидера мнений максимально и среди большого числа поклонников есть два, которые ему близки по интересам. Вот этот вот слева максимально близок по интересам и вот этот вот внизу. По этому графовому представлению можно бородить. Эта картинка показывает, что правило шести рукопожатий, которое в какое-то время анонсировали, что от любого человека на земле до любого человека можно дойти через шесть рукопожатий. Оказывается, что даже в рамках одной социальной сети это не так. Потому что мы, допустим, берём некоторый граф, находим там некоторого пользователя и идём из этого пользователя пытаемся найти, кто для него является авторитетом. Вот пришли к этому. Выяснили, что вот у этого пользователя авторитетом является этот, мы решили посмотреть, а кто еще является его авторитетом. Тыкаемся на него, приходим сюда. Выясняемся, что сам этот пользователь имеет кучу пиров. Вот два поклонника у него, ну вот у него наверху один авторитет. Тыкаемся в него, приходим сюда. вот тыкаем значит соответственно тыкаемся вот того кто у него на самом верху приходим сюда тыкаемся того выбираем того кто у него наверху тыкаемся сюда и вот так вот идем по графу попытаемся найти все время значит того кто является авторитетом и в итоге поход приходим вот к самому верхнему значит авторитету данной сети но получается у нас не 6 рукопожатия 1 2 3 4 5 6 7 10 рукопожатий понадобилось. Более сложный граф – это графы, которые вычисляются в соцсети эфир. Там обычно все графы сводятся к некоторым криптообменникам. Обычно все подсети транзакционные, они сводятся к криптообменникам. Можно по этим графам рейтинговать криптообменники. Вот, значит, анализ как раз социальных взаимодействий. Здесь вот как раз мы можем выделять разные типы связей. То есть, вот показано, что, можно указывать, вот если мы показываем все типы связей, то вот получается такой граф. Если комментарии, комментарии и голосование и платежи. транзакции между пользователями. Соответственно, зелененьким, по-моему, показываются финансовые транзакции, синеньким – текстовые коммуникации, а сереньким – лайки. Если мы включаем только комментарии, то вот получается только граф с синими стрелочками. Если мы оставляем только транзакции финансовые, вот получаются всего две стрелочки. Если мы оставляем только голосование, то получаются вот эти две стрелочки. Соответственно, мы можем изучать структуру некоторого онлайн-социума с точки зрения, во-первых, как репутационной структуры, кто наверху у того соответственно выше репутация, так и с точки зрения тематической близости или семантической близости по интересам коммуникационным Это вот в данном случае подсвечивается вот этими нимбами, ширинами нимбов. Так и структуру взаимодействий. Где у нас финансовые взаимодействия, где коммунеотекстовые, а где, так сказать, одобрятельные. Ну вот, ответ на вот этот вот вопрос. Так, какие еще есть вопросы? Так, последнее сообщение. А как у вас совпала оценка, выданная ботом от вашей собственной активности в сообществе? Ну, у меня нормально совпало. То есть, я регулярно смотрю. Да, значит, на всякий случай, если вдруг кто-то спрашивал, вдруг будет пользоваться, значит, Естественно, могут быть баги. Это проект в виде работающего прототипа. Поэтому, если будут баги, то обращайтесь. Но, в целом, работает. Оценка совпала, совпадает. В общем, совпадает. Я периодически эти отчеты смотрю и вижу реально, что те люди, которые охотятся вверху репутационного скоринга. Они являются действительно заслуженными участниками сообщества. Тут все нормально, что называется. Еще вопросы? Коллеги, у нас уже прошло Почти два часа, поэтому, наверное, сегодня давайте мы закончим. Соответственно, на проризонеры и системы представления знаний тогда оставим разговор. Следующую систему представления нечётких знаний оставим в следующий раз, потому что времени уже много. И время запланируем, наверное, уже это будет в начале марта. Есть у кого-то еще вопросы или комментарии? Нет. Тогда всем спасибо. В понедельник у нас будут через буквально четыре дня дифференциальные онтологии. В следующий четверг Татьяна Шаврина будет рассказывать про то, насколько далеко нас, Лелемки, придвинули к AGI. В конце февраля Александр Балдачёв будет рассказывать про те вещи, про которые мы говорили сегодня, но в рамках, отталкиваясь от своего собственного проекта, на основе событийной онтологии больших языковых моделей. Ну и к разговору о резонерах и системах представления нечётких знаний мы поговорим, видимо, уже в начале марта. Всем спасибо за участие и всего доброго! 






https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

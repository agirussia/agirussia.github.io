## 23 января 2025 - Редакторы и просмотрщики онтологий (на примере Webstructor), DSL-и (на примере ORL) - Антон Колонин (AGIRussia, Aigents, НГУ, SingularityNET)
[![Watch the video](https://img.youtube.com/vi/WSkd1008hGE/hqdefault.jpg)](https://youtu.be/WSkd1008hGE)
- [видео в ВК](https://vkvideo.ru/video-210968399_456239210)
- [видео в RUTUBE](https://rutube.ru/video/d0f42d6f0d7c38afcecf03d9f9f32f6f/)
- [расшифровка](https://github.com/agirussia/agirussia.github.io/blob/main/workshops/2025/23_january_2025_Editors_and_viewers_of_ontologies_Anton_Kolonin.md)
- [слайды](https://aigents.com/papers/2025/ontologies-webstructor-aigents-2025.pdf)

**Суммаризация семинара:**

Основные темы и тезисы:

Актуальность онтологий в эпоху трансформеров:


Важность символьных моделей для интерпретируемости и доверенных систем ИИ
Необходимость в верификации знаний
Применимость в случаях недостатка данных для машинного обучения
Возможность комбинирования с нейросетевыми подходами (например, GraphRAG)


Уровни работы с онтологиями:


Foundation ontology (мета-мета-онтология) - базовые концепты
Domain ontology (мета-онтология) - верхнеуровневая модель предметной области
Прикладной слой - конкретное наполнение
Уровень данных - конкретные экземпляры


Исторический опыт разработки (1993-1999):


Разработка универсального представления бизнес-логики для разных CASE-систем
Создание системы с базовой онтологией из четырех сущностей
Реализация объектно-реляционного языка (ORL)
Проблемы и открытия в области моделирования:

Объект может быть классом
Связь может быть узлом
Необходимость гибкой модели для разных представлений




Практические реализации:


WebStructor - система для редактирования и обмена знаниями
Поддержка различных интерфейсов (консоль, 2D/3D редактор)
Возможность распределенной работы
Проблемы с производительностью на тогдашнем оборудовании


Ключевые выводы:


Двумерные интерфейсы практичнее трехмерных для рабочих задач
Табличное представление часто эффективнее графового
Сложности с удалением и редактированием в распределенных системах
Важность единого формата для обмена данными между системами


Современные параллели:


Сходство с концепциями Google Knowledge Graph
Актуальность проблем интеграции разных онтологий
Сложности перевода между разными концептуальными моделями
Конкуренция с нейросетевыми подходами за финансирование

В ходе семинара также состоялась оживленная дискуссия о природе DSL (Domain-Specific Languages), способах представления знаний и практическом применении онтологий в современных системах. Были затронуты вопросы реализации бизнес-процессов, верификации знаний и проблемы согласования разных концептуальных моделей.



**Расшифровка**


S03 [00:00:08]  : Коллеги, всем добрый вечер. Начинаем очередной семинар русскоязычного сообщества разработчиков общего сильного искусственного интеллекта. Поводом для семинара послужило бурное обсуждение, которое состоялось буквально чуть ли не в новогоднюю ночь. Первое января оно активно происходило. Речь шла о редакторах антологий или семантических графов. о DSL, о Reasoner. И возникло предложение на эту тему поговорить всем заинтересованным. Я с своей стороны предложил в качестве повода для разговора рассказать о том, что я сам делал на по трём упомянутым темам. Алексей Незнамов на предыдущем докладе сделал фантастический по широте и полноте и глубине доклад по поводу того, что на эту тему делается на свете. И даже не полностью на самом деле раскрыл эту тему. Будем надеяться, что он найдет возможность раскрыть эту тему на следующих семинарах или пригласить своих коллег. Но я буду рассказывать не о том, что происходит на свете. Я буду рассказывать о том, что делал сам. Вот и буду акцентировать на некоторых потенциально важных вещах, которые, мне кажется, либо были важными и имеют некоторый интерес исторической точки зрения, либо, может быть, еще до сих пор имеют свою актуальность и кому-то помогут в будущем. Идея была не просто позаставлять кого-то что-то послушать, а именно поговорить, если вдруг по ходу разговора будут возникать вопросы. и возникнет желание и возможность провалиться в полезную дискуссию, то я предлагаю в режиме свободного микрофона брать слово, перебивать и обсуждать. Я думаю, мы справимся в таком варианте. Итак, я демонстрирую экран. В худшем случае мы не дойдем до конца моих сегодняшних слайдов, а отложим продолжение на будущее. Итак, я вначале хочу заострить внимание на двух вещах, почему, мне кажется, важно в век торжества трансформеров и глубоких нейронных сетей говорить об антологиях. Мне кажется, есть еще ряд людей, которые разделяют эту точку зрения, что вычисления когнитивные, скажем так, на основе символьных моделей, либо с четкой логикой, либо с нечеткой логикой, или какой-либо вероятностной, неаксиматической, или другими видами логик. Они имеют значимость, во-первых, с точки зрения интерпретируемости, если мы собираемся строить так называемые доверенные системы искусственного интеллекта, или если мы собираемся строить системы, где мы хотим иметь возможность верифицировать знания. Или если мы хотим строить системы, где знания не могут быть введены в систему иначе, как экспертным путем, потому что у нас просто нет достаточно больших объемов данных для машинного обучения на основе нейронных сетей. Во всех этих случаях имеют право на существование различные системы, основанные на антологиях, геохилиосемантических графах или символьных моделях. которые могут использоваться либо с помощью резонанеров, которые непосредственно осуществляют индуктивный, дедуктивный, абдуктивный или какой-либо другой логический Или, вероятно, с аналогичным выводом на этих графах. Либо эти графовые модели могут загружаться в нейросетевые модели и эти нейросетевые модели могут дообучаться на основе этих знаний. Либо эти графы или графовые модели могут извлекаться из нейросетевых моделей и верифицироваться экспертным путем, а потом загружаться в эти нейросетевые модели, либо и то и другое может сосуществовать одновременно, как это сейчас становится все более и более популярно на основе технологии типа GraphRack, это графический Retrieval Augmented Generation или сейчас это еще называется KAG, Knowledge Augmented Generation, когда в глубокие нейросетевые модели и фреймворки многоагентные, на них основанные, включаются механизмы извлечения информации графового база знаний и эта информация интегрируется в результаты вывода и контекст нейросетевых моделей. Следующий момент, который мне представляется важным, это разделять и каким-то образом интегрировать работу с тем, что мы называем онтологиями, как минимум на трех, но скорее всего на четырех уровнях. То есть, во-первых, у нас есть уровень того, что здесь называется foundation ontology, это верхний слой, или meta-meta-ontology. Это некоторый базовый набор понятий, с помощью которых мы оперируем самими понятиями. Например, в онтологии, которая принята в тех проектах, с которыми я сейчас сам работаю, я про них буду говорить, И в антологии, которая взята на основу в схеме Орг, базовыми вещами являются на самом деле вещь, это thing, и свойства. которая в этой вещи есть. То есть, любая вещь имеет свойства, и, соответственно, из обладания некоторой вещью и некоторых свойств выводится все остальное. То есть, все атрибутные составы различных доменспецифических антологий, они описываются через эти базовые вещи как вещь и свойства. Ну и, соответственно, следующим слоем, который мы здесь рассматриваем, должны рассматривать под foundation ontology или meta-meta-ontology является некоторая как бы уже доменная онтология или мета-онтология, которая описывает, скажем так, верхнеуровневую картину конкретной предметной области, где мы, допустим, описываем, если мы говорим про медицинскую сферу деятельности медицины у нас описываются такие понятия, как лекарство, бренд и действующее вещество в одной системе. А в другой системе это может быть только лекарство и бренд, например. Из реальной жизни, просто это некоторая практика разработки приложений для медицины, в реальной жизни сталкиваются системы, что эти верхние антологии или мета-антологии для различных систем, допустим, которые работают с медицинскими препаратами, они оказываются разными. Вот, и если мы хотим строить мультиагентную систему, где в данном случае агентами могут являться две системы, которые хотят, допустим, экспортировать и импортировать данные из одной системы в другую, да, допустим, у нас есть две аптечные сети, которые налаживают партнерские отношения и хотят обмениваться информацией, которая есть у той и в другой сети в каталоге, то им необходимо как-то договариваться, что вот как отображать, значит, прайс-лист или продуктовый каталог одной компании на прайс-лист или продуктовый каталог другой компании, соответственно, для того, чтобы оперировать с понятиями типа класс, атрибут или вещи-свойства, или сущности-отношения. Здесь вот уже начинаем играть в различные мета-мета-онтологии и их термины. Им нужно как-то договориться, что вот если мы, к примеру, знаем, что в одной системе у нас лекарства, есть два свойства, такие как бренд и субстанция или действующее вещество, а у другой онтологии есть только лекарство и бренд, то при экспорте данных либо нужно действующее вещество выкидывать, либо нужно в верхнюю онтологию или мета-онтологию второй кампании просто импортировать понятие верхнего уровня в действующее вещество с тем, чтобы она расширила свой функционал и получила большую информацию. Дальше возникает прикладной слой наполнения продуктового каталога. Мы уже наполняем конкретные товары или продуктовые позиции, которые у нас поступают в рамках вот этой вот верхней онтологии, да, конкретно ибупрофены и аспирины или ацетилсалициловые кислоты со своими действующими веществами и брендами. Ну и на четвертом уровне, который здесь уже не показан, это уже даже, собственно, не онтология, это как бы уже сама данная, это уже сами данные, да, это уже собственно те графовые данные, которые подкрепляют, являются прецедентами или экземплярами вот этих вот сущностей, которые описываются вот этой вот трехуровневой онтологией. Это конкретное поступление товаров с конкретными, значит, датами поступлений, с конкретными количествами, конкретными весами, цифрами. И важным при разработке некоторой системы, основанной на антологии вообще и на многоагентной антологии в частности, является некоторым образом правильное выстраивание этой базовой антологии. И оказывается, существуют разные способы, разные принципы построения этих базовых или фундаментальных мета-мета-антологий. Для продолжения разговора я вернусь к некоторой истории, каким образом я попал в эту тему, которая касается и визионеров, и графов. В 1993 году я занимался таким интересным проектом в американской компании. Там была следующая задача, может быть не все знают. в конце 70-х, в начале 80-х годов, или даже, может быть, ещё в конце 80-х, точную дату не помню, может быть, даже в начале 90-х была очень популярна технология CASE. Case-based software engineering, по аналогии с CAD. Computer-aided design, когда мы с помощью компьютеров разрабатываем чертежи промышленных каких-то изделий или конструкторскую документацию. А были модные технологии, когда с помощью программных средств разработывали дизайны и конструкции программного обеспечения. Идея была такая, что мы можем с помощью прямоугольников и стрелочков нарисовать некоторую схему данных, нарисовать некоторую бизнес-логику. Примерно так, как сейчас некоторые делают с помощью UML. Но тогда слова UML еще не было, самого UML еще не было. Были разные аннотации разных авторов разных компаний, были продукты таких компаний, как IBM, Oracle, Tejas Instruments. Компания, которая сейчас, по-моему, даже уже не существует. Это были вот такие вот монстры, которые создавали свои собственные технологии именно графического дизайна программных приложений, включая как бизнес-данное, так и, собственно, логику исполнения программных приложений. Дальше предполагалось, что на основе этой логики генерируются коды SQL, генерируется программная логика на кабеле, и это все запускается в производство. Потом этот поход начали распространять на разработку на языках Java, на языках C++. Проект, которым мы занимались, заключался в том, что нам нужно было моделировать эти приложения, то есть компания занималась моделированием производительности вот таких корпоративных приложений. Исходными данными являлись либо логи SQL, либо вот эти вот конструкции, проектная документация в виде моделей цифровых бизнес-приложений любой из этих систем. Задача заключалась в том, что нужно получить вычислимое представление энтерпрайзного приложения и просимулировать его работу и оценить его производительность при определенных метриках. И поскольку исходными данными являлись либо тексты программ на Каболе, либо вообще логи, которые снимали из базы данных, с одной стороны транзакционные логи SQL, с другой стороны логи программ на Каболе и сами исходники программ на Каболе, либо модели приложений в системе Oracle, либо IBM, либо TX Instruments, возникла идея, чтобы не писать четыре среды эмуляции, сделать некоторое унифицированное представление, универсальной бизнес-логики и структуры данных с тем, чтобы ее можно было промоделировать. И, собственно, я делал конвертер, который из разных представлений, из логов, исходников разных моделей разных производителей, сводил это все в некоторую универсальную вычислимую форму, и в ходе этой истории развилась идея. Почему? Зачем вообще нужны исходники? Зачем нужны модели, если можно вот некоторое унифицированное исполнимое представление бизнес-приложения взять, почему его нельзя просто исполнять как мы исполняем набор машинных инструкций вот соответственно в рамках прототипа была значит уже отдельно в отдельном проекте это уже делалось не на западную компанию в рамках собственного так сказать стартапа была написана программа на основе некоторой мета-онтологии, про которую я сейчас расскажу. Она тут показана слева, я расскажу сейчас, как она устроена была. На основе этой мета-онтологии разрабатывались мета-онтологии и конкретные бизнес-приложения для набора задач или набора приложений. Во-первых, как это выглядело. Была некоторая структура данных, которая сегментировалась на модели данных. на формы, отчетные формы отчетов и входные формы, с которыми работали и пользовались, то есть экранные формы, отчетные формы, графические представления, текстографические представления, структуры данных, реляционные, естественно, функции и процессы, то есть вся бизнес-логика пользователей с их правами на вот четыре как бы категории данных которая хранилась в системе и было два интерфейса к этой системе был интерфейс дизайнер дизайнера где аналитик мог редактировать структуры данных было дизайнер форм где аналитик мог редактировать формы дизайнер процессов где аналитик мог писать программы с помощью в терминах тех же самых примитивов унифицированной модели и, соответственно, управлять пользователями. И был процессор. То есть система, которая могла либо анализировать структуры данных, либо генерировать или снимать информацию, управлять поведением входных-выходных форм, либо исполнять соответствующие процессы, либо все это разграничивая доступ между соответствующими пользователями. И это было реализовано, на основе этого была реализована система управления пользователями CRM, главная бухгалтерская книга, система управления склада, система расчета заработной платы и система продаж для управления розничным магазином. Проблема заключалась в том, что поскольку это все было сделано в 95 году на существующих вычислительных средствах, на персоналке и с теми базами данных, которые тогда были. Небольшой объем памяти, там по-моему 640 килобайт, по-моему, была база данных. Там были типа DBase, FoxBase и так далее, значит, навигационные базы файлового типа. Все это работало настолько медленно, что никакой практической применимости удумать было нельзя. Это просто работало. На 3-4-5 объектах это еще как-то работало, а никакой продакшен выносить было нельзя. А модель была вот такая. У нас были с одной стороны сущности и отношения. У нас есть абстрактная сущность. И для каждого типа сущности или класса сущности мы описывали соответствующие отношения, которые связывают ее с другими сущностями. Соответственно, у каждой сущности могли быть какие-то экземпляры, которые к этой сущности относились как к типу, вершины, ноды, и, соответственно, связи, которые являлись экземплярами отношений. Самая каждая связь имеет отношение типа к некоторому отношению, и тоже связи есть парень-чайл. Ну и у каждого из этих прямоугольников был фиксированный набор атрибутов, ну и с помощью вот этих всего четырех базовых сущностей можно было описывать вот это все многообразие того, что нарисовано с правой стороны. Ну там еще были технические моменты, у ноды были индексы и некоторые аттачменты в виде данных, но это уже не столь важно. Интересно, что когда в 2013 году взлетел И попал, значит, и продался Гуглу Фрибейс. Вот. То есть, Фрибейс, когда Гугл, значит, напоминаю, что в начале, в какой-то момент, в начале двухтысячных, когда Гуглу сказали, Гугл, значит, не собираешься ли ты вот заняться онтологиями, семантикой, Гугл сказал, что нам и так хорошо, значит, у нас текстовый поиск и так нормально работает. Вот. А в 2013 году Гугл внезапно Приобрел Freebase, сделал его публичным, стал его раскручивать, сказал разработчики всего мира давайте вместе сделаем всемирную семантическую базу данных. Разработчики всего мира дружно несколько лет эту базу данных наполняли своими сущностями и отношениями по всем поводам предметным областям потом а после чего google сказал ну вот еще там вам пара месяцев на то чтобы скачать кому надо а после чего мы доступ закрываем и используем это внутренне И до сих пор они это используют внутренне. Но до того, как они это дело закрыли, я ради интереса расковырял то, как у них там всё устроено. И обнаружил, что устроено оно было примерно так же. Полное зеркальное отображение. Соответственно, у них была сущность типа тип и сущность типа проперти. Естественно, сущность типа проперти была привязана к конкретному типу. Дальше у них была сущность, соответственно entity это type, relation это property. Дальше у них была сущность типа object, это наш нод и сущность типа link. Это соответственно link. Обращаю внимание на следующий момент. Чуть позже станет ясно почему, но это обращаю внимание, что на этой схемке у них объект является экземпляром типа вот черненькая стрелочка это экземпляр объект является экземпляром типа связь является экземпляром свойства да вот точно так же как у нас было на левой стороне но у них еще есть важная стрелочка из из kind of да что на самом деле тип сейчас секундочку а нет нет извиняюсь значит у нас сейчас значит то есть у нас есть же два этих самых отношения из kind of и instance of соответственно у нас объект является instance of Объект является instanceOfType, то есть instanceOfType – это черненькая стрелочка, link является instanceOfProperty. А property является isKindOfLink. и тип является из kind of object. То есть, важное достижение, которое появилось у Freebase, это они отнаследовали тип от объекта и они отнаследовали свойства от связи. То есть революционного по сравнению с Java тут ничего не было, потому что еще раньше, чем появился Freebase, в Java был сделан Reflection, модуль Reflection, в котором класс является наследником объекта, ну и метод соответственно тоже происходит от объекта. То есть у нас метаданные, как во Freebase, так и в Java, В C-Sharp метаданные являются данными. Метаданные – это специфические данные, которые управляют другими данными. В том числе, по идее, они должны управлять самими себями. Но в процессе практической работы с какими проблемами мы столкнулись? Мы столкнулись с тем, что в рамках той модели, которую я с левой стороны показал, мы не можем разрешить следующие ситуации, которые оказываются важными в ряде практических аспектов. Во-первых, мы обнаружили, в какой-то ситуации у нас не только класс является объектом. Нам в какой-то момент нужно сказать, что объект сам является классом. Пример показан слева. Вот у нас есть некоторый объект, от которого мы отнаследовали консумера и сапплайера, потребителя и поставщика. И мы отнаследовали и от потребителя, и от поставщика некоторого Джона Дойа. где Джон Дойя выступает с одной стороны как консумер, так и сапплайер. Но в какой-то момент нам может выясниться, что в той системе, по мере развития системы, у нас появляются новые сценарии, новые кейсы, новые приложения, в которых нам вот этот вот самый Джон Дойя в свою очередь должен выступать в качестве класса, и мы должны От него производить либо некоторые экземпляры, либо от него наследовать некоторые специфические подсущности вот этого Джона Дойя. В одном случае он выступает как доктор, в другом он выступает как мистер, в третьем он выступает как хасбанд. В четвертом он выступает как анкл. И у них там может быть различный атрибутный и функциональный состав. Это вот одна история. И вторая история, которая выяснена, то есть это вот, что не только класс является объектом, но объект тоже в каких-то случаях может являться классом. Но и другая интересная история, с которой мы столкнулись, и которой нам пришлось решать по ходу с помощью некоторых костылей, что у нас на самом деле связь. Она тоже в некотором случае может быть нодом. То есть мы не только можем связью связать несколько нодов, но мы в некоторых случаях должны от связи тоже отращивать какие-то отношения, то есть какие-то линки мы должны привязывать к какой-то связи и связывать эту связь либо с другими нодами, либо с другими связями. Например, мы сначала сказали, что Джон Дойа живет в Лондоне. А потом мы еще должны сказать, что оказывается он не просто живет в Лондоне, он живет там в какое-то время, да? А потом мы еще можем сказать, что он там живет с точки зрения кого-то, да? то есть возникает еще связь according to knowledge of и там имя человека в соответствии со знаниями которого он там живет или наоборот эта связь может быть связана в другую сторону то есть у нас может быть некоторая мэри энн которая имеет интерес к тому факту что джон дуэрр же находится значит проживает по некоторому адресу в лондоне на самом деле вот такие вот сложные зависимости информационную можно описывать по-разному. Если мы успеем сегодня, мы до этого дойдем. Но вот необходимость рассматривания некоторым образом связи в качестве полноценной вершины, она вот всплыла во всей своей красе. И, кстати, вот эта идея несколько лет позже, после того, как она в 95-96 году была обнаружена, эту идею удалось донести до Бена Герцеля и компании в 1998 году. В результате они создали систему Atomspace, как раз основанную на том принципе, что у них там нет нодов и нет линков, у них есть атом. А уже и нода, и линк, они происходят от атома. То есть вот такая уникальная фишка атомспейса, которую нет ни в одной, насколько я знаю, существующей из популярных графовых баз данных. Но про атомспейс, если мы успеем, мы еще поговорим сегодня. Теперь, что самое интересное. То, что я сейчас рассказал, я сейчас вернусь к этому слайду. Значит, вот это открытие мы сделали, грубо говоря, в 97-м году. А в 2019-м году или в 2018-м году, Евгений Евгеньевич не даст соврать, когда мы были в Праге на конференции AGI какой-то там номер, там за завтраком я случайно оказался с человеком, который в Гугле как раз разрабатывал Google Knowledge Graph. Вот. И, значит, ни с того ни с сего он стал мне делиться тяжелой жизнью в гугле и рассказал ровно вот про вот эту вот проблему, ровно про вот это вот все. И сказал, что они эту проблему осознали, и последний год они пилили решение, как им из вот этой точки перейти в такую точку. Как им перефигачить свой Google Knowledge Graph, чтобы можно было учитывать вот эти вот... инновационные особенности, без которых они какие-то задачки не могут решать. И после того, как они разработали некоторый прототип и пришли с ним к менеджменту, менеджмент схватился за голову и сказал, что в процессе переделывания вот этого прототипа у нас полетят все бизнес-приложения к черту. Ничего мы делать не будем. Идите, делайте что-нибудь другое. Вот он делился своей болью. Дальше перехожу к тем истории, к чему эта история пришла дальше. В 1997-1999 году на основе этих принципов, про которые я сейчас уже сказал, мы построили другую систему. Уже тогда появились революционные базы данных, которые работали побыстрее, поскольку все революционные таблички кэшировали в памяти. Мы разработали систему для автоматизации произвольного вида деятельности и уже решили, что описывать мы систему будем не просто в терминах каких-то графов, которая рисуется на уровне базы данных. То есть, все, что я здесь рассказывал, это все редактировалось в UI. И данные объекта набивались табличной формой, и отчеты рисовались графические, и функции, и процессы рисовались в виде некоторого дерева. А тут, поскольку в некотором бизнес-проекте задача была построить систему, где можно было взаимодействовать с сервером по некоторому клиентированному протоколу и специфицировать данные, аналитику без необходимости взаимодействия с графическим пользовательским интерфейсом на уровне некоторого языкового представления, то родилась концепция некоторого, как мы его назвали, объектно-реляционного языка, который бы позволял, с одной стороны, описывать объектную модель предприятия. Мы тогда в этом проекте не говорили слово «семантика», а слово «совсем». Мы говорили об объектной модели. И мы говорили в терминах того, что объектная модель предприятия включает в себя классы данных, классы бизнес-процессов, данные, бизнес-процессы, бизнес-правила, отношения между ними и все, что мы знаем и любим про бизнес-процессы и бизнес-логики. И, соответственно, было реализовано все, что нужно. Вот здесь мы видим иерархию классов. Здесь мы видим возможность определения атрибутов для этих классов. Здесь мы видим табличные представления данных, описанные в этой модели. Тут мы видим функциональный граф, который описывает просто функциональную декомпозицию, произвольную функцию. и является просто исполнимым кодом. Опять-таки, я подчеркиваю, что и в предыдущем проекте, и в этом проекте предметом исполнения программы и исходным кодом был граф. То есть, исходной моделью был граф, который никуда не компилировался, а просто интерпретатор шел по вот этому семантическому графу и исполнял соответствующие предикаты. да вот там и в дебет больше кредит это один предикат одна связь лет значит это другая связь там ду это третья связь да которая связывает определенные атрибуты но а хоть какие-то дополнительное значит расширение этих связи они описываются вот через тот механизм того что мы к любой связи в вершине можем привязать еще любое количество связей и вершин то есть мы по сути строим некоторый эротический гиперграф вот ну и какие уроки были извлечены из этого проекта значит ну во первых понятно что у нас класс является объектом объект является значит производным точнее класс является Класс is kind of object, объект is instance of class. Объекты могут иметь свою собственную иерархическую структуру, то есть некоторые объекты могут быть агрегациями других объектов. У классов может быть отношение, соответственно, тоже может быть своя какая-то внутренняя структура. Родительство этих классов примерно так же, как мы в Java можем определять внутренние классы. У классов есть атрибутный состав. Интересное изобретение, которое там возникло и которое было практически использовано, это то, что процесс, как мы обнаружили, Исполняемый процесс, он в некотором смысле, а в нашей системе это было в прямом смысле, является экземпляром объекта, является из kind of object, т.е. некоторый вычислительный процесс, который имеет место в конкретном месте в конкретное время, т.е. процесс выполнения некоторой бизнес-операции или бизнес-функции, неважно, либо это транзакция, Либо это какой-то бизнес-процесс, который применяется в отношении какого-то конкретного клиента. Допустим, проведение какой-то сделки от заказа до оплаты, отгрузки товара и подписания соответствующего акта. То есть бизнес-процессы могут быть короткие, краткосрочные, одна транзакция, покупка-продажа, а могут быть длинные процессы, долгосрочные, которые могут занимать годы, если это какой-то долгосрочный контракт. И может быть некоторая иерархия процессов, где краткосрочный процесс включается в какой-то среднесрочный процесс. Среднесрочный процесс имеет множество дочерних, краткосрочных процессов и относится к некоторому очень долгосрочному процессу. Кроме того, процессы могут быть между собой связаны в стеке. Соответственно, если один процесс выполняется на стеке другого, то у нас есть понятие некоторого текущего стека процессов. Ну и, соответственно, процесс на самом деле является экземпляром некоторого метода. То есть, определяя некоторые классы, которые описывают структуры данных, мы определяем некоторые методы, где метод, с одной стороны, сам по себе является производный от класса, поскольку у него тоже есть свои атрибуты, по сути, внутренняя переменная входные переменные выходные переменные вот и при исполнении метода у нас происходит инстанцирование у нас происходит создание экземпляра этого метода то есть процесса где мы заполняем некоторые входные атрибуты по ходу его жизненного цикла меняются на его внутренние переменные то есть его так сказать приватные атрибуты вот но и при завершении этого метода перед его финализацией. При завершении процесса, как экземпляра этого метода, при его финализации мы снимаем предсмертное значение его выходных параметров и передаем их в другой метод. Это была такая интересная фишка, которую мы активно использовали. Вот, ну и положительный урок, который мы извлекли из этой истории, это то, что, значит, на самом деле, да, значит, и для того, чтобы, вот, описывать эту систему не только на уровне, вот, значит, каких-либо деревьев, либо деревьев данных, либо функциональных деревьев, либо форм, а чтобы можно было описывать это на уровне языка, мы как раз тут разработали язык, который назвали объектно-реляционный язык, URL, в котором мы поняли, что нам не нужно несколько, грубо говоря, языков, да, то есть нам не нужно разделять, к примеру, SQL на язык манипулирования данных, с помощью которого мы описываем структуру таблиц, язык манипуляции данных, с помощью которого мы делаем select, absurd и delete, на PL, на язык программирования, да, либо в Oracle это у нас PL-SQL, либо в Microsoft это у нас Transact-SQL, Либо когда мы выгружаем данные, мы получаем просто tab-separated или comma-separated values. Мы можем все это описать в рамках одного языка. В рамках одной языковой парадигмы. И строить мультиагентные системы, где любая система, любой агент в этой системе может обратиться с любым запросом. к соответствующей системе корреспонденту с любым запросом. Ну и соответственно тоже самое касается графовых языков, то есть нам не нужно отдельно иметь язык для описания метаданных, отдельный язык для описания данных и отдельный язык для выполнения запросов к этим данным, когда мы все это можем сделать в рамках одного языка. Соответственно, вот здесь показаны примеры этого язычка. С левой стороны примеры на английском, с правой стороны примеры на нашем URL. С этим багажом дальше мы пошли. История этого проекта заключалась в том, что, несмотря на то, что проект делался по заказу большой российской конторы, конкретно эта контора называлась Российская торговая система, после того, как мы выпустили первую версию бета-альфа-версию, значит, там у RTS начались проблемы, они оказались не готовы пофинансировать дальнейшее развитие этого проекта. Поэтому следующие эксперименты с этим языком были сделаны уже в рамках, опять-таки, стартапа, который назывался WebStructor, где была сделана попытка, которая имеет уже непосредственное отношение вот к той дискуссии, которую Мы обсуждали в группе антологий. И недавно тут как раз возникла тема, как бы нам играфицировать историю с сознаниями. И как раз в связи с этим возникла у нас идея с одним коллегой. Конкретно идея возникла в результате завершения заказа по разработке одной игрушки для западного заказчика. И западный заказчик сказал нам, а теперь, ребята, давайте предложите концепт какой-нибудь новой игры, которую мы с вами вместе разработаем. Вот. И мы, значит, долго пыжились и за рюмкой чаю, извиняюсь, придумали игру, которую назвали «Обмен разумом». Идея была следующая, что мы создаем некоторое виртуальное пространство, онлайн-пространство. У нас есть интернет, куда заходят пользователи, вступает взаимодействие между собой, и каждый пользователь может рисовать свою картину мира. каким-то образом описывает, да, что он думает, что он знает, а другой пользователь может рисовать свою картину мира. И дальше они могут попытаться свои картины мира стыковать. То есть, по сути, вот кто, вот Александр Балдачев здесь точно знает эту историю про то, как мы, значит, составляли терминологическую табличку сообщества IGA Russia, чтобы состыковать различные онтологии, вот ровно такую же идею в качестве некоторой игры по моделированию пользовательских онтологий и интеграции и доказания непротиворечивости собственной онтологии самому себе, окружающим, а также доказательства того, что твоя онтология либо лучше других, либо эквивалентна им, либо включает их, либо является частью их, Вот это является предметом этой игры. Соответственно, возникло понимание, что мы можем это все очень хорошо вписать вот в ту концепцию, которую я показывал на втором слайде, что если мы договариваемся, что у нас есть некоторая базовая онтология, в которой у нас есть как минимум два вида сущностей, это вещи-свойства, и два вида базовых отношений, это обладание и наследование, И отталкиваясь от этой базовой онтологии из, по сути, четырех сущностей, из которых одна является универсальная «think», от которой все происходят свойства, является эта производная, ну а от свойства происходят две сущности отношения из ИХС, которыми обладает любая вещь. И отталкиваясь от этого, мы можем построить уже систему мультиагентного редактирования и обмена знаниями с каким-то пользовательским интерфейсом. Соответственно, с реализация каждого агента предполагалось, что может быть сделано как серверное, когда есть некоторый сервер, у которого нет пользовательского интерфейса, он является медиатором для различных терминальных агентов. Дальше есть десктопные агенты, которые живут на десктопе, да, и пользователи работают с ними десктопом. И есть агенты в апплетах, которые запускаются в браузере. Тогда джаваскриптовых приложений еще не было, это был 1997 год. Предполагалось, что веб-приложение работает во плете. Ну и, соответственно, для того, чтобы взаимодействовать с теми знаниями или онтологическими моделями, которые находились внутри, предполагалось использовать либо интерактивную консоль, где можно разговаривать на языке ОРЛ, либо двухмерный или трехмерный графический редактор онтологии. И первое, что было сделано после того, как был сделан некоторый прототип, был разработан конвертер верхней онтологии Сайко, и эта верхняя онтология Сайко была туда закачана. После того, как мы закачали туда верхнюю онтологию Сайко и принялись ее разглядывать, вот это пример. выгружены из энтеотологии, мы как раз увидели вот все эти примеры того, про что я говорил, про транзитивность отношений как генерализации, так и наследования. То есть, мы вот, например, видим, что здесь имеется некоторый подграф верхней энтеологии, по поводу, значит, таксономии животного мира, на примере собаки, вот, соответственно, из А Это у нас получается isKindOf, а GLS, а нет, сейчас, isA, isA это instance of, в переводе с цайковского, значит, в цайке isA это instance of, а GLS это isKindOf. Соответственно, вот у нас animal с одной стороны является isKindOfThin, а с другой стороны Mammal является из Kind of Animal, а Dog с одной стороны является экземпляром Biological Species, а с другой стороны конкретный пёсик, по которому зовут Фидо является экземпляром собаки. С помощью этой же системы Поскольку в тот момент мы начали работать с Пивангом и с Беном Гёрцелем и с их логиками верхнего уровня, Возникла попытка описать с помощью этой системы и визуализировать многоуровневые логические формулы. Вот пример описания логической формулы того, что если тунец является рыбой, это подразумевает, не насекомые и не птицы. В трехмерном представлении мы можем нарисовать граф и различными цветами подсветить различные типы отношений. Да, ну и подчеркиваю, что всё, что мы здесь видим в графической форме, всё это выражалось в выражениях таких на языке. Можно было всё то же самое выводить не на графический терминал в виде графов, а в виде консоли, работать с этим с консолью. И данные в этом тексте могли путешествовать между различными нодами. или различными вычислительными узлами в сети, таким образом, что тем, что пользователь редактирует на одной машине, могло отправляться пользователю на другой машине. Вот опять-таки различные представления графических формул для выражения уже на языке Cyc. Это вот из Cyc. Соответственно, вот так вот, точнее «cycle language» – это вот язык логических выражений «cycle», который говорит о том, что мама животного является животным женского рода. Вот тоже в двухмерном редакторе графическом и в трехмерном графическом редакторе мы можем визуализировать одну и ту же логическую формулу. В какой-то момент мы подумали, что, наверное, Вот такое редактирование графов – это не очень привлекательно для среднего пользователя в качестве эгофицированной платформы, и решили внести туда элемент развлекательный, дать пользователю возможность редактировать не только графы и вообще не обязательно графы, а редактировать вообще произвольные трехмерные миры, наполнять их различными графическими примитивами, сферами, поверхностями, объектами, графическими изображениями, гиперссылками, управлять освещенностью. С помощью этой системы мы описывали как архитектурные дизайны системы как себя самой, делали каталогизаторы сайтов в интернете, описывали антологические замкнутые или верхние антологии для различных предметных областей. графический интерфейс оплетного приложения соответственно можно было значит вот с левой стороны видна видна консоль вот ну а здесь одна картинка то есть можно было переключаться между различными представлениями то есть у нас была была концепция того что любое знание оно описывается некоторым пространством до некоторым большим графом где некоторые сегменты этого графа, они относятся к конкретным пользователям, но кроме того есть еще так называемые представления или view, которые могут выводиться на конкретный экран. То есть вот то, что мы сейчас видим на экране, это конкретно view, допустим, категории, экземпляры и свойства. Но если мы вот сюда нажмем, появится другое view, где могут быть совсем другие сущности и отношения. Таким образом, мы в разных view одного и того же мира, который называется Animals, можем просматривать один и тот же граф знаний в различных аспектах. И можем создавать новое view, можем в существующее view добавлять какие-то сущности из графа, можем их убирать из этого графа, но при этом общая картина мира, она остается одной и той же. Вот можно было опять-таки редактировать трехмерные объекты, при этом трехмерные миры, при этом, значит, эти миры, они, по сути, позволяли создавать некоторый 3D-нет, или гипер 3D-нет, или интер 3D-нет. Потому что на любую сущность, на любую связь, на любую картинку можно было повесить ссылку и ты мог не то ли не просто бродить по треумерному пространству, а жамкая на любую ссылку, по сути попадать в телепорт и перемещаться в другое view и вообще в другой мир на другом компьютере. Ну и в завершение, в какой-то момент появился заказчик, которому была нужна визуализация научных данных для геологии, геофизики, и на том же самом движке мы просто сделали визуализатор научных данных, но это уже не имеет отношения к теме сегодняшнего доклада. Вот так вот выглядела архитектура. нашего замечательного приложения. Соответственно, у нас было приложение типа Servlet, которое не имело графического интерфейса. Были приложения типа Applet, были приложения типа Server. То есть, десктопное приложение, они все между собой общались на основе вот этого текстового URL протокола поверх либо HTTP, либо TCP IP. Вот. У серверного агента у нас была, значит, и у серверного агента, и у десктопного агента, и у, соответственно, оплетного агента была как консоль URL на языке URL, так и трёхмерный редактор, который мог переключаться как в двухмерный, так и в трёхмерный режим. Ну и вот та схема данных, про которую я говорил, что у нас есть некоторый мир, это такой вот разделяемый между всеми пользователями гиперграф, где у одних пользователей есть одна часть этого гиперграфа, а у другого пользователя есть другая часть этого гиперграфа. То есть на самом деле весь, совершенно не обязательно, весь этот гиперграф он полностью разделен между пользователями. Каждый пользователь может иметь только свою какую-то его часть. Ну и опять-таки у каждого агента или у каждого пользователя есть набор своих собственных view. У этого агента вот своя часть графа, там есть view 1, view 2, view 3. У этого агента есть U4, U5, U6 в его сегменте этого графа. Агент B является некоторым пересечением. и частичное объединение между этими двумя агентами. Тем самым, с одной стороны, мы создали то, что сейчас можно было бы назвать семантически распределенный реестр, а с другой стороны, реестр, который мы делали, он был сделан как шардированный или не полностью, или частично реплицированный распределенный реестр, или распределенный реестр с частичной репликацией, который сейчас является целью некоторых компаний вроде TODA, у которых как раз фишка заключается в том, что они пытаются повысить транзакционную производительность системно распределенном реестре за счет того, что они не держат полный список всех транзакций на каждом узле, а они некоторым образом шардируют вычислительную нагрузку и нагрузку связанную с хранением цепочек транзакций между различными узлами вычислительной сети. Что в итоге мы выучили? Какие уроки были извлечены из этой истории? Первое – это то, что на самом деле двухмерные графические интерфейсы прикольны, но для практики они не всегда удобны. Не очень удобно с ними работать во многих случаях. А с трехмерными интерфейсами еще хуже. Они еще более прикольны для того, чтобы поиграться, но когда дело касается практики, это очень неудобно что-то делать в трехмерном пространстве. Гораздо проще реальные бизнес-задачи решать в табличной форме или в крайнем случае в деревьях. Ну и что касается распределённой обработки, то мы столкнулись с тем, что создавать эти данные новые в распределённой системе и шарить их в системе, это очень легко. А вот как только дело касается удаления и редактирования, связанного с удалением, вот здесь возникают проблемы, которые на сегодняшний день никакие системы даже на распределённом реестре решить не могут. Потому что, когда мы начинаем работать с необходимостью удаления или редактирования данных, которые расползаются по распределенной системе, максимум, что мы можем сделать на сегодняшний день, это две вещи. Первая. Мы можем очень жестко регламентировать создание новой информации, пока все валидаторы участвующие в консенсусе, значит, допросит меня Александр Балдачев, если я использую слово консенсус не совсем правильно, все валидаторы, которые участвуют в создании этого очередного кусочка данных, пока они не договорятся, этот кусочек данных не попадает в общую цепочку, а вот уж если он попал в эту цепочку, то для того, чтобы его изменить, нужно либо создать новую версию того же этого объекта данных который перекроет этот предыдущий кусочек данных либо либо создать кусочек который инкрементально изменит этот кусочек данных да то есть грубо говоря чтобы изменить состояние счета мы не можем изменить остаток мы должны создать транзакцию, которая изменит баланс с тем, чтобы этот баланс пересчитался. А если мы изменяем, допустим, данные в социальной сети на блокчейне, как это делается, к примеру, в хайве, в стимите или в голосе нашим русскоязычным, то там, если мы, грубо говоря, написали пост или комментарий, в социальной сети. Если мы хотим этот пост изменить, мы просто создаем отдельную транзакцию, где мы меняем конкретный кусочек этого поста, это записывается в цепочку и, соответственно, рендеритель всего этого дела должен проигрывать всю цепочку изменений, включая исходные посты, все инкрементальные изменения для того, чтобы получить тот контент, который нужно отобразить на экране или в мобильном приложении. И, соответственно, на основе тех уроков, которые здесь были выучены, возникло понимание, что нужно работать с системами на основе некоторого языка. Если не на основе графических примитивов, табличных форм и лидереев, то на основе некоторого языка. И в новом проекте, посвященном созданию персонального агента искусственного интеллекта для пользователей социальных сетей интернета, мы решили сделать новый язык, так сказать, URL+, более дружественный для человека. С одной стороны. С другой стороны, мы решили решить проблему удаления или редактирования данных за счет учета того, что называется социальный evidence. То есть идея заключалась в том, что мы не можем на самом деле в системе просто взять и удалить ничего. Все, что мы можем сделать, мы можем указать актуальность того или иного знания для различных участников системы. То есть, грубо говоря, по поводу любого события каждый участник системы вносит свой собственный вклад. А после чего, для того, чтобы понять актуальность этого кусочка, некоторый inference engine определяет, с учетом того, насколько каждый участник имеет вес репутационный, или вклад, или значимость в системе, inference engine принимает решение, является ли этот кусочек частью знания системы, основанной на этом наборе пользователей, или не является. Но это две отдельные темы, о которых, в принципе, дальше можно поговорить. Вот здесь я хочу сделать паузу. Может быть, прежде чем мы пойдем дальше, есть будут какие-то вопросы или желание какую-то дискуссию устроить? Алло. Так, что-то я очень плохо слышу. 

S01 [00:55:51]  : О, отлично. У меня, конечно, в конце задался вопрос самый главный. А где DSL был? Как бы DSL был здесь. 

S03 [00:55:58]  : Что предполагается под DSL, в моем понимании? Я понимаю следующее. То есть, с одной стороны, у нас есть некоторая базовая онтология или мета-мета-онтология, то, что называется foundation ontology здесь. в терминах, которые мета-DSL, то есть у нас есть некоторая онтология мета-DSL, и у нас есть некоторая орфография и пунктуация, может быть, грамматика, которая описывает то, как мы эти базовые сущности, класс и объект, сущности-отношения, вещь и свойства, соотносим между собой. И уже на основе вот этих базовых понятий и соответствующего синтексиса, пунктуации и грамматики мы создаем конкретные классы и атрибуты или вещи и свойства или сущности отношения для конкретной предметной области. То есть, грубо говоря, если мы возьмем мета DSL и опишем в нем драг, бренд и сабстанс, то мы получим доменную DSL для медицины. Если мы в рамках этой мета-онтологии в том же самом синтексе с епунктуацией опишем такие сущности, как, допустим, товар, продажа, покупатель, мы опишем DSL, допустим, для магазина. Понятно, да? 

S01 [00:57:54]  : Да, Антон Георгиевич, я про другое хотел спросить. Вот у вас почему-то начинается DSL с такой интересной точки о том, что давайте у нас мета-мета-модели у обоих пространств будут одинаковые. И вот мы будем различать их только разными синтезами, грамматикой, пунктуацией. У вас есть... Меня слышно нормально? Да-да. Вот у вас, значит, вы описали две прекрасные компании. Одна из них называет обупрофеном А, а другая обупрофеном, ну, что-то другое там называет, или свойства у нее другие. Но это классика. Вы говорите, у нас же DSL, он не к медицинской области DSL. Вот DSL — медицинская область. Нет, это DSL, который И да, она использует для описания медицинской области. То есть, там есть компания Pfizer, которая описывает медицинскую область другими объектами. И метамодель там другая. Соответственно, мы говорим в реальности жизни. Ну, давайте спустим на реальность, чтобы мы понимаем по TSL. У нас есть бизнес-пользователь, допустим, который говорит, у меня там есть какие-то бизнес-объекты, а мне нужно создать приложение. А ему говорят программисты на своем бизнес языке, в своем программистском языке. Какие у вас там нужны интерфейсы, классы, методы, еще что-то? А он говорит, минуточку, в моем языковом пространстве таких терминов вообще нет. У меня вот есть такие, такие, такие. Это вообще не из моей области. Нет, когда мы говорим, что у нас есть DSL, да, есть проброска о том, что есть вот у нас, можно описать на языке одном и пробросить туда, сконвертировать потом на язык у нас какой-то целевой, в который мы хотим, ну или связать два языка. Вот компания Медана или что там у нас там понимает, под контролируемыми исследованиями вот такое, значит, FDA понимает под контролируемыми исследованиями третье, а Pfizer под контролируемыми исследованиями понимает что-то четвертое. Давайте мы как-то сделаем вот общее. Да, вот они могут прийти, но изначально-то у них, вот когда мы говорим про DSL, Это у них разные языковые пространства, разные объекты. Почему вы так центируетесь на грамматике? Почему? Я вот хотел спросить. На синтаксисе пунктуации изначально о том, что у них объектные какие-то пространства, они одинаковые или мапятся друг на друга. Они могут вообще же не мапиться друг на друга никак. 

S03 [01:00:15]  : Давайте я попробую ответить. Смотрите. Во-первых, мы говорим, что у нас есть один домен. Домен у нас один. Медицина, допустим. На этом слайде. Но есть в рамках этого домена два разных диалекта. Две разных компании, которые в этом доме не работают. Окей, первое. Дальше. Мы хотим этим компаниям в многоагентной информационной системе как-то между собой договориться по поводу импорта и экспорта данных. Первое условие, которое должно выполняться. Вот они, грубо говоря, должны договориться. Мы вообще будем гонять друг другу tap-separated files или comma-separated files. Мы будем их там заворачивать в JSON или в XML. То есть, как бы структура синтаксическая и пунктационная, она должна быть одна. Вот этого на этом слайде нет. Это должно быть, иначе мы просто раскодировать информацию не сможем. Это первое. Второе. Очевидно, у нас в рамках нашей мета-доменной модели одни и те же понятия верхнего уровня должны обозначать одно и то же. То есть, если мы говорим think, Мы должны понимать, что think – это у нас самая верхняя базовая сущность, в терминах которой мы описываем все. Не должно быть такого, что у одной системы think и property, а у другой класс и атрибут, или entity и relation. То есть, если мы по-разному интерпретируем такие слова, как класс, интерфейс и атрибут, как у нас на самом деле происходит часто в нашем сообществе, то мы не договоримся. 

S01 [01:02:28]  : Об этом на самом деле и речь. Вы изначально говорите о том, что есть некоторая картина, которую мы можем признать за объективно истинной. Правильно я понимаю? Верхнеуровневая. Мало того, что она верхнеуровневая, она может включать все виды. Это же не вопрос. Я пытаюсь сейчас параллельно найти здесь господи картинку из тезиса про этот сейчас секунду прям найду скину про вот нашел замечательная картинка вот буквально обожаю сейчас ну вот прям у нас же зум чат есть тут же секунду вот Оно летит, летит, вот, долетело. Вот у нас в Zoom-чате. 

S01 [01:03:31]  : Вот, вот у нас, вот то, о чем вы говорите, ну, то есть, да, вы говорите, давайте, вот есть какие-то единая концептуализация, да, и давайте мы выберем один. И как будто бы у нас проблемы с двумя медицинскими компаниями о том, что они используют разные модельные языки. У нас есть концептуализация, есть модельный язык, есть спецификация, но это то, как у нас сам экземпляр выраженной модели на языке. То есть это модель, выраженная на конкретном языке. Это называется спецификация модели. Вот, и, соответственно, вы изначально подразумеваете, что у нас есть некоторая единая концептуализация, просто языки разные, там эти используют запятую, а эти называют ибупрофеном нурофен, я не знаю, а эти по-другому. И нам надо их притесать. Достойная задача, но она как бы в условиях, когда все уже говорят, ну, вы как правильно упомянули на примере нашего чата и также всех других чатов, и реально каких-то доменов сложных, там нет такого. То есть там есть такое, что мы понимаем под обупрофеном, и есть три-четыре разные точки зрения, а что под ним надо бы объективно понимать. Почему я сюда прилетел такой радостный? Потому что когда мы говорим про DSL, мы говорим, что есть некоторый доменно определенный язык, ну какой-то конкретный, но он конкретный, потому что его там кто-то использует, не потому что он истинный. Когда я захожу в чаты про онтологию, там очень любят, говорят про истинность. А вот когда в чатах про DSL, там говорят, что эти эксперты пользуются вот таким прагматичным языком. Если мы делаем для налоговиков, Какие-то приложения, чтобы они могли писать на каком-то DSL-е про налоговую. И они говорят, вот вы знаете, мы вот эту вот всю ситуацию называем вот так. Допустим, какие-то программисты скажут, да это просто какой-то семантический сахар, тут на самом деле это все две разные сущности. Они говорят, ну мы вот используем вот так. Ну хорошо, используйте, используйте. То есть если мы задаем, что есть просто какое-то пространство, вот я почему люблю Хуайна, вот он говорит, ну люди так говорят, но мы не задаемся вопросом, истинно оно или нет, мы говорим, что вот есть язык их, и нам надо причесать. Вот у нас есть язык заказчика, как я в начальном примере приводил, вот у нас язык заказчика, это его DSL, у него шаурма, у него там точки, у него то да сё, а есть язык программиста, которому делают приложение для управления его шаурмой, CRM. И вот он пытается поженить, что в его модели бизнес объектов будет являться. точкой, что будет являться сотрудником, а что будет являться менеджером. Он как-то бьет между собой эти концепции. Это сращивание на уровне двух концептуализаций, а не на уровне двух модельных языков. Поэтому задача сращивания концептуализации гораздо веселее и в реальной жизни, мне кажется, более интересная. И в прикладном смысле прагматически полезно, особенно в контексте ризнинга. И, кстати, я просто не с этой стороны к этому подхожу, но в этой теме, мне кажется, это вообще отдельно имеет большую важность о том, что DSL в первую очередь нам показывает о том, что мы сращиваем две концептуализации разные. Не то, что они изначально бьются в какое-то единое дерево, и мы все их причесываем, а вот о том, что Вот оно так. Но это вот так. Для затравки, почему мне, как говорится, про DSL? 

S03 [01:07:03]  : Я могу прокомментировать. Спасибо. Смотрите, в моём понимании, во-первых, мне кажется, про медану и бупрофен тут не совсем удачный пример. То есть, я как бы проблему понял, но мне кажется, медана и бупрофен не совсем удачно, потому что всё-таки, насколько я знаю, по крайней мере, из своего опыта с этими делами, Понятие «действующее вещество» и понятие «бренд» достаточно понятны всем врачам. И в этом смысле медан и эбупрофен – это не атрибуты, это значения. И если мы говорим, что у нас нечто, какой-то литерал или какая-то чиселка является в значении какого-то атрибута, то зная, что эта чиселка находится в значении такого-то атрибута, что мы знаем, что там медана. Мы знаем, что если это является действующим веществом, а в другой системе действующим веществом является что-то другое, то это очевидно разные вещи, потому что химические формулы, они вроде как во всех компаниях одни. Классификация болезни, она тоже вроде как сейчас общемировая. И, допустим, с действующими веществами, и с химическими, и с брендами, и с диагнозами вроде как проблем нет. Вопрос именно в атрибутном составе. Это с одной стороны. С другой стороны, например, с клиническими анализами, которые упоминал Алексей Незнанов, там проблема действительно есть, потому что там в разных системах лабораторных есть несколько систем онтологии, которые описывают эти названия. У них там и структура совершенно разная, и классификаторы совершенно разные. И там действительно возникает проблема перевода, как точки зрения самой структуры. Вот другой пример, который я студентам даю. Если вы возьмете, допустим, описание одних и тех же людей, например, Альберта Эйнштейна в Дибипедии, и в Wikidata, и вы увидите двух достаточно разных людей. Структура совершенно разная, атрибутный состав совершенно разный, и домены, доменное наполнение разное. И решить, допустим, задачу переноса информации в части Person из DBPedia и Wikidata можно только, по сути, некоторым машинным переводом. И мне кажется, как раз вот эта задача именно трансляции из одного диалекта в другой или из одного домена в другой – это задача, может быть, действительно практически не менее, а может быть, и более важная, чем то, что я рассказываю, но это задача именно, которая решается, мне кажется, с примерно теми же механизмами, как решаются задачи машинного перевода. И, по-моему, Александр Балдачев достаточно успешно решает задачи перевода не только из одного ДСЛ в другой, но и из человеческого языка в ДСЛ, и из ДСЛ в человеческий язык. Я бы так ответил. 

S01 [01:10:53]  : Я вот тут прокомментирую о том, что тут все действительно важно на примерах. Может быть, собопрофеном не самый красноречивый пример, но если мы посмотрим на вопрос о том, как мы преобразуем объекты из одного пространства концептуального в другое, То здесь мы фактически получаем модель преобразования. Вы говорите, давайте спарсим как машинное обучение, как машинный перевод. Мне кажется, это совсем ближе к резонингу. к машинному переводу. Почему? Потому что у меня будет модель преобразования из одного концептуального пространства в другое. Возьмите очень простой пример, как у нас есть модели преобразования написания, допустим, технической документации. Сколько у нас есть различных теорий про то, как у нас из бизнес-требований перейти к техническим. Сколько у нас есть системной инженерии. Это не то, что машинный перевод. Это тут целое пространство для дебатов и убийств. Поэтому это все порождает модели, модели преобразования. И здесь никакой не линейный маппинг. Это то же самое, это очень креативный такой процесс. И здесь мы видим его чаще, чем кажется. То есть кажется, как будто это просто какое-то заблуждение, люди там слишком далеко друг от друга были и не согласились. Это не вопрос вообще о терминах. Это вообще вопрос о прагматической ценности. Вот вы говорите, вот у нас сейчас уже все компании, допустим, пришли к выводу с медицинской точки зрения, пришли к какому-то общему соглашению о терминах, о концептуальном делении предметной области, но и что? Это только говорит о том, что они и к проблемам пришли одинаковыми и находятся в одинаковом тупике. То есть для того, чтобы им выйти из проблем своей доменной области, им нужно какой-то другой способ смотреть на нее. То есть должен появиться какой-то третий человек, который скажет, что давайте мы посмотрим на молекулы не в том виде, как они взаимодействуют с организмом, на какие там рецепторы они влияют, а мы как-то по-другому посмотрим, может быть, какая-то комплексная воздействие. Ну я не знаю, я на ходу придумываю. Просто он предложит другой модель взгляда на, допустим, механизм влияния химических веществ на организм. Ну вот мало ли, что у нас завтра придумают. У нас много в истории таких ситуаций, когда люди открыть. Мы можем открыть историю научных открытий. Я не помню, к сожалению, автора прекрасного, который рассказывает про научные революции, как они там случаются. Это тот же самый вопрос про то, что есть какие-то новые иные способы концептуализации, и когда мы начинаем их сращивать с нашей традиционной предметной областью, мы вдруг открываем что-то новое, понимаем, что там у нас появились новые объекты. То есть я про то, что эта задача не тривиальная, она не машинная абсолютно, но ее понимание даже на уровне, ну мы даже сейчас если машин не касаемся, просто я всегда привожу пример, давайте добьемся согласования между мужчиной и женщиной, нам все человечество скажет спасибо, а потом если мы между человеком и машиной, ну тоже спасибо, но если мы решим даже согласование между мужчиной и женщиной, это уже будет большой прогресс для вселенной. Вот я про то, что это вообще не в линейной плоскости. 

S03 [01:14:03]  : Три комментария. Насчет перевода из одной антологии с одной структурой или из одного DSL с одной структурой, как с точки зрения наполнения данных доменной структурой, так и самой мета-структурой. Эта задача, в общем, с одной стороны, совершенно понятная. То есть, если мы знаем Грубо говоря, доменное наполнение для определенных доменов. Мы можем выстроить таблицы соответствий. Если мы знаем, как одни структуры мета и мета-мета уровней отображаются друг на друга, то мы можем написать конвертер. И это вот ровно та задача, через которую я эту историю пришел в 1993 году. Собственно, из решения этой задачи вся эта история родилась. Для меня, по крайней мере. Это с одной стороны. И там действительно в чистом виде ризнинг, символьная индукция, может быть, даже не ризнинг, а просто в чистом виде софт инжиниринг. С одной стороны. С другой стороны, машинный перевод не один десяток лет пытались решить ровно таким же способом. То есть, человечество долго билось как с помощью символьных систем, грамматик, онтологии решить проблему машинного перевода. И как достаточно обоснованно заключают многие участники процесса, в том числе присутствующие здесь, что всё это потеряло какую-либо ценность, потому что сейчас это тот же самый машинный перевод. Но ура! Делаются нейросетевыми моделями и смысла возиться с антологиями и грамматиками нет. Поэтому тут еще можно порассуждать, как нам быстрее и проще делать перевод из одной доменной модели в другую. То ли нам попросить LLM LAMU2, LAMU3 или на худой конец ЧА-ГПТ перевести из одного медицинского классификатора в другой. Или нам накодить таблицу соответствия и ее все время поддерживать. Или нам делать систему символьной регрессии. Или символьной индукции. Мы возвращаемся к первому слайду. Да, мы можем любую задачу решить как с помощью нейросетевой модели, гипотетической, так и с помощью символьной или вероятностно-символьной модели, тоже гипотетической. Весь вопрос в том, что мы на сегодняшний день знаем практически, как получать нейросетевые модели методом тренировки на больших данных, но мы пока не научились создавать символьные модели, иначе как методам многолетнего человеческого труда по их кодированию. Ну и третий комментарий по поводу того, что вы сказали, посмотреть с неизвестной стороны, но я не знаю, как смотреть с неизвестной стороны, вот честно. Метаспой. Я не знаю, как формализовать решение проблемы неизвестным и неформализуемым способом. 

S01 [01:17:27]  : Ну, это Эдвард Де Боне. Мы возвращаемся туда. Как смотреть с неизвестной стороны? Я последний, можно? Скажу комментарий, и все. Не буду больше тратить ваше время. Про то, что вы сказали, я абсолютно согласен с тем, что вы говорите про, допустим, про машинный перевод. И здесь есть очень интересная вещь, которая мне кажется очень, в принципе, доказуема. Ну, то есть, просто главное найти на это чуть-чуть времени. Возьмем, если мы машинное зрение. Едет лидар, камера, они пытаются распознать знак на дороге, так? И мы о чем можем здесь говорить? Мы можем придумывать алгоритмы очень сложные, которые попытаются распознать, но в конце концов статистика и машинное обучение показывают нам, что мы справимся лучше. И здесь действительно нам все равно, как видит глаз, мы очень легко верифицируем, узнала она знак или нет. На самом деле, она может по-разному. Мы не знаем, как она выведет знак, ну, допустим, как она его реально воспринимает. Для нас важно, что у нас верификация происходит на другом уровне. То есть мы не просим ее точно так же, как мы почувствовать этот знак, ощутить или что-то. Мы просим ее выдать вывод на более высоком уровне. Она нам на более высоком уровне говорит «этот знак – поворот на право» или «этот знак – стоп». Мы говорим, да, ты угадала, нет, ты не угадала, учись дальше. И, соответственно, здесь эта практика очень хорошо работает. Здесь потому что все данные, которые необходимы для анализа, они у нее перед глазами. А вот тот вопрос, который я тут все из чата в чат кидаю про атомы и яблоко, заключается в том, что когда мы касаемся текста, ну действительно, писать алгоритмы, мы потерпели с этим фиаско. Почему? Ну потому что, наверное, мы не очень хорошо понимаем, как все-таки эта штука работает. Как сказал Хомский, если бы мы понимали, как работает язык, мы бы их делали. Его когда спросили, почему вы не верите в ложбаны и все такое. Он говорит, слушайте, если бы мы реально знали, как это работает, я бы тут с вами не сидел. И, соответственно, когда мы говорим о том, что якобы мы можем утверждать, что все причинно-следственные связи, которые необходимы для того, чтобы понять выражаемое, они уже изложены в текстовом языке, это уже очень спорное допущение. И там я привожу несколько примеров. Допустим, о том, что вкус яблока содержится в форме. Если мы представим, ну, то есть по большому счёту, это идёт. Декомпозировали мы до такого пространства, разложили, в котором уже как будто из четырехмерного в трехмерный, или из трехмерного в двухмерный. Там не сохранилась информация о высоте. Она просто утеряна. Но, тем не менее, по чертежу мы можем в голове восстановить представление о трехмерном предмете. Вы можете посмотреть на двухмерный чертеж или даже на эскиз и восстановить в голове свои представления о трехмерном предмете. Почему мы считаем, что с текстом не так же? То есть, если бесконечно анализировать текст, то невозможно прийти, допустим, к тому, чтобы понять сам механизм, как мы это делаем. Допустим, организации. Особенно вы это подчеркиваете, когда говорите, слушайте, про три проблемы с объектом. Он является класс, а Relation – это тоже объект. Вы вот эти все вещи говорите, слушайте, они все меняются. Три проблемы, которые вы в 95-м столкнулись, вы их подчеркнули. И вот здесь мы к этому же подходим, о том, что мы пытаемся уложить в термины, казалось бы, плоские, которые мы парсим из текста, о том, что они там могут проследиться или мы можем их увидеть. Но это не гарантированно. Если мы с вами можем по 3D-чертежу или ребенок по словам начинает со временем понимать, что вы хотели сказать, уловить, дешифровать, что вы хотите сказать, это не значит, что эта информация напрямую в тексте есть. Возможно, у него есть такой же опыт. Благодаря которому он уловил, что вы хотели сказать. И это ближе похоже на то, что мы испытываем в прикладной плоскости. Это скорее похоже, что если у человека нет опыта, он не поймет, что мы хотели сказать. Этого в языке он не понял, а потому что это не хранится в этом. То есть это только какая-то штука, которую вы должны уже дешифровать. И это вот бьется. Поэтому говорю, что когда Незнанов скидывает статью про анализ текстов, о том, что вот мы еще можем знать, как текст проанализировать. Вот если мы пытаемся выявить закономерности, которые находятся в той же плоскости, концептуальной пространстве, То это машинное обучение 100%. Но если нам нужно преодолеть это расстояние, мы его чисто теоретически не можем вытащить информацию, изучив все атомы на планете, мы все равно не поймем, что такое вкус, потому что он находится просто в другом пространстве. Мы можем бесконечно сейчас изучать. Но когда нам нужно будет выйти в измерение вкуса и запаха, мы никак оттуда как бы вот эти объекты и понятия вообще не выживем. Но, как говорится, по аналогии с животными, людьми и всем остальным, вспомнить об этом мы можем. Вот я о чем. 

S03 [01:23:02]  : Я полностью согласен. Я же даже больше скажу. Я даже про знак с вами не соглашусь. Потому что если некоторая нейросеть выучила, что, допустим, знак СТОП – это красный круг на вертикальной палке, а потом в какой-то момент перед нами окажется красный круг на горизонтальной растяжке, и мы на него проедем, то у нас будут проблемы. И ровно поэтому мы можем говорить о том, что в некоторых случаях нам нужна интерпретируемость и верифицируемость не на уровне исходных тех моделей, которые система выучила. То есть, прежде чем, грубо говоря, мы машину, натренированную на дорожных знаках, выпустим на дорогу, мы должны у нее спросить, а что такое знак «стоп», а что такое «пешеход», а что такое «собака», а что такое «помеха справа». И если она нам будет говорить пургу, то мы понимаем, что ее выпускать на дорогу нельзя. Потому что она живет в другом концептуальном пространстве, которое не соответствует той предметной области, в которой ей предстоит работать. Коллеги, еще есть какие-то вопросы и комментарии? 

S05 [01:24:33]  : Добрый день. Можно вопрос? Да, пожалуйста. А можете показать слайд там, где был Джон Доу? 

S03 [01:24:40]  : Сейчас, секундочку. Я буду пытаться выйти из того места, где оказался. Сейчас я попытаюсь. Это я был... Так, чтобы ничего не сломать. Сейчас видно мою презентацию? 

S05 [01:25:03]  : Видно, но чуть-чуть раньше. 

S03 [01:25:06]  : Сейчас пойдем искать John Doe. 

S05 [01:25:08]  : Да, вот он. Смотрите, вы сказали, что John Doe является также не инстансом, а еще и классом в каких-то случаях. Можете пояснить, пожалуйста? 

S03 [01:25:23]  : Я в данном случае привел некоторый условный пример. 

S05 [01:25:28]  : Просто не понял, когда именно это нужно на практике. По-моему, если Джон Дову – это один экземпляр, то его надо представлять одним экземпляром. А Доктор Мистер – это его могут быть трейды, например. А вы говорите, что… Короче, вопрос по поводу, когда инстанс — это одновременно и класс. По-моему, это делает запутанное все это. 

S03 [01:26:00]  : Как запутанное? По сути, мы создаем отдельную сущность с другим атрибутным составом. Давайте я приведу пример. У меня есть John Doe, который идентифицируется некоторым номером паспорта. 

S05 [01:26:12]  : Это один экземпляр. 

S03 [01:26:13]  : Да, или social security number. Это тот черт, который здесь в серединке находится. А теперь представьте, что мы делаем большую систему, типа Google Knowledge Graph или chat GPT, который управляет, допустим, поведением всего на свете. Словно говоря, где-то джундоу должен проходить по всем возможным сценариям, всех возможных информационных систем. Предположим, что человечество решило, что не писать прикладные системы, допустим, кастомные, а все делать внутри одной универсальной глобальной планетарной системы. И, допустим, в этой системе нам нужно делать от этого джундоу учетку в фитнес-центре. И там у него будет свой идентификатор. В другом месте нам нужно сделать учетку этого Джон Доу в, допустим, Сбербанке. В третьем ему нужно сделать учетку в Альфа-банке. Но это будет один и тот же drone.do с одним набором? 

S05 [01:27:14]  : Да, но я бы на первый взгляд сделал просто одну инстанцию, и у этой инстанции будет ссылка просто на ID в одном банке и ID в другом банке. 

S03 [01:27:29]  : Смотрите, с точки зрения… Давайте я поясню. Мы рисуем, предположим, что мы строим революционную базу данных, объектную модель. То есть у нас, грубо говоря, у этого Джон Доу, который в серединке, у него один атрибутный состав, в котором есть social security number, номер пенсионного фонда, Номер паспорта, есть дата рождения, фамилия, имя, отчество. Вот у этого Джон Доу справа, у него там есть аккаунт в Сбербанке и дата открытия счета. 

S05 [01:28:00]  : А почему нельзя в одну запись, в которой вы записываете все про Джона Доу? 

S03 [01:28:04]  : А зачем? 

S05 [01:28:05]  : А чтобы не разводить вот эту вот странную фичу, что джондо будет целым классом, непонятно... Ну вот потому что с прикладной точки зрения это оказывается удобно. 

S03 [01:28:15]  : Просто речь, что есть прикладные кейзы, где мне неудобно делать большие записи. То есть мне удобно делать отдельные записи. 

S05 [01:28:26]  : А какая проблема записывать другие поля, когда надо дополнительное поле записать? 

S03 [01:28:35]  : А это могут быть вообще разные базы данных, например. Или могут быть различные условия. Но здесь мы уже переходим к требованиям физической организации. Могут быть разные права доступа. То есть, мы не можем. У нас могут быть разные, допустим, индексы. То есть, при физической реализации системы у нас возникают конкретные прикладные кейсы, которые требуют именно такой структуризации. Я вот про что говорю. Естественно, мы можем сделать все большое и плоское, но это будет вычислительно и практически, с точки зрения разработки, неэффективно. 

S05 [01:29:17]  : Ну, неэффективно. Я так сразу не понимаю, почему эффективно. А вы еще заносите информацию, чтобы вы знали, что это один Джон Доу? То есть, что Джон Доу в фитнес-центре – это тот же Джон Доу, у которого есть забитый периметр? 

S03 [01:29:31]  : А это вот как раз эти стрелочки и есть. То есть, мы говорим, что это из кайнд-офф один и тот же самый. То есть, это Джон Доу, это Джон Доу, а это из кайнд-офф один и тот же Джон Доу. 

S05 [01:29:42]  : А вы тогда можете сделать экземпляр класса человека в фитнес-центре, и там будет Джон Дову, который будет с ссылкой. Опять-таки не будет эта фича, что object may be a class. Вот этого не будет в том, что я сейчас говорил. 

S03 [01:29:57]  : А какая проблема? То есть у них отношение, то есть у них по сути, то есть если мы хотим делать логический вывод, у нас просто есть один тип отношения, что есть отношение из kind of, И мы на отношении скайндов можем делать логический вывод над любыми объектами, которые имеют отношение к скайндов? 

S05 [01:30:20]  : Да нет. Это просто некая революция. В общем, я потом скажу. В общем, я не считаю, что объект должен быть классом. 

S03 [01:30:26]  : Это можно... Мы можем... Ладно, я пока... Нет, на самом деле... Нет, смотрите, вы правильно рассуждаете. То есть, вы можете сказать, что... 

S05 [01:30:34]  : Ну, смотрите, если у вас есть, ладно, отдельная датабаза про всех фитнес-центры, то просто заносите человек в фитнес-центр, и это будет класс, и его инстанция будет John Doe фитнес-центр, и там будет ссылка на John Doe. Но это не будет то, что тут написано PUM2 Object Maybe Class. Нет-нет-нет. Будет отдельная инстанция John Doe фитнес-центра и ссылка на отдельную инстанцию John Doe, и объект не будет классом. Это страшно запутывает антологию, по моему мнению, насколько я там начинал ее делать. 

S03 [01:31:05]  : Но в этом случае у вас смысл вот этих двух ссылок, это будет ссылка, которая иметь будет специфический тип, но суть этой ссылки, эта ссылка будет происходить от ссылки из kind of. Потому что смысл этой ссылки будет из kind of, но только специфически. 

S05 [01:31:28]  : Подождите, подождите, как вы по-русски поточнее назовете из kind of? 

S03 [01:31:35]  : Extension. Ну как, производный или там экземпляр. Подкласс? Наследник. 

S05 [01:31:43]  : Нет, вы только что сказали разные типы. Подкласс и экземпляр это разные вещи. а IsCountOf это вообще я не видел. Если у вас Extension, то это подкласс, то есть это класс понятий, который берет понятия родительских классов и их как-то наследует. Есть инстанция, правда, инстанцию тоже можно рассматривать как подкласс, но это запутывает, это смазывает точность определений в антологии, и подкласс — это просто один экземпляр какого-то класса. Вот что такое IsCountOf? Вы это называете, но что именно имеете ввиду? 

S03 [01:32:20]  : SkyDove – это extension. А можно вмешаюсь? 

S04 [01:32:24]  : Ваш диалог – отличный пример к тому, о чем говорил Ким. Как раз когда вы в двух разных концептуальных плоскостях говорите как бы об одном, но на самом деле о разном. 

S03 [01:32:35]  : Совершенно верно. Это вот как раз мы находимся в двух разных мета-мета-антологиях, где даже на уровне базовых понятий мы используем... Да, просто я бы тогда не считал, что доктор Джанду — это подкласс Джанду. 

S05 [01:32:46]  : Это отдельные инстанции, между которым какая-то реляция, но эта реляция не подкласс. Эта реляция — это ссылка на то, что это один и тот же человек. Ну ладно. Так, интереснее мне. Перейдете там, где у вас была антология бизнес-процессов? Можно еще вас спросить? 

S03 [01:33:02]  : Так, это вот куда? 

S05 [01:33:04]  : Вот это вот? Нет, дальше там, где была антология бизнес-процентов. Раньше она была, по-моему. Вот, вот это. Объясните, то есть где-то можно вообще почитать, из чего она состояла? Мне интересно посмотреть. 

S03 [01:33:28]  : Я давайте давал ссылочку, сейчас я найду эту ссылочку. Так. Так. Так. Сейчас. Так, documentation. так documentation вот так где-то это английская где-то по-русски была но здесь вот есть вот короче так и сейчас в общий чат кину так как вы его найти а вот он здесь вот соответственно и есть русская русская страничка так опс 

S05 [01:34:13]  : Спасибо. 

S03 [01:34:18]  : Так, коллеги, еще вопросы? 

S05 [01:34:21]  : Вопрос, что вы могли с этим делать, с бизнес-онтологией? 

S03 [01:34:26]  : Вы ее уже задали, допустим. Мы могли делать следующее. Там интересный достаточно кейс получился, потому что, с одной стороны, У нас была группа разработки, где мы вначале разработали вот эту концепцию, а потом стали ваять эту систему. Но пока мы ваяли эту систему, мы ее ваяли медленно и печально. Её нужно было наполнять данными. По мере того, как мы делали систему, которая всё это будет исполнять, нужно было формировать классы, описывать бизнес-процессы, описывать бизнес-правила, экранные формы. И было принято решение, что если мы зафиксируем спецификацию языка, то аналитики сядут и начнут это все описывать на уровне текстов. А мы будем на основе этих текстов делать ту систему, которую эти тексты потом будут исполнять. В какой-то момент возникла ситуация, что мы начали всю эту систему запускать. Тексты были написаны. Естественно, не все пошло гладко. Вот где-то пришлось чинить систему, где-то пришлось править тексты, но в итоге это все соединилось и заработало вот примерно так, как это показано на скриншоте. 

S05 [01:35:58]  : Вопрос был опять-таки в том, вот вы, это просто задача модели, что вы дальше делали с этой моделью? Какой набор функций вы делали на нем? 

S03 [01:36:10]  : Описание и реализация тех функций, которые написаны в бизнес-требованиях. Открытие счетов, закрытие счетов, открытие ордеров, закрытие ордеров, поиск. То есть, любой бизнес-процесс, который вы можете описать в терминах любого языка программирования, любых объектов или любых атрибутов, вы можете описать. Конкретно этот кейс мы описывали в BackOffice российской торговой системы, его функционал. Но можно было описать все, что угодно. 

S05 [01:36:51]  : Вы могли, например, в этой системе что-то рассчитывать, я не знаю? Что? Что-то рассчитывать для бизнеса. 

S03 [01:36:59]  : Конечно. Ну так вот, по сути, с правой стороны, вот здесь вот в окошке, у нас, по сути, язык программирования. Только программировать можно было либо в дереве, либо в тексте, но в конечном итоге все это хранилось в графовом представлении, и исполнение шло в результате интерпретации графовой модели. которая хранилась в базе данных, а не в виде интерпретации инструкций процессорных, которые были скомпилированы из некоторого кода на некотором языке программирования. Вот это все имело текстовое описание, все могло бы быть описано в виде текста, но эти тексты загружались в конечном итоге в графовое представление, и в графовом представлении исполнялись. 

S05 [01:37:45]  : То есть вы могли, например, автоматизировать принятие бизнес-решений? 

S03 [01:37:48]  : Да, конечно. Все, что можно написать любым языком программирования, можно было бы автоматизировать. То есть это полноценный язык программирования. 

S05 [01:37:59]  : Слушайте, это дальше использовалось как-то? Или что было в конечном итоге? 

S03 [01:38:05]  : Вот конкретно это не использовалось. А почему? 

S05 [01:38:10]  : Вы говорите такая крутая вещь, что можно... Секундочку, давайте я отвечу. 

S03 [01:38:15]  : Конкретно этот проект был закрыт на уровне прототипа, потому что у заказчика кончились деньги на этот проект. Но есть как минимум два подобных проекта. Как минимум три. Здесь есть Александр Балдачёв, у которого, насколько я понимаю, есть подобная система. И сейчас она проходит испытание. Александр, может быть, вы возьмёте слово, расскажете про свою систему. Здесь присутствует Евгений Евгеньевич Витяев, у которого коллеги разработали систему DSL-0. Вот, или Delta 0, где тоже есть исполняемый движок, где вот то же самое можно решить, то есть описать любые бизнес-процессы, любые доменные онтологии в терминах этого языка и исполнять их на уровне бизнес-правил и бизнес-процессов. Есть еще аналогичная система в Иркутске. Евгений Евгеньевич тоже может подскажете, как она называется под руководством Монсиводы. 

S02 [01:39:16]  : Басистом. Она называется басистом. Как? Басистом. Она называется басистом. Басистом. То есть, это документное программирование получается. 

S03 [01:39:28]  : Сейчас, давайте я тоже ссылочку кину. 

S04 [01:39:31]  : Так, ну я могу сказать, что буквально мы, недавно работал в компании, где мы на проекте федеральном использовали аналогичный подход для построения цифрового медицинского профиля пациента. А для Минздрава цифровые двойники процессов. И это, ну с точки зрения инструментальной части дизайнера модели у нас был он послабее, но подход именно аналогичный. И это отлично работает. 

S03 [01:40:01]  : Так, вот я кинул ссылочку на свой телеграм. Кто-то спрашивал. И вот ссылка на Delta 0 SL. Это наша новосибирская разработка. Так, коллеги, еще есть вопросы? Я думаю, мы с докладом дальше не пойдем. Я потом сделаю опрос, имеет ли смысл и интерес продолжить с того места, где мы остановились. Давайте сейчас закончим с вопросами и комментариями. Александр, вы, Балдачев, вы не хотите прокомментировать и про свою систему сказать пару слов? Александр, вас не слышно. 

S00 [01:40:40]  : Да. Добрый день. Да, пару слов я скажу. То есть я затянулся своим докладом и собирался его еще в конце лета. Ну там всякие накладки получились, там программисты менялись, болели. Вот сейчас выпускаем бету уже и тогда, как она выйдет, я все сделаю доклад, покажу, расскажу. По докладу Антона могу сказать, что я так периодически себе делал пометки. Да, у нас это решено, у нас это решено, у нас это решено. То есть и проблема вложенных свойств, когда на одном свойстве можно фиксировать другое свойство, а на том еще следующее свойство. Это как в базовой версии прямо вот исходно решается. И проблема, которую сейчас обсуждали с возможностью применения сущностей экоклассов или инстансов экоклассов, она тоже решена использованием различных моделей. То есть, когда у нас есть один, то есть, по сути, инстанс или индивид нас – это идентификатор, просто идентификатор. И по разным моделям он наполняется разными свойствами. Этот идентификатор может работать и в модели медицинской, и в спортивной, и в отделе кадров, и в семейной. Один и тот же идентификатор, но, как Антон говорил, разные view. Так и разные модели, по ним и отражаются, и создаются различные, даже не сказать, что это различные представления. Как мы о человеке знаем? Один человек знает другого человека по работе, это его представление. А другой знает по игре в футбол, как по вечерам играет. Все равно это один и тот же человек, только просто по разным моделям он воспринимается и строится. И еще какой-то тоже был момент, который сказал, что у нас... А, у нас, поскольку движок однозначно сразу же вписан и пертуперсеть, То есть эта перседа уже работает, и решена проблема с редактированием, она решена кардинально, никакого редактирования нет, данные только добавляются. Поскольку направлен циклический граф, только добавляются, невозможно удалить. Если нужно удалить, то нужно просто приписать вложенным свойством события удаления на данные их события, которые дальше не будут учитываться в запросах. И параллельно решена проблема архивирования веток графа, чтобы не перегружать хранилища узла. Ну и тоже Антон упоминал то, что хранят данные не как в блокчейне. Каждый узел хранит не все данные, а только те данные, которыми он работает. То есть он работает по некоторым моделям, в некотором кластере, в некотором топике, то он то эти данные и хранит. То есть нет необходимости хранить и валидировать данные вне конкретного бизнес-процесса. Если не хватает узлов для валидации и хранения, то можно добавить дополнительные специальные узлы, ресурсные, которые специально нацелены на то, чтобы только хранить, только валидировать, только участвовать в консенсусе. То есть бета-версия будет где-то в ближайшие недели, может, максимум месяц, а будет открыто тестирование, еще не сетевое тестирование, а локальное. Каждый сможет загрузить и посмотреть, как это все работает. Ну, сетевая версия тоже работает, то есть можно, я делал демонстрации создания прямо в сети приложения и работы, то участники, которые участвовали в конференции, сразу работали в сети, голосовали, там голосовалка создавалась, мессенджер. Опыты работы с LLM продолжаются. LLM строит модели довольно успешно, но контролировать нужно, но гораздо сокращает время. Создание полноценной работы простенького приложения может потребоваться час-два. 

S03 [01:44:42]  : Да, спасибо, Александр. Будем ждать вашего доклада. Евгений Евгеньевич, вижу вашу руку, сейчас отвечу только. Давайте я сейчас быстренько пробегусь по вопросам. В конце здесь есть вопрос. Если это было сделано в 1999 году, почему до сих пор не сделан инструмент такой же, как ГПТ на онтологиях? Удивляюсь. Перевожу этот вопрос. Если вы такие умные, то почему вы такие бедные? На этот вопрос ответил очень ёмко Питер Вост, в моём понимании. Питер Вост – это широко известный в узких кругах человек. Наряду с Беном Гёрцелем, Пейвангом и Шейнлегом он в 2001 году или в 2002 придумал сам термин AGI. Он один из его авторов. Он на одной конференции позапрошлому году сказал, что трансформеры и глубокое обучение высасывают весь кислород и воздух, и все деньги из инвесторов. развивать никакие альтернативные подходы не получается. Вот такая точка зрения. Поскольку никто не дает нашей конкретной разработке столько денег, как их дают известным компаниям на трансформеры, поэтому не получается. Как могу, так отвечаю. Евгений Евгеньевич, пожалуйста. 

S02 [01:46:05]  : Да, вот у меня такой простой вопрос. Вот если вот эта вот система, его граф-веб-представление, оно по функциональности эквивалента DSL0, которая применяется в центре искусственного интеллекта для конкретных программ, почему вы об этом там же не рассказывали? Потому что получается, что два возможных способа решения задачи, и неизвестно, какой более эффективный. Тем более, что граф-веб-представление нужно глядно, кроме всего. 

S03 [01:46:32]  : Ну, Евгений Евгеньевич, я не рассказывал, потому что не звали. Я же на самом деле вот то, что я сегодня рассказывал, я же на нашем семинаре, который у нас там был лет семь назад, с Дмитрием Ивановичем рассказывал. 

S02 [01:46:46]  : Есть мой доклад, соответственно, если будет интерес… Я думаю, что в настоящее время имеет совершенно прямой смысл это рассказать заново, потому что именно в этом году будет пытаться вестись конкретная практическая работа, где графовые представления могут оказаться более эффективными. 

S03 [01:47:06]  : Ну, давайте тогда… Это с кем нужно разговаривать, с Дмитрием Ивановичем или с Александром Николаевичем? Нечосов? А, ну давайте тогда я сейчас тебе запишу, что Нечосов, доклад. Так, Нечосов. 

S02 [01:47:22]  : Когда они начнутся, потому что финансирование еще не открыто. 

S03 [01:47:26]  : Хорошо, давайте тогда мы с Нечосовым к этому вопросу вернемся, а вы тогда с своей стороны тоже при случае Нечосову подскажите, что... Да-да-да, хорошо, я ему обязательно скажу. Да, хорошо. Так, спасибо, коллеги, еще вопросы. А в Академгородок, да, это хорошая идея. 

S05 [01:47:47]  : А про решатель тогда уже в следующий раз будет. Что-что? Что-что? Про решатели. 

S03 [01:47:53]  : Да, я думаю, мы уже два часа сидим, поэтому презентацию я выложил. Дальнейший план доклада там есть. Соответственно, если интерес будет, мы найдем время и продолжим этот разговор. Я думаю, в феврале получится. Давайте я сейчас быстренько пробегусь еще по вопросам, какие остались. Так, про Джундоя мы проговорили. Relation entity это стандартно. Ну да, сейчас это стандартно. Так, имплементация модель бизнес-процессов. Какая именно интерпретация была модель бизнес-процессов? Смотрите. По бизнес-процессу. Идея была примерно следующая. С бизнес-процессами. Еще раз, может быть, повторю. Предположим, что мы бизнес-процесс описываем следующим образом. что есть описание класса, который является не просто классом, а является класс исполняемого объекта, то бишь процесса, атрибутами которого являются, во-первых, входные параметры, во-вторых, выходные параметры и, в-третьих, локальные переменные. То есть мы просто описываем это в нашей, так сказать, онтологии. И у него есть набор исполняемых операторов. где операторы тоже описаны в нашей онтологии, и у этих императоров есть принадлежность к этому классу. То есть, чем отличается этот класс-метод от простого класса? Что у него кроме атрибутов, есть специализация атрибутов не на публичные, а на входные, выходные и локальные. Переменные, по сути, атрибуты – это, по сути, переменные метода или функции. А функция, на самом деле, это метод, у которого просто нет класса. Метод – это функция, которая исполняется в контексте некоторого класса, а функция или процедура – это такая функция, процедура, у которой нет никакого контекста, кроме глобального, имея пространство. 

S05 [01:50:11]  : Можно уточнить? Да. То есть, вы могли, например, интерпретировать антологию, что написано в тело исполняемого метода? 

S03 [01:50:21]  : Нет, у нас был набор отношений и вершин, которые, по сути, позволяли создавать исполняемые операторы. То есть, была вершина типа переменная. было отношение типа операторы, оператор сложения, вычитания, умножения, которые связывали между собой операнды. Что такое абстракт Syntax-3? То есть, у нас любой компилятор, на самом деле, в результате компиляции исходного кода на некотором языке программиров порождает, на самом деле, некоторую структуру. Это абстрактное синтактическое дерево, которое потом дальше идет либо на кодогенерацию для целевого процессора, либо на интерпретацию той или иной виртуальной машиной. То есть, на самом деле, абстрактное синтактическое дерево – это некоторая структура данных. И мы эту структуру данных просто отображаем на граф. Соответственно, в нашей онтологии описание исполняемого метода – это имя класса метода, это ссылка на некоторый класс, которому этот метод применим. Это набор переменных, входных, выходных и локальных. Если это метод класса, то это еще и отдельная переменная, которая называется Viz, то есть это ссылка на объект, в контексте которого происходит вывод метода. И это цепочка инструкций, дерево на самом деле, которое описывает код этого метода. А теперь внимание. У нас могут быть методы одноразовые, которые выполняются, допустим, в одерноле. Он проинтерпретировался. Так и завершился, да? Это, так сказать, одномоментные, мгновенные транзакционные методы. А есть методы долгоживущие, да? Когда у некоторого метода есть некоторое состояние. То есть, мы, допустим, запустили некоторый бизнес-процесс, допустим, исполнение некоторого договора. Вот, наверное, сейчас Александр Балдачев, я надеюсь, сделает пометку, что это тоже сделано. Вот. И он создался, грубо говоря, на стыке, но он дошел до какой-то инструкции, допустим, проведения оплаты. И мы ждем подтверждения этой оплаты, потому что мы оплату отправили в пятницу, а банк уже закрылся, потому что мы ее провели в пятницу вечером, и подтверждение платежа придет только в понедельник. И у нас исполнение этого метода со всеми его локальными переменами, оно где-то на некотором стеке виртуальном застряло, и субботу-воскресенье он лежит в базе данных. А в понедельник у нас приходит извещение из банка, срабатывает триггер, и этот метод продолжает свое исполнение. Я ответил на вопрос, идем дальше. Игра убийцы GTA V. Про GTA V не знаю. В свое время, когда появился Minecraft, мы поняли, что мы плохо продавали. Вот, значит, «Моя онтология круче». Да-да-да. Вот, собственно, «Моя онтология круче», «Нет, моя круче». Скриншот из игры. Вот, на самом деле, если вдруг у кого-то есть идея, как эту тему поднять на щит, про мерение онтологии, вот давайте обсудим. Это вообще тема. Недавно же, по-моему, на днях обсуждали, как бы это что-то игрофицировать. Да, вот правильный скриншот. 

S01 [01:54:00]  : Есть в приложении, если у кого есть идея. Вы знакомы с кодо.io? Каким? Кода.io. Нет, я тода.io знаю, а кода нет. Откиньте ссылку. Ссылка на коду? Ну, хорошо. Есть такое приложение Кода.io и... из него интереснее всего кода io-gallery. И вместо того, чтобы провоцировать, как говорится, холивары и срачи, которые неконструктивны, когда люди пытаются доказать, на самом деле они пошли по-другому. Они сказали о том, что если человек прагматически использует что-то, значит это работает и значит нужно Как говорится, чтобы он рассказал, почему его видение концептуализации, она крутая. И что предлагает Coda? Coda вообще конструктор просто бизнес-приложений. Но в Coda Gallery это появилась такая интересная штука, что люди там делятся на самом деле своим подходом с одной стороны. То есть они в этих простых бизнес-приложениях, по факту, они излагают свое видение, допустим, подходом к управлению процессами или к приоритизации. И там очень много интересных вещей, допустим, как из обычной жизни, из бизнес-применения, из маркетинга. Видно очень много разных концептуальных пространств, и видно, как они их используют в процессах. То есть изучать чужие вот эти доки, они у них называются, в Code Gallery, это как бы интерактивные, там сразу некоторые, ну то есть там видно структуру объектов, которые они используют, и видно, как они их принимают, и даже они текстом дописывают, значит, как они ведут, как они ее в реальном бизнесе или в реальной жизни применяют. Типа трекер для бега, для достижения привычек, еще для чего-то. Это было что-то похожее у Notion, возможно, как Notion-овые штуки. Но в коде у нее возможностей побольше, это такой Notion-астероид. И в Coder Gallery у нее есть, допустим, и от известных людей, там очень много интересных документов. таких практик, которые мы, допустим, даже на законодательном уровне в процессе внедряли. Я имею в виду в процессе, нормотворческий процесс, не в законодательном, как закон, а как процесс внутрь нормотворческого процесса. Поэтому очень крутая штука. И вот она как раз показывает о том, что если людям дать удобный инструмент изложения и делиться своей предметной областью, как правильно сказал Я, к сожалению, не знаю, как вас зовут, вы подписаны Креуди Бунг. Я скажу Креуди Бунг. Вот, как сказал, а какой смысл от вашей антологии? Вы выпустили эту антологию, и чего, на неё смотреть, что ли? Молодцы, сделали каталог. 

S05 [01:56:52]  : Я так не говорил, какой смысл. 

S01 [01:56:55]  : Если вы спросили, какое применение потом у этого все может быть? 

S05 [01:56:59]  : Мы спросили, какое применение, да. Если это успешный инструмент, то почему он как бы завис и не применяется? 

S01 [01:57:05]  : Не только вы, да. Многие спрашивают, антологии зачем? Ну сделали вы структуру-структуру, да, и что с ней дальше делать? И вот, соответственно, кода, она как раз дала этот интересный такой кейс, который, может быть, сейчас не напрямую буквально надо использовать, но просто их опыт, насколько хорошо у них user-generated content на этом счете сработал. Люди делились им, потому что его можно сразу же применить. То есть он тебе дает не только структуру, но и автоматически сгенерированные интерфейсы, чтобы ты мог в своей, допустим, компании переименовать Допустим, был каталог книг, а ты сказал, ой, я могу каталогизировать машины, и ты можешь всю структуру вместе с интерфейсами, моделью объектов, делением, типом, перетащить, что-то переименовать и потом также зарелизить, и кто-то другой может, грубо говоря, форкнуть и сделать. И вот если посмотреть историю, я просто сам был одновременно амбассадором в коду сообщества и в чате официальном состою. Всех в кода Russia приглашаю, приходите, она еще жива. И, соответственно, для меня самый большой... Я на студентах, кстати, это пробовал в Нижегородской области. Они у меня делали документы. Допустим, у меня был кейс, они делали книжный клуб. Сейчас я, правда, до сих пор не знаю, зачем они ходят в этот книжный клуб. Это когда они читают вместе, сидя в одном месте. Это очень странное занятие, но ладно. Книжный клуб у меня был в НГТУ, Нижегородский государственный технический университет Алексеева. Медиаклуб, они где снимали, как они фото, видео синхронизируют, производственный процесс, и они для этого делали кода доки, структуру процесса. Это там очень весело обследовать. Когда вы говорите геймификация, если дать удобный инструмент, и потом они могут в этом сразу жить, Они это используют, они это создают, то есть это первокурсники. И с RSM у нас было много проектов с Российским Союзом Молодежи, тоже, соответственно, в Рязанской области. Если кто есть из Рязани, привет. То есть там тоже есть много кейсов, интересно, как они это принимали. Так что вот это как раз реальный кейс, у кого сработала геймификация. 

S04 [01:59:07]  : Ну, для этого есть название «Цифровые сады». Концепция, по-моему, в 2015 году была предложена. Она прямо есть в статье, есть по поводу много статей. То есть вот кода — это как раз реализация самых цифровых садов. Я в чате кинул название статьи. 

S03 [01:59:26]  : Окей, так, давайте дойдем дальше. Вопрос, не лучше ли по логическим выражениям, не лучше ли задавать через диджойнт, а не через логическое выражение. Ну, я не понимаю, что подразумевается под диджойнт. На самом деле, то, что там написано, это так называемые предикаты верхнего уровня или higher order logic predicate, которые так используются много где они есть и у дуга и нато они в сайкле были и если хотите есть еще время то можете открыть этот предикат будет вопрос моя концепция была бы это так покажу сейчас секундочку давайте я зашарю так я обратно обратно вернусь на sharing так так где у нас так где у нас это было так так куда сюда или вот например это да что там написано так вот это вот 

S05 [02:00:32]  : Вот это вот, да? Жесть. Например, if tuna is a fish, это не bird, ну вот это вот. Это просто элементарно disjoint. То есть от animal под классы disjoint fish, insect и bird. И тогда вы знаете, что fish это не insect и не bird, и тогда вам не нужно задавать это правило, можно задать это просто... описанием объектов, структуре объектов. Вот об этом я говорил. А теперь давайте более сложный пример. Что тут вообще написано? В чем смысл этого? 

S03 [02:01:07]  : Что здесь написано? Здесь это написано в терминах языка OpenCoke Atomis, до которого мы не дошли. Здесь написано следующее. Смотрим на скобочки. Есть, во-первых, то, что называется отношение импликации. implication link. Я знаю, что значит на семантическом уровне. 

S05 [02:01:30]  : Я спрашиваю про прагматические уровни, что тут написано. 

S03 [02:01:34]  : А вот написано, что mother of an animal is a female animal. Что мама животного – это животное женского пола. 

S05 [02:01:46]  : Зачем это записывать правилам? Это записывается опять же свойствами класса, я бы какими-то написал. 

S01 [02:01:52]  : Это может быть для верификации? 

S05 [02:01:55]  : Не надо, записали свойства класса и читают, и резонер читает свойства класса и верифицирует это. А вот это уродливое правило не надо помещать в систему, которую вы делаете. 

S03 [02:02:07]  : Это constraint. 

S05 [02:02:10]  : Ну ладно. 

S03 [02:02:13]  : Это из какой-то истории. 

S01 [02:02:14]  : Чтобы никто не записал, что папа может быть мамой. 

S05 [02:02:20]  : Что я знаю, в чем фича была СИЗ, это в том, что они там писали сотни тысяч каких-то правил. Вот я смотрю на это и понимаю, что правила в этом виде описывать в систему не нужно. А это будет само содержаться, что значит Mother of an animal is... Во-первых, нет... Во-первых, нет матери, которая не животная, допустим так, и тогда это описывается просто, например, классом Mother, трейдом, который будет в Animal, и описывается просто свойствами класса, а не вот этим вот правилом формальной логики. Не нужно это применять в этом случае. Ну, по моему скромному мнению. Ладно, разобрались. 

S03 [02:03:00]  : Это как бы вопрос практического применения, да. 

S04 [02:03:04]  : Это вопрос практического применения. В реализации конкретной одной системы не нужно. А если мы хотим сделать, условно говоря, правила, которые используются в 10 разных системах, то нужно. 

S05 [02:03:18]  : Не совсем понял. 

S04 [02:03:19]  : Ну т.е. интерпретация этого правила в разных системах может быть реализована по-разному, совершенно по-разному. Но само правило, оно где должно быть, чтобы было что интерпретировать. 

S01 [02:03:31]  : Да, и потом вот как раз жалко Денис Никифоров не пришел, он бы рассказал про таможенный союз и про то, как там товары, когда переезжают со стороны в страну, как-то надо сто правил на разном законодательстве переделывать. 

S04 [02:03:46]  : У них не только таможенный союз, просто даже здравоохранение на федеральном уровне. Совершенно разные домены. Даже кардиология в Питере и кардиология в Москве – это разные домены. 

S05 [02:04:00]  : Ну, это так сделали просто. Надо один домен делать. 

S04 [02:04:03]  : Ну, как это так сложилось? 

S01 [02:04:05]  : Это жизнь, да. Это дураки. 

S05 [02:04:09]  : Это мне напоминает этот проект, в котором я раньше некоторое время работал. Там был конвертер из одной базы данных в другую. И работа заключалась делать в этом конвертер, который был бы не нужен, если бы у всех баз данных был изначально один и тот же формат. 

S03 [02:04:24]  : Это боль. Так вот, говорю, у нас только в России три системы, по крайней мере, я не знаю, как сейчас, но вот сколько-то лет назад было три разных системы кодирования медицинских препаратов. И, соответственно, в разных аптечных сетях были, кто-то там повидали, а кто-то еще какая-то система есть. В общем, разная система, разные онкологии, разные атрибутирования с точки зрения действующих веществ, брендов и всего остального. А с лабораторными анализами та же самая история. Алексей как раз упоминал, SNOMED и какой-то еще, вот я тоже забыл, я этой темой давно не занимался. Совершенно разная система классификации лабораторных изменений. Грубо говоря, мочу измеренную в одной системе невозможно просто так конвертировать в другую систему. Нужно программу писать для того, чтобы анализ мочи из одной системы в другую перевести. Перевод с помощью машинного обучения на уровне онтологии и структурированных данных. Так, коллеги, еще на этом слайде есть вопросы или дальше? 

S05 [02:05:37]  : Тут есть, а что еще дальше было? 

S03 [02:05:41]  : значит давайте что там у нас дальше еще было сейчас уже пора закругляться но так так так так так так про визуальное было Сейчас давайте я выйду из screen sharing, чтобы увидеть список вопросов. Пусть автор подписывает знания, только он сможет изменять и удалять. Собственно, это концепция блокчейна. То есть, грубо говоря, как устроены пресловутые соцсети на блокчейне или транзакции. Если я сформировал транзакцию, Только я ее могу подписать и никто ее не может изменить. Возьмет ли система мою транзакцию или нет, это другой вопрос. Если система не возьмет мою транзакцию, то я оставлюсь, грубо говоря, своим. соглашаюсь с тем, что моя транзакция не принята, либо я делаю форк и создаю свой собственный форк этого блокчейна с моей любимой транзакцией, которой никто не пользуется на свете, кроме меня или, может быть, моих друзей. С социальными сетями на блокчейне тоже самая ситуация. Если я опубликовал пост и Я его подписал, никто его изменить не может. Я могу только сделать корректировку к этому посту, новые транзакции, где будут поверхмоизменения. Если кому-то мой пост не интересен, опять-таки, он может его не рассматривать, он может его не читать, он может его, если у нас система вот про то, как Александр говорит, Балдачев, если, грубо говоря, каждый нод хранит только те транзакции, которые ему нужны, кто-то может моих записей не увидеть. То же самое с семантическим. То есть, если мы семантические знания в виде отношений храним в транзакционной базе данных, если мы хотим делать какой-то инференс на основе их, резонер какой-то запускать, про который мы, очевидно, в следующий раз поговорим, то у нас один резонер может работать на одной базе данных, используя те, так сказать, отношения или связи, из тех источников, которым этот резонер доверяет, или то ядро, на котором этот резонер запущен, доверяет. А резонер, запущенный на другой системе, может использовать другие транзакции. Ну, представим себе, что у нас есть Блокчейн с семантическими отношениями и фактами, которые кудавали, условно говоря, и демократы, и консерваторы. На этой базе Ризенер консерваторов работает только на транзакциях, которым он доверяет от консервативных источников. Демократический резонер использует только транзакции, которые подписаны участниками демократической сетки. А третий резонер, он такой плюралистический, он берет и демократические, и республиканские транзакции и пытается построить какую-то общую картину мира. Вот, как мне кажется, куда все должно идти. Но главное, чтобы транзакции были в одном формате. Так, юморно, да, со слоном все правильно. Так, почему естественный язык имеет неточную природу, так, так, так, так, значит нейросеть в любой момент может соврать. Интерпретируемость, ПДД, так, ну, вроде как. 

S05 [02:08:56]  : Это было по поводу перевода. Потому что естественный язык трудно переводить, потому что в нём нечёткая перевода. А DSL можно, в принципе, алгоритмически переводить, потому что значения в DSL они точные. 

S03 [02:09:09]  : Если мы одинаково договорились о том, что мы подразумеваем под ISA и ISKINDOF. 

S05 [02:09:15]  : Ну да, мы же договорились в ходе разговора. 

S03 [02:09:19]  : Если договорились, то всё ок. Если договорились, то всё ок. коллеги ну вроде как все так да спасибо больше вопрос повестку исчерпали да хорошо я тогда закину опрос на предмет продолжения вот всем большое спасибо за участие мне кажется интересно поговорили интересно обсудили и тогда до новых встреч всем спасибо до свидания. спасибо, очень интересно. 

S04 [02:09:57]  : до свидания. 






https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

## 27 февраля 2025 - boldsea - событийно-ориентированное семантическое моделирование - Александр Болдачев — Семинар AGI - аудио
[![Watch the video](https://img.youtube.com/vi/DqcrKcbV7ec/hqdefault.jpg)](https://www.youtube.com/watch?v=DqcrKcbV7ec)
- [расшифровка]()
- [видео в RUTUBE](https://rutube.ru/video/2bbd62123abbbbd1e8afb6dd5e6bea22/)
- [видео в ВК](https://vkvideo.ru/video-210968399_456239214)
- Архитектура на основе событийной семантики - https://www.osp.ru/os/2021/03/13055996
- Событийная онтология vs объектная - https://habr.com/ru/articles/706916/
- Как я учил ChatGPT - https://habr.com/ru/articles/715492/
- Акты, классы и семантический сахар - https://habr.com/ru/articles/708026/
- Семантика и деятельность - https://habr.com/ru/articles/503406/
- Деятельность, документы и семантика - https://habr.com/ru/articles/509990/
- https://www.youtube.com/watch?v=gazUrDmjAOw&ab_channel=siberai
- https://www.youtube.com/live/FQQ7umzDXhI
- https://www.youtube.com/live/fhU2nJVlgRw
- Дополнительные материалы в Телеграм-группе https://t.me/boldsea

_ВНИМАНИЕ: СЛЕДУЮЩИЙ ТЕКСТ СГЕНЕРИРОВАН ИИ, РАЗРАБОТАННЫМ УЧАСТНИКАМИ НАШЕГО СООБЩЕСТВА!_

**Суммаризация семинара:**

Александр Болдачев представил систему событийной семантики - функциональный Workflow-движок "Bolt C", основанный на событийном подходе. Вот ключевые аспекты презентации:

## Основные принципы системы
1. **Событийный подход**: Всё в системе записывается в едином событийном формате. События являются основой всех действий и процессов.
2. **Семантический подход**: Все концепты, свойства, атрибуты и отношения берутся из словарей, обеспечивая единую семантику.
3. **Модельный подход**: Ничего нельзя добавить в граф без модели, в отличие от традиционных семантических систем.
4. **DataFlow-архитектура**: Исполнение бизнес-логики происходит асинхронно - каждый узел срабатывает, когда поступают нужные аргументы.
5. **No-code решение**: Отсутствует компиляция бизнес-логики в код.

## Особенности архитектуры
- Система является одновременно редактором онтологии и Workflow-движком
- Создаёт динамическую модель деятельности, а не статичный граф
- Обеспечивает темпоральное хранилище данных с возможностью отката к предыдущим состояниям
- Использует направленный циклический граф для отслеживания всех изменений

## Концептуальная модель
Александр подчеркнул важное отличие от других онтологических подходов:
- В системе нет иерархии классов/подклассов
- Есть только концепты и их индивиды (экземпляры)
- Классификация вынесена за пределы онтологии

## Демонстрация
Александр показал пример создания и работы с приложением:
1. Создание моделей и реестров
2. Определение ролей и прав доступа
3. Формирование оферов и процесса их утверждения
4. Демонстрация бизнес-процесса с несколькими участниками

## Интеграция с ИИ
В конце Александр продемонстрировал возможности интеграции с большими языковыми моделями (LLM):
- LLM может анализировать грамматику языка и создавать модели на его основе
- Система может использовать LLM для построения моделей по текстовым описаниям
- Возможность семантического парсинга документов на основе созданных моделей

## Преимущества системы
- Децентрализованные приложения благодаря DataFlow архитектуре
- Безопасность дополнения моделей (новая функциональность не ломает старую)
- Масштабируемость через сегментирование графа
- Возможность работать в P2P сети с консенсусом

Александр также объявил о предстоящем открытии тестирования системы для всех заинтересованных участников.

**Расшифровка семинара:**

S00 [00:00:00]  : Да, коллеги, еще раз всем добрый вечер. И сегодня у нас в гостях Александр Болдачев. Расскажет нам про свою систему событийной семантики. Александр, пожалуйста. 

S01 [00:00:11]  : Добрый день. Несколько лет назад я делал доклад по событийной семантике, в основном состоящей из теоретических рассуждений. Только немного показал на то время работающий движок. Ожидалось, что движок будет готов в каком-то виде через год, через два, но через три более-менее подошли. И вот сейчас, что вы видите на экране, это как бы входная страница движка, который запущен у меня в браузере. Технология называется Bolt C. Такое название выбрали. И эта технология сейчас находится на патентовании в офисе патентом OSIP из США. И, значит, сегодня я хочу практически все время потратить на демонстрации, может быть чуть-чуть и каких-то технических подробностей, не вдаваясь совершенно в событийную семантику философскую, событийную логику, то, что я раньше рассказывал. И еще я с Антоном посоветовался и предложил такое решение, что я буду ему рассказывать, и Антон будет мне отвечать по мере прямо показа. То есть я буду обращаться, чтобы спросить понятно, непонятно. И вопросы можно задавать прямо по ходу, но только не всем, а только Антону. Если хотите что-то спросить, то пишите в чат, и Антон транслирует вопрос, и мы тут же его разберем. Чтобы это не была такая занудная длинная история с кликанием мышкой и с показом каких-то картинок. Если что-то непонятно, мы останавливаемся и разбираем. Буду пользоваться я самим движком, на нем буду показывать, и несколько еще окон у меня открыто. Есть полное описание работы движка для аналитиков, которые работают на движке. Здесь, может быть, какие-то моменты будут показаны, связанные с запросами, что нужно более-менее пояснить. Есть какая-то маленькая презентация, совершенно небольшая презентация с несколькими картинками просто для некоторой основы. И есть ваза знаний, в которой зафиксированы какие-то приложения, описание приложений, разбор их, которым я буду пользоваться во время демонстрации и брать некоторые, скажем, элементы, те же запросы, чтобы не набирать их руками. Понятно, что это все не так быстро было бы демонстрироваться, если я запросы набирал бы руками. Маленький предварительный рассказ. Вообще, что это перед нами? Во-первых, это функциональный Workflow-движок. Движок, на котором проигрывается бизнес-логика, на котором можно проиграть, взять вот эту схемку. И не впрямую ее взять, а просто как бы эту бизнес-логику переложить и проиграть. Что еще нужно знать об этом движке? Он основан на субъективной семантике, на субъективном подходе, event source, event driving. В отличие от других каких-то подходов событийных, в которых события только частично что-то регулируют, являются какими-то управляющими элементами, в данном подходе все, что не записывается, все, что не проигрывается, все, что не существует как-то. Оно записывается в едином событийном формате. И сейчас я уберу эту картинку, которая была сильно увеличена для того, чтобы снять слайд. Значит, если мы посмотрим, то есть вот перед нами событийный граф, событийное хранилище. в котором хранится и бизнес-логика, и хранятся предметные события, модельные события. И сейчас, на данный момент, перед нами генезис-часть этого графа, который состоит из 28 на 10, 280 событий. И все, что не записано в этом хранилище, оно представлено в виде событий, в котором есть некий свой идентификатор, есть события, на котором фиксируется другое событие, есть тип события и значения. Также прописана модель, по которой созданы события. Темпоральная связь с предыдущим каким-то событием, об этом поговорим. И актор. Ну вот видно, что в основе, в самом генезис, в самом корне лежит просто событие, ивент, ивент, ивент. И из него разворачиваются, записываются... Это не иерархия. То есть нет типичная антология высокого уровня, где выстраивается иерархия. Это просто последовательность событий, которые каждый из последующих ссылается на предыдущие и приносит какое-то содержание. Видим, что есть какие-то Типы данных здесь записаны, роли, домены, ограничивающие свойства пошли. Вводится, значит, опять типы данных. Ну вот таким образом у нас 280 событий, в которых записана необходимая информация для того, чтобы запустить любую бизнес-логику. Это вот такой фундамент, на котором здесь видно, что вот уже есть какие-то введены системные акторы, системные роли. Так, это я про событий не сказал. Теперь, значит, второй момент, это семантика. Самая настоящая какая-нибудь семантика. И, наверное, основным признаком семантики является то, что все данные берутся из словарей. То есть все концепты, свойства, атрибуты, отношения, акты, роли, все прописано в словарях. И каждое событие... Так, что-то мне подвисло. А, нет, все правильно. Вот. 

S00 [00:06:55]  : И каждое событие, значит, строится из... Александр, извините, пока подвисло, значит, я тут пытался задать вопрос, просто на минуте был. Тут два вопроса сразу возникло связанных. Первое, значит, вопрос от Олега Иванова. Как строится сам граф? Автоматически и вручную? И второй вопрос. Вы сказали, что все берется из словарей. Поясните, пожалуйста, откуда оно может браться, кроме как из словарей? 

S01 [00:07:29]  : Нет, значит на первый вопрос отвечать не буду, потому что как бы в начале демонстрации, на первых минутах демонстрации спрашивать, а что вы будете демонстрировать. Вот этот вопрос как бы уместить будет в конце, если будет непонятно. Мы сейчас будем строить граф. То есть мы строить будем граф, а вопрос, опять же, что автоматический, что не автоматический, мы тоже к этому вернемся в конце, уже обсуждая агишные дела. Сейчас, на данном этапе, я не рассматриваю связь с искусственным интеллектом, связь с агиб событий на семантике, а только рассказываю про вордлоу-движок. А про словари, ну понятно, что когда программист пишет несемантический движок, несемантическую программу, несемантическое какое-то приложение, он все выдумывает из головы. он выдумывает из головы все переменные поименования колонок в таблицах, и несемантическая технология ограничена рамками самой конкретной системы, которая проектируется, и для связи с другими системами нужен какой-то API, какое-то согласование, какой-то маппинг имен, пространства имен, И это не семантик. Семантический, значит, подразумевает, что есть единое пространство имен, есть единые словари, которые используются все, кто работает в данной семантике. И плюс еще, наверное, что семантический, то есть сама запись, сама запись, вот конкретная единица записи, она полностью как бы семантически определена. То есть если мы берем, скажем, рассматриваем здесь запись, то есть есть какое-то app, то есть какое-то приложение, есть какой-то словарь, есть словарь как type value и есть название этого словаря, который подключен к этому приложению. То есть сама семантика читается в самом записи. Ну, как в РДФе, то есть мы берем тройку РДФа и смотрим на нее, имея по словарям и понимаем, что в ней написано. То, что передается в несемантических системах, мы не можем сказать, это просто фантазия самого программиста, который может передавать как угодно, что угодно. Ну, скажем, в блокчейне то, что загружается в блок, оно об этом знает только сам программист, который писал смарт-контракт. Мы говорим, что есть семантика, и это однозначно семантическая, потому что я несколько раз сталкивался с людьми, я понимаю, и это не касается, конечно, нашего сообщества. Люди не понимают, что такое семантика, и чем семантика отличается от несемантических приложений, и смотрят, а где же здесь семантика. Но здесь семантика как бы самая-самая настоящая. Ну, сейчас еще вернемся к этому. 

S00 [00:10:28]  : Александр, можно все-таки еще раз уточнить, да, то есть раз уж мы хотим быть, чтобы все было понятно, потому что мне как раз сразу стало непонятно, когда вы упомянули словари, вот, потому что мне было непривычно слышать слово слова в соответствии с семантикой по ряду причин, то есть все-таки просьба разъяснить. Я правильно понимаю, что словари описывают имена, с помощью которых вы идентифицируете сущности в вашем семантическом графе. То есть, словарь – это список имен для вершин семантического графа, правильно? 

S01 [00:11:07]  : Я показывал генодиз граф, там есть примитивы, семантические примитивы, которые не находятся в словаре, они заложены в саму базу. В дальнейшем каждое приложение, каждая модель, она должна брать свои семантические примитивы, то есть это концепты, атрибуты, отношения, акт, ограничивающие свойства, должно брать из словарей. 

S00 [00:11:39]  : И еще один вопрос, на самом деле он мне кажется важным, но, может быть, потом ответите, если сочтете целесообразным. У вас для каждого типа или класса сущности свой словарь имен или словарь имен общий? Ну, грубо говоря, может ли быть такое, что есть сущность или группа вершин типа человек и сущность или группа вершин типа страна, И там может быть Вася, и там может быть Вася. Может быть человек по имени Вася, и может быть страна по имени Вася. Или вот если он Вася, то он глобальный. 

S01 [00:12:16]  : Значит, во-первых, Вася – это значение предметного события. Это не концепт, поэтому немножко некорректный сам пример. Но, значит, смотрите, подразумевается, что если в данной системе, вот на данном движке, в данной семантике работает корпорация или некая публичная сеть, то подразумевается, что все пользуются одними словарями. Если кто-то сделает свои словари, он на них будет работать локально, не имея возможности обмениваться данными, свободно обмениваться данными при наличии доступа с другими приложениями, с другими узлами, с другими кластерами или с другими предприятиями. Поэтому задача стоит, как и в Open Data или как в Semantic Web, создание единых словарей, которые практически уже есть, их нужно использовать. Ту же схему ORC или дублинское ядро, то есть в какой-то степени нужно бы их интегрировать в словари, существующие. Значит, и теперь на второй вопрос. Это мы еще, наверное, посмотрим, что словарь это всего лишь поименованный список. И если, скажем, у меня есть некая наим, то он с одним идентификатором может существовать в разных словарях. То есть именно в словарь он входит как в список по идентификатору, но в системе наим существует только один. То есть задача стоит к унификации всех взаимоотношений, и каждый примитив, каждое свойство, каждый концепт должны присутствовать в системе в единственном экземпляре с единственным идентификатором. Вопрос сибнониев – это отдельный вопрос, как нужно вычислять, как с ними бороться, как переходить на единые словари. Но в идеальном случае в словарях могут быть одинаковые свойства, но с одинаковым идентификатором. И в системе у нас есть, можно сказать, можно поместить, взять новый словарь и сказать, взять из этого словаря, взять из этого словаря. И словари, прежде всего, они привязаны к приложениям. То есть одно из приложений работает с неким набором словарей. Обычно это тематические словари, которые касаются данной предметной области или сферы внутри данной предметной области. И есть общие словари, которые применимы везде. То есть там comment, description, name. То есть общие словари, которые можно подгрузить и с их помощью делать приложение. Значит, это мы с семантикой закончили. 

S00 [00:15:00]  : Александр, извините, я все-таки хочу получить полную ясность. Смотрите, вот есть приложения, которые работают, допустим, с тремя словарями. Может ли в этих двух словарях быть в разных, в одном словаре и в другом словаре разные сущности или entry points, но с одним и тем же значением атрибута name? 

S01 [00:15:31]  : Нет, в словаре может быть только name. В словарях нет никаких связей. Словарь – это список. И в разных словарях может быть name. 

S00 [00:15:44]  : Один и тот же name. То есть может быть Вася в одном, может быть Вася в другом. Не Вася, name. 

S01 [00:15:48]  : Вася – это индивид, это значение индивида. 

S00 [00:15:53]  : А, словари – это у вас словари, у вас имеются в виду словари свойств. 

S01 [00:15:58]  : В словари сводят, значит, что идентифицируется, с помощью чего создается антология. Это концепты, свойства, акты. Скорее всего, в большинстве случаев, в большинстве роли, в большинстве случаев это словари свойств. А не словари индивидов. Тип словаря заключается в том, что в нем не хранятся имена людей или там идентификаторы машин. То есть документ номер 1.24. Зачем его в словаре хранить, если это наш индивид, которому даже совершать некие действия? А вот что у словаря есть? Title, description, там продавец, покупатель. Это все словари. Это мы сейчас увидим, поэтому мы немножко сейчас опережаем, потому что лучше... Я, наверное, зря стал немножко теорией, но теорию хочется очень минимально все-таки дать. 

S00 [00:17:01]  : Смотрите, значит... Хорошо, Александр, да, сейчас пойдем дальше, просто вы сами сказали останавливать. Давайте последний еще вопрос, а потом, значит, если вы скажете, мы будем проскакивать и ехать дальше. Вопрос следующий от Алексея Незнанова. Чем семантический словарь отличается от тезауруса? Полным отсутствием семантических связей? 

S01 [00:17:27]  : Вот это вопрос, конечно, очень интересный. Я задумывался над этим, но я бы сказал так. Безотносительно событий и какой-то семантики, они отличаются местным применением. То есть если мы в некой семантической системе используем набор каких-то свойств, неких поминованных сущностей, то это будет семантический словарь. Если мы используем его где-то в классификации документов, это будет тезаурус. То есть один и тот же набор свойств каких-то, то есть он в зависимости от применения может называться либо тезаурусом, либо словарем. Но это дело, опять же, вкуса. Никто, скажет, если сейчас переименую все свои словари в тезаурусы, ничего не изменится. Давайте дальше идем. Третий принцип, на котором построена система и который принципиально отличает от существующих семантических систем, это модель базовый подход. То есть если мы берем РДФ и граф какой-то и помещаем туда какие-то еще триплеты, и нам никто не запретит поместить туда какие угодно. И кто угодно может поместить. Это было как базовым принципом в Semantic Web. Каждый на своей странице делает семантическую разметку и добавляет все это в единый граф. То я пошел другим путем, что ничего принципиально невозможно добавить в граф без модели. То есть каждое событие, каждое свойство, какое-то значение или примитив подается только по модели. То есть модельный подход. И это касается именно самой семантики. И это очень важно, потому что поможет нам решить некоторые проблемы, о которых мы в конце будем говорить, возвращаясь к искусственному интеллекту. Следующий пункт – это дата флоу-архитектура. Значит, это касается именно исполнения алгоритмов, это касается исполнения самой бизнес-логики. В движке применена Dataflow-архитектура, ее событийная интерпретация, то есть Event Dataflow-архитектура. Вот сейчас вопрос, Антон, прямо сейчас поясните, что такое DataFlow, чтобы всем было понятно. 

S00 [00:19:56]  : Поясните. 

S01 [00:19:58]  : Хорошо. Значит, смотрите. Тогда я перейду на картинки. Значит, смотрите. Если кто помнит, то на заре компьютерной истории У нас было два типа компьютера. То есть была архитектура фон Неймана, это контрол-флор-архитектура, которая делает компьютинг, вычисление или выполнение какого-то алгоритма по шагам через. И в Зенке следующий шаг. И вот выполнение вот пошагового алгоритма, вот эта архитектура фон Неймана победила. А вторая архитектура, которую называют дата-флоу, она где-то маргинально существует, какие-то контроллеры есть, пытаются делать какие-то компьютеры, но она не получила широкого распространения. Может быть, сейчас только есть какие-то в интернете вещи и контроллеры над дата-флоу-архитектурой. В чем принцип дата-флоу-архитектуры? Есть некий граф, некая дерево, в узлах которого располагаются выражения, которые нужно рассчитать. Скажем, у нас нужно рассчитать x плюс y умножить на z. Конечные выражения разбиваются на подвыражения элементарные, скажем, на x плюс y, и есть входные какие-то данные, куда поступает x, y, z. И архитектура асинкронная. Каждый узел срабатывает, когда поступают аргументы. Поступил x – молчи, поступил y – сработало, закинул, токен передал вот этот узел. Получилось 8, когда передал 3, плюс 8. И ждем, когда z, как только z появило значение, срабатывает этот узел и выдает ответ 16. Эта DataFlow архитектура имеет преимущество перед ControlFlow тем, что она исходно распараллельна, то есть мы можем параллельно вычислять огромное количество каких-то выражений на потоке данных и потом в конце получить результат, когда появятся все значения, но каждый узел будет рассчитываться отдельно. Что у нас позволяет делать, как мы это применим в событийной архитектуре? У нас есть какой-то набор событий, которые поступают извне, и каждое событие, вот событие 4, в нем прописано, что оно сработает тогда, когда поступит событие 1 и событие 2. А событие пятое, оно сработает тогда, когда события четвертое и третье тоже через n появятся. Вот в квадратных скобках здесь некое логическое выражение, condition, которое определяет, когда сработает это событие. модельное событие, когда сгорит предметное событие. То есть в архитектуре выполнения бизнес-логики нет шлюзов, вентилей, которые перенаправляют бизнес-процесс по одной или по другой линии. Есть только набор событий, которые ждут события, которые являются обуславливающими. Обычно я поясняю на примере бизнес-логики. Есть у нас издательство, сидит Вася, который должен начать свертать буклет. И он не должен знать, куда этот буклет пойдет после. Он должен только знать, что Маша ему должна передать текст, что Гриша ему должен передать картинки, что из типографии ему должен прийти формат для верстки, а директор издательства должен дать отмашку. Начинаем. То есть у него события начала верстки, у него есть condition, состоящий из четырех and, и когда все эти события придут, он начнет верстать. И когда он закончит верстать, он тоже нажмет кнопку «Я закончил», и всё. А это значит, что кто-то, где-то, другие события, та же типография, нет, скорее всего, корректор сначала. Корректор, у него стоит в кондишене условие, что как только, значит, Вася нажмет End, закончит верстку, значит, корректор может приступать к работе, выявлять ошибки в этом макете. Вот что такое Dataflow архитектура. И если в самом движке смотреть, то реализуется это через подписку у нас на события. То есть некоторые события у него есть condition. Если оно не может выполниться, то эти события, которые он ждет, записываются в подписку. И когда приходит новое событие предметное, проверяется, какое из событий на подписке выполняется. Если выполнилось, то выполняется это событие. Либо разрешается доступ актору, либо автоматически выполняется. Это мы сейчас посмотрим. Лучше всего понять, что такое дата-флоу в архитектуре, это вспомнить электронные таблицы Excel. Excel работает именно на дата-флоу в архитектуре, то есть вы пишете формулу в какую-то ячейку, и когда меняется значение этой формулы хоть где-то, в связанных таблицах пересчитывается значение вот в этой ячейке. То же самое происходит и в Dataflow-архитектуре событийной. То есть если где-то поменялось событие, которое является условием других событий, по цепочке меняется все. Даже был такой у меня пруф-концепт, мне дали задание смоделировать работу акселевской таблицы. Ну вот как, кстати говоря, и прокрутилась картинка. То, что я сейчас рассказывал, что есть некоторое модельное событие, у которого в кондиционере прописаны обуславливающие события, и при совпадении, то есть при получении истинности этого кондишена, генерится новое новое событие предметное, которое записывается в виде листочек драфа. Вот это как реализуется. И что мы имеем? Плюс еще ноу-кода решения. Ноу-кода ничего такого интересного для нас нет, кроме одного, что в отличие от традиционных ноу-кода решений, в движке нет никакой компиляции в код. То есть кода как такового нет в принципе. То есть есть код движка самого, который обрабатывает каждое событие, но перевода бизнес-логики в код и исполнения этого кода нет. Это тоже принципиально такая разница. Хотя, конечно, ноу-коды можно было написать в лоу-коды, потому что есть код запросов. но это через некоторое время, переведем запросы все-таки в более приемлемый синтаксис, и тогда там вообще не останется никакого кода. Значит, вот мы имеем движок, который одновременно является и редактором онтологии, это редактор онтологии. То есть ничто другого, кроме как редактора онтологии, в нем нет. То есть ты просто создаешь онтологию предметной области. Но создавая онтологию предметной области в виде модели, в виде исполняемых моделей, они же исполняются этим движком, и мы имеем в одном флаконе вортовой движок и редактор онтологии. И в качестве хранилища, что мы имеем ввиду? Событийная антология что нам дает? Это динамическую модель деятельности, именно динамическую. То есть мы не пишем статичный граф, у нас направленный циклический граф, который отслеживает все изменения предметной области и не только их фиксирует, но и исполняет бизнес-логику на этом графе. Мы тут же имеем темпоральное хранилище данных. То есть обычное темпоральное хранилище данных, в котором отслеживается вся история, и при желании можно откатить на какой-то этап, не на момент времени, а на этап какого-то события, и посмотреть состояние системы на это событие, на момент исполнения этого события. И поскольку темпоральное хранилище у нас семантическое, то мы имеем, по сути, граф знаний. То есть мы можем сделать запрос к любым индивидам, получить их свойства, проследить все отношения с индивидом. Но это вот сейчас посмотрим. Так, вот то, что я хотел сказать. И может быть еще картинку, чтобы не возвращаться. Это архитектура вишка. Это вот архитектура движка, больше в ней ничего нет, кроме вот то, что здесь обозначено. То есть берется модельное событие из графа, строится контроллер интерфейсов, строит по нему интерфейс. То есть конкретное поле по типу, там будет список, значит, будет выпадающий список, будет, значит, дата, будет поле даты, будет отношения, будет выпадающий список индивидов отношений, которые нужно получить. И, значит, пользователь вводит какие-то значения, если он действительно должен ввести здесь дату, не всегда, нажимает кнопку ОК. Валидатор. проверяет именно само значение, насколько оно допустимо по типу данных, еще каким-то, то есть не по семантике, а просто по формату проверяется. Если все в порядке, то записывается предметное событие, которое уже валидируется движком по модели, что все значения, все ограничения, все условия выполнены, Вот, и системный контроллер делает системные события. Если нужно, скажем, если, скажем, пришло какое-то событие извне, то по нему можно сгенерить еще несколько других событий, и это делает, ну, фиксирует, это системный контроллер. Ну, и подписка. И исполнительный контроллер, который по подписке меняет состояние формы на экране, то есть оно делается либо доступно, либо недоступно в зависимости от выполнения condition. Ну и предметное событие записывается в граф. То есть вот вся архитектура, сам движок претерпел за долгие годы различные изменения, то есть первая версия была на PHP написана, мной на коленке еле работала и на MySQL, потом была версия на Sharp, потом Сейчас текущая версия на тайскрипте, и, скорее всего, в ближайшее время будет еще, наверное, на Rust, потому что там удобнее. Потому что сам режим минимальный, и его для переписывания не требуется больших усилий, то есть он где-то до мегабайта размер. 

S00 [00:31:35]  : Так, хорошо. Александр, а можно сразу тут вопрос еще раз? Так, сейчас. Скажите, как быть в случае, когда часть материалов пришла из одной книги, а часть от другой? Как разделяются разные данные от разных ситуаций? 

S01 [00:31:52]  : Давайте в конце, это в конце. Хорошо. Да, то есть эта тема мы затронем в конце. Итак, эта версия движка, она загружена сейчас у меня в браузер, работает в браузере с хранилищем браузера, и граф, индексированная версия графа доходится в памяти. Значит, движок может быть запущен на сервере. и работать на сервере с любой базой данных, какую там можно будет подключить. Вот. И есть, значит, уже сеть, peer-to-peer сеть. Вот, по сути, я сейчас, работая в браузере, являюсь узлом сети. Ну, сейчас я к сети не подключился, чтобы там все-таки сеть, она какую-то задержку небольшую на консенсус, на обмен данными дает. Вот. Сам узел написан тоже, это lib, peer-to-peer библиотека, она есть в джаваскрипте, мы ее дописали, переписали, и вот на джаваскрипте тоже, на тайпскрипте, узел, который обеспечивает связь с другими узлами. Значит, потом, может, вкратце я еще несколько слов скажу про сеть, про как это все работает, какие преимущества дает перед другими сетями. 

S00 [00:33:24]  : Александр, тогда сразу, так сказать, или да потом отложите, или сейчас. Если у вас peer-to-peer сеть и у каждого своя версия базы данных, я правильно понимаю, что это распределенный реестр? И если да, то как вы распространяете изменения от узла к узлу по какому протоколу? 

S01 [00:33:44]  : Ну, если это peer-to-peer сеть, то естественно, что она должна обеспечивать синхронизацию данных на узлах. Но в отличие, скажем, от блокчейна, в отличие от блокчейна, семантика позволяет нам делать естественную пластеризацию. Тогда я все-таки переключусь. Еще одна есть запись. 

S00 [00:34:09]  : Пока вы переключаетесь, я поясню. Просто у меня подобный проект был с 1997 года, и как раз фишка была именно в том, что есть семантическая сеть, есть кластеризация на узлах, а дальше была следующая типичная проблема. Я завел узлы А и Б, и эти узлы А и Б пришли к вам. После чего я решаю, что между узлами А и Б будет связь АБ, допустим, типа Х, триплет ХАБ. И я эту связь отправляю к вам. А потом, когда я вдруг решаю, что эта связь не нужна, возникает вопрос, а как я вам информацию донесу о том, что она не нужна? Из этой истории возникает очень много. 

S01 [00:34:57]  : Смотрите, peer-to-peer сеть работает и это по сути публичная, применять можно в интерпризе, это стандартная блокчейн сеть. То есть выполняет все функции стандартной блокчейн-сети. То есть это не блокчейн, но выполняет все функции. И криптографическую защиту, и консенсус, подписание приватным ключом каждой транзакции. децентрализованное хранение на всех узлах данных, защита данных за счет децентрализации и за счет сквозной передачи хэшей в следующий блок, если это реализуется в блокчейне, то у нас, если могли обратить внимание, есть идентификатор события, идентификатор транзакции, это хэш ее. И поскольку по условию, по протоколу, каждая транзакция в себе, каждое событие имеет в себе поле, в котором прописываются предыдущие события, связанные, обосславливающие, то у нас получается такой event chain. То есть хэш-хэш некого события обязательно включен в хэш последующего события. И есть еще указания на актера, поэтому переписать вот этот граф практически невозможно, потому что в отличие от блокчейна нужно использовать не произвольные ключи для генерации блоков, а именно те ключи, которые актер, который прописан в именно этом событии. То есть это стандартное решение. А теперь решение, какие нам что дает семантика. И, наверное, ваш ответ. Вопрос семантика и модельный подход. Семантика нам, прежде всего, что дает? Она дает нам естественную кластеризацию. Если мы в блокчейне записываем все что угодно, что не пришло в данный промежуток времени, там может быть и котики, и мусор какой-то, и транзакция на миллион долларов, все может быть. в одном блоке, то мы имеем возможность все это сепарировать, то есть и, скажем, деятельность, которая касается финансов, можем ввести в одном кластере, деятельность, которая касается спортивных каких-то мероприятий в другом, недвижимость в третьем и котики в четвертом. То есть сама, вот я говорю, что есть семантические приложения, набор моделей. Эти модели довольно автономные, они не передают данные другим моделям. По этой модели можно составить кластер. То есть вы, я, еще кто-то, мы работаем по одной модели и обмениваемся данными только по этой модели. И консенсус проходит только по этим транзакциям. И мы храним у себя все данные, синхронизированные консенсусом, но только по этой, по одной конкретной модели. То есть есть кластер и естественная кластеризация по моделям. То есть по моделям записываются данные, по моделям генерятся данные, по моделям формируется выделенный кластер для того, чтобы не вся сеть кормилась нашими транзакциями, которые ее не интересуют. Если нас мало, скажем, мы втроем работаем, мы должны подключить ресурсный узел, который будет обеспечивать консенсус, поддержку консенсуса и хранение больших данных. Есть там, скажем, реестр. Мы работаем с реестром недвижимости, мы подключили там еще семь узлов для надежности, которые будут хранить все данные. а пользователи своих устройств будут хранить только те данные, с которыми они функционировали по модели. Скажем, я со своей квартиры, там еще соседа, может, обед какой-то. Вот эти данные хранятся и у меня, и на ресурсных узлах. И еще один момент, который позволяет нам та же самая семантика, это управление консенсусом. Если мы знаем, что в обычной блокчейн-сетях каждый блок проходит одинаковый консенсус для всей сети, потому что, как иначе, закидывали туда помойку, все, запечатали ключом и пошли консенсус проводить по этому блоку. то, скажем, если мы подписываем некий контракт, 5 человек там, или 5 из двух участвует, да, то мы можем некие мусорные промежуточные события, транзакции, там, скажем, обмен комментариями, некий спор по поводу цены, еще чего-то, то есть это входит все в модель, но это несущественно, это не юридически значимо. Мы можем проводить там минимальный консенсус и даже в некоторых случаях будет работать просто бародкастом, без консенсуса. То есть мы просто знаем, вот мы дошли до этой точки, если не дошли, мы там что-то еще подождем или подтолкнем. Но вот когда мы будем подписывать конечную сумму, и по этой конечной договоренности переводить деньги, мы там проведем полный BFT-консенсус. То есть мы можем, аналитик, создавая модель контрактования или еще какую-то модель, некий смарт-контракт, он может для различных транзакций задавать разный консенсус. И разное количество узлов, которое может участвовать в этом консенсусе. Насколько он считает, сам аналитик, насколько важна вот эта сделка и насколько важно конкретное событие, по которому нужно провести консенсус. Отвечая на ваш вопрос, нужно сказать, что есть модель, которая строго соблюдает согласование данных на узлах. Если куда-то не пришло некое событие, человек выпадает из контракта, из модели, и если у него существенная роль, ничего никуда не продвинется. Патовая ситуация, но она решается как-то отдельно, но самое главное, что никакая ошибка здесь не может возникнуть из-за того, что что-то не пришло, потому что весь кластер, все участники работы по этой модели, они отслеживают валидность всех данных, но не синхронизируют, подслеживают и смотрят изменения интерфейса в зависимости от состояния бизнес-процесса. 

S00 [00:41:34]  : Александр, вы извините, вы сами на это подписались, но вот тут вопросы. Первый вопрос, потому что вы говорили от меня. Имеет ли то, что вы рассказываете, какое-то отношение к смарт-контрактам и к цепочкам взаимозависимых смарт-контрактов? То есть, можно ли сказать, что Event-driven или саббативная архитектура, она построена, по сути, на цепочках смарт-контрактов. И второй вопрос непонятный от Алексея Незнанова. Непонятно про консенсус на фоне упомянутых смарт-контрактов. То есть, как связан консенсус со смарт-контрактами? 

S01 [00:42:19]  : Значит, смотрите. Вообще, я не люблю слово «смарт-контракт». И на «Форт Лобби» у меня где-то написана статья на эту тему, что смарт-контракт, он не более умный, чем метаз на бочок. 

S00 [00:42:39]  : Ну, смарт-контракты в терминологии, товарищ Катерина, вот так вот. 

S01 [00:42:43]  : Да, да. То есть, это просто некоторая программка, которая выполняет какую-то бизнес-логику. Сейчас я буду демонстрировать некоторую программку, модель, которая будет демонстрироваться в выполнении бизнес-логики. Поэтому любая модель, любую модель терминологии эфириума, в смысле любую программу терминологии эфириума называют контрактом. Любую модель, исполняемую движком, я называю просто модель. Я не называю это как контракт, потому что это может быть и контракт, да, это может быть контракт, который выполняется, а может быть и там голосование. И теперь, значит, есть небольшая, большая разница между консенсусом по контракту и консенсусом в событийной семантике. Консенсус в событийной, или скажем даже не в событийной семантике, потому что консенсуса в самой событийной семантике нет и быть не может, потому что это семантика. Консенсус есть в сети. Вот в сети, построенной на событийной семантике, на болт С, консенсус делается по событиям, по каждому событию. И поэтому без разницы, это голосование, это подписание контракта какого-то, это опрос какой-то или мессенджер просто, без разницы, тасктрекер, что бы там где ни происходило, в каждое событие оно проходит консенсус. Но здесь хочется еще раз подчеркнуть, что почему это стало возможно в сети на технологии Boxeer и невозможно в блокчейнах, потому что консенсус проводится внутри кластера, внутри ограниченного числа узлов, и может быть упрощенный консенсус для неважных событий. То есть мы достигнем этого консенсуса в любом случае, но он может быть упрощенный. Скажем так, во многих случаях достаточно консенсуса с лидером. Это вполне допустимо. Что-то застряло, лидер поменялся, поехали дальше. Это мгновенно автоматически меняется лидер. Известная технология. С консенсусом все более-менее известно. 

S00 [00:45:01]  : Поясните, что значит консенсус лидера? Помните наш разговор, что такое консенсус и что такое алгоритм отбора? участников консенсуса, который разделяется. Соответственно, первый вопрос. Участвует ли у вас в консенсусе более одного человека? 

S01 [00:45:18]  : Консенсус не может участвовать с одним человеком. 

S00 [00:45:22]  : Хорошо. Тогда каким образом вы отбираете... Первый вопрос. По какому алгоритму вы отбираете участников консенсуса? И второй вопрос. Что такое консенсус с лидером? 

S01 [00:45:36]  : Ну, Антон, это, наверное, просто я бы достал к Вике или к какому-то учебнику по консенсусу, потому что консенсус есть полностью распределенный, консенсус с лидером, когда один узел управляет консенсусом, то есть он получает транзакцию, валидирует ее, рассылает всем, получает от всех значения соответствующие, скажем, от 70% получил то же самое значение, и он дает сигнал всем, что примите эту транзакцию, это с лидером. Без лидера, когда BFT-консенс играется некоторым количеством узлов, они по какому-то алгоритму обмениваются между собой и приходят к мнению, что у большинства, у 70% узлов совпали данные по этой транзакции. Транзакция стала валидной. 

S00 [00:46:20]  : И каким образом вы отбираете участников консенсуса? 

S01 [00:46:26]  : Смотрите, опять же, все зависит от консенсуса. Если это BFT-консенсус полный, то все узлы, которые участвуют в топике, в кластере, работают они все и участвуют в нем. Если, значит, это консенсус лидером, то возможны варианты, то есть автоматическое решение, когда, значит, каждый из узлов может стать лидером. По очереди, как только пропадает один узло, значит, к следующему узлу переходит лидерство, он лидер, он решает консенсус и управляет им. Это не человек, это программа, естественно, узел это все делает. И, возможно, другие варианты, когда, я уже упоминал, ресурсные узлы, ресурсный узел подключается к нашему кластеру 3 ресурсных узла, и мы говорим, что вы между собой играете в консенсус 3. И задается, вы либо с лидером, кто-то один из вас будет, либо вы все играете однорадговую сеть и BFT-концепцию проводите. Провели, всем остальным участникам кластера рассылаете данные, подписанные, скажем, всеми тремя узлами, если лидер, то лидером подписанный, мы проверяем, да, это лидер, да, он подписал, да, он соответствует протоколу, мы все участники кластера берем эту транзакцию. Мы очень много, конечно, потратили на время, на сеть и какие-то вещи, когда нужно смотреть саму семантику, как это работает. Давайте перейдем. Значит, смотрите, у меня было запланировано пока с нуля делать приложение, но я, скорее всего, просто кину ссылку на видео. У меня есть видео, я просто фрагмент его покажу, этого видео. Вот здесь. Фрагмент видео покажу. Сверху, кто видит, надпись есть. Мы об этом должны были поговорить. Голосование есть. И есть он на YouTube. Я не буду его все проигрывать. Три минуты создается приложение с обрезанными паузами, конечно, с копипастом. По крайней мере, все. И две минуты потом демонстрация. Вот, так что я останавливаю, то есть все видео 5 минут с созданием и с демонстрацией приложения. А сейчас мы кратенько расскажу принцип построения приложений, и еще вишенку на торте дам одну в конце этого приложения. То есть я взял Бекмен схемку тупо из Вики, стандартную, в которой, значит, происходит создание офера по заказу покупателя, утверждение его менеджером и утверждение потом его самим покупателем. То есть стандартная такая схема. Вот здесь хочу обратить внимание, вот есть эти шлюзы, вентили, которые вот разветвляют процесс. Вот этого нет. Что мы делаем? То есть мы, по сути, переписываем этот бизнес-процесс в виде событий, которые происходят. А что происходит у нас? По сути здесь видно, что определение предмета, которое покупается, сформирование оффера, решение менеджера. по приему или не приему этому офферу. Если send back, то comment пишется и потом еще сам покупатель подтверждает, не подтверждает и меняется статус самого этого оффера. Значит, сейчас я перейду в сам движок. И загружу в него, я показываю просто изначально, Genesis Graph, который 240 событий. Сейчас, если мы посмотрим, у нас 440 событий, значит, вот еще 200 событий ушло на приложение, которое я сейчас загрузил. И сейчас я покажу еще и структуру самого движка, самого интерфейса. Что мы видим здесь? Мы, как вы уже понимаете, видим здесь сам граф. Чтобы понять, что это граф, достаточно покликать. Вот есть какой-то статус. Мы смотрим, откуда этот статус берется. Вот этот статус и атрибут, он был создан. Либо мы смотрим, что такое процесс RequestRole3. Это индивид процесса нашего, который мы делаем, и его имя, какой модель он сделал, ссылается, и что Джонсон это сделал, то есть актер. То есть все узлы, они связаны, то есть можно потыкать и посмотреть. Вот comment был атрибут, когда-то создан. Это где-то в начале. Дальше. Ну и здесь мы можем reset, export, import сделать нашего графа. Перешли сюда. Что у нас есть? У нас есть приложения. Приложения – это законченные… Ну, это и есть приложения. То есть некоторый законченный набор словарей и моделей, которые выполняют некую одну функцию. Может быть и одна модель, может быть и десятки моделей в одно приложение. И есть список акторов, которые регистрируются. Можно создать нового актора. Я создал нового актора. Да, мы можем здесь сразу же посмотреть, что вот он. Актер Игалов, Булдашин, пускай будет, да. И я от имени Гостя сделал его. Актеры. Есть концепт. Значит, здесь существенная вещь, которую, наверное, все, кто знают, знаком с антологиями, антологиями топ-высшего уровня, и простыми, и предметными антологиями. Показано, что вообще в системе нет никаких классов-подклассов. Есть только концепты. Ни подконцептов, ни надконцептов. То есть система исходит из того, что все действия совершаются с предметами, с объектами, которые по сути являются экземплярами или индивидами, индивидами используется термин, индивидами концепта. Вот стол, конкретно за которым я сейчас сижу, это индивид концепта стола. Но он не является индивидом, скажем, категории мебель. И когда столер делает стол, он вообще не знает, что такое мебель. Он никогда не употребит этого слова. Он никогда не подберет инструмент к мебели. Он не назначит никакую технологическую операцию к мебели. Он не утвердит ничего в мебели. Он все это сделает конкретно со столом, с экземпляром концепта. И это одна из важнейших особенностей разработанной мной онтологии, что в ней принципиально разделены классификация, категоризация системы категорий и концептуальный анализ, концептуальное построение предметной области. Когда есть концепты, между концептами есть какие-то отношения, есть какие-то свойства концептов, и по отношениям концептов, которые составляют модель, строятся индивиды. Есть концепт стол, есть модель стола, поэтому с моделью стола строятся индивиды стола. А все, что касается классификации, вынесено за пределы антологии, за пределы концептуальной схемы и используется только для классификации, поиска, анализа, и при этом классификации может быть множество. Скажем, мы делаем классификацию неких продуктов на предприятии. И понятно, что одна классификация будет для склада, другая классификация будет для бухгалтерии, третья классификация будет для отдела главного инженера, четвертая классификация будет для торгового зала, если он там есть, или выставочного зала. Я считаю, что это категорическая ошибка, которую совершили основатели антологических подкодов, что они антологию стали строить на классификации. и сделав одну классификацию на одну онтологию. Я выбросил за пределы онтологии классификацию, работаю только с концептами, которые представлены моделями, по этим моделям строятся индивиды. Концепт-продукт и концепт-утверждение заявки. Вот эти два концепта, они объединены в одно приложение, которое сейчас мы смотрим. Ну и словари. Значит, вот то, что мы говорили. Есть и словарь системных каких-то свойств. Это именно системные свойства, которые используют движком для внутренних каких-то своих дел, и они не используются пользователями, и они как бы и недоступны. Вот здесь можно посмотреть, но в приложениях их нету. Или вот уже пользовательские Common свойства, здесь только Namco и Comment. Все, теперь мы переходим к самим приложениям. И вот у нас есть приложение, которое реализует вот ту payment-схему, которую я показал. Есть реестр продажи. реестр продуктов. Он представлен тремя индивидами, а сама модель совершенно простая. Просто name и текст. Текстовое значение name. Ну, если нам захочется, мы можем, наверное, присоединить, допустим, комментарии. комментарий к этой модельке, да, и тогда у нас, а я не раскрыл, не показал, да, но вот у нас появился еще комментарий, которым мы можем давать, и можем еще, значит, тоже сейчас быстро показываю, у нас время уже заканчивается, значит, мы переходим в модель, назначаем доступ, permission, У нас кто там? Только менеджер. А нет, давайте админу. А вот только админу. Сейчас нужно перейти нам, я не помню наизусть, кто у нас. Есть приложение, базовое приложение для организации деятельности внутри вот этого пространства, где существуют все приложения. Это либо организация, проект, скажем, там, экосистема. Вот. И здесь у нас прописаны роли, привязанные к индивиду этой организации. В ней приписано, что вот Смит у нас админ, да. Ну, мы тогда и посмотрим наши минусы. О, нет. Значит. Да, вот сейчас никто не достиг, и сейчас Смита я... В сетевой версии это как бы работает, каждый заходит под своей ролью, да, а здесь, вот я записал Смит, вот админ может сделать какой-то комментарий, вот, и мы можем посмотреть, что вот, пожалуйста, Смит по такой-то модели сделал комментарий, который относится к событию турбины. Да, вот оно. продукт первый, и к имени турбина был сделан комментарий. Поехали дальше, значит. И сама модель... Вот, вот это... Сейчас я... А, ну да. А нет, все время я промахиваюсь. Да, вот наша схемка, то есть вот эта вот вся схемка, она у нас вот выражена вот в таком виде. Значит, что в ней? Она абсолютно стопроцентно рабочая, даже более рабочая, чем та схема, которая нарисована, потому что то есть ими нет комментария. Здесь еще добавил комментарий. Значит, что мы видим? У нас есть некий продукт. которое нужно выбрать, это отношение к продукту, который там в реестре. Значит, права у нас записаны на пользователя, на заказчика, кто заказывает, он имеет право выбрать продукт. И condition, вот то, что condition, о котором я говорил, когда может случиться это событие. Тогда, когда офер еще не сформирован. То есть пользователь может менять сколько угодно свои продукты, но только до того, как сформирован офер. Как офер сформирован, все, он теряет возможность создавать, менять продукт. Ну, а name, здесь мы познакомимся еще одним элементом технологии получения значения из графа. То есть вот name у нас прописан там в реестре продуктов. Для этого нужно сделать запрос, который возьмет модель продукта, подставит значение предмета, которое было выбрано, это переменная, которая выбрана вот здесь, и заберет name. Дальше формирует у нас офер. Кто формирует офер? Работник. Давайте параллелим тогда сразу же. Я вот несколько экземпляров этого бизнес-процесса уже провел. Да, сейчас откроем новый Так. Создаём новый индивидуал. Это у нас будет там четвёртый. Заходим. Ничего не доступно, потому что у нас не тот актор, который в роли. То есть в роли должна быть пользователь. Можно посмотреть, действительно, кто у нас там пользователь. заказчик, Williams, еще запомним, значит, менеджер Браун и Джон исполнитель, значит, Williams. Но этой проблемы нет запоминать, потому что каждый работает под своей ролью, когда нормально в многопользовательском режиме. А сейчас я просто не помню. Значит, если мы… Да, вот видим, что открылась возможность. у него роль заказчика, выбрать один из продуктов. Он выбирает один продукт и по запросу, который я там демонстрировал, подтягивается из реестра продуктов его имя. Можно любые другие данные продукта сюда вывести, если есть необходимость. Офер у нас должен произвести вроде Да, и обратите внимание, что вот это событие было сгенерено автоматом, и это инженерный актор. Он у нас сделал. Значит, offer должен делать у нас вроде Jones. Да, вот ему открылась возможность. Он делает offer. И открывается возможность менеджеру, который у нас кажется Браун. Сейчас Брауна переключу, чтобы он получил доступ. Да, вот Браун получил возможность что-то оценить как-то этот оффер. Он говорит send back. И пишет, что добавить информацию. После этого у Джонса появляется возможность отредактировать свой оффер. Скажем, он инфу тупо и добавил. И после этого Браун может опять оценить. Сейчас мы и заканчиваем этот бизнес-процесс Браун. Правда, он говорит Ацепт. Вот, и появляется возможность у Вильямса либо подтвердить, либо отказать. Но он подтвердит, чтобы... Так, Williams. Да, вот у него появилась возможность нажать CES. И все, статус пошел в процесс. Вот. Значит, здесь вишенку на торте добавим. Значит, мы берем наш бизнес-процесс. По сути, все, что есть в описании, это просто разъяснение для пользователя, не для меня. Хотя оно помогает, я выложу его, чтобы можно было посмотреть и попробовать все это сделать. Это в символной нотации записано полностью весь бизнес-процесс. И мы берем, скажем, вот описание, текстовое описание, 4 пункта – покупатель, заявку, сотрудник, формулировать предложение и так далее, то, что мы делали. Мы берем это, копируем. И переходим уже на мозолившие вам глаза, наверное, главную страничку чата Клауда. И Клауду мы только добавим два файлика. Значит, это грамматика. Грамматика языка, которая, как вы видите, состоит из 137 строчек. Это полное описание грамматики языка. Оно в биен-фи нотации сделано. Сделал сам Клаудер. Естественно, я бы не стал это все писать. Александр, можно здесь вопрос языка? 

S00 [01:07:06]  : В данном случае язык, он определен именно только для конкретной модели. 

S01 [01:07:14]  : Нет, это общий язык. 

S00 [01:07:19]  : А там я вижу конкретные ключевые слова, которые относятся к доменной модели. 

S01 [01:07:23]  : Нет, нет, нет, давайте еще раз. Нет там ни одного ключевого слова, которое относилось бы к доменной модели. Там все слова, это универсальный словарь, который хранится в генезисграфе. Посмотрите внимательно. 

S00 [01:07:38]  : То есть, это все зарезервированные слова, скажем так. 

S01 [01:07:40]  : Это все зарезервированные слова. Это язык. Это описание языка, на котором... Вот я когда создавал модель, вот сейчас показывал модель, да, вот это она написана на этом языке. 

S00 [01:07:52]  : А, ну вот Smith. Smith это что такое? Smith это, очевидно, не ключевое слово. А где? Я не вижу. А вот автор Smith. Name – техническое задание. Ну вот сейчас у вас на экране конкретный смит есть. Не вижу. 

S01 [01:08:08]  : Не в каком месте. 

S00 [01:08:09]  : Ну вот зеленым светом. Вы же сейчас зеленый экран показываете, зеленый текст. Я сейчас вижу зеленый текст. 

S01 [01:08:16]  : Нет, нет, нет. Там сверху экземпл написано. Это экземпл. 

S00 [01:08:20]  : Это просто примеры, да? Это просто примеры, да. 

S01 [01:08:22]  : Хорошо. Это просто примеры, то есть ЛНКО, помимо самого, вот снизу это все примеры, вот это примеры записи, то есть вот ниже. Их можно в принципе убрать, но вот значит это вот у нас И второй файлик – это спецификация, она чуть побольше, но тоже, как видите, 500 строчек. Это спецификация языка в формате EML. Я вот эти два файлика, которые предельно малы, скидываю к лоду. И пишу, спрашиваю. Так, буду на русском. Вы понимаете, что это? 

S00 [01:09:28]  : Это вы новую сессию создали, правильно? Новая, абсолютно голая сессия. 

S01 [01:09:37]  : какие есть сущности, элементы, пример какой-то, вот как записано, и все. То есть вот он все съел, сказал, что я знаю, это судебная документация. А теперь я говорю ему, создайте приложение по текстовому описанию и у меня в буфере там было наше текстовое описание вот бизнес процесса да вот оно было наше текстовое описание вперед Всё строго в формате. Я это сейчас не могу загрузить API нашего движка. Не совсем готов. Я более чем уверен, что здесь есть ошибки. То есть нужно посидеть часик-второй, попроверять, посмотреть. Но просто кувипаста можно перенести. Значит, вот он создал модель и написал, что, как, структура приложения, роли какие, действия какие, бизнес-процесс, статусная модель, то есть запрос вот он как бы создал. А теперь, значит, мы делаем еще один интересный момент. Значит, я беру Как вы видели, сколько он написал, какую простыню. А у меня вот столько. Это сделано руками. Я возьму. 

S00 [01:11:30]  : Тогда сразу вопрос спросится, в чем разница, почему он просто не у вас? 

S01 [01:11:36]  : Сейчас он ответит. Я просто экспериментировал. Но это чистая сессия. Он вообще первый раз ничего не знает, он еще не помнит ничего. Вот, значит, приложение. с его руками, с которым все... ну ладно, неважно, пускай... оцените его. Но я задал его оценить, чтобы он оценил, потому что если не оценить, то он начнет говорить, ой, как чудесно, как прекрасно, а так можно было сделать коротко. Компактный, хороший используемый условий выражения, четкое предъявление прав доступа, возможно, улучшения пишет какие-то. То есть он прекрасно по нескольким десяткам килобайт текста может строить модели и прекрасно понимает Я проводил эксперименты с полноценной переносом модели. То есть он делает, переносит JSON, я копипащу его в файл и загружаю. То есть именно полностью без моего участия он создает приложение. Давайте еще к интересному моменту перейдем к складам. Оставить его в покое. Да, вот чтобы еще раз продемонстрировать гибкость самой системы, давайте-ка мы дополним наше приложение. То есть мы вот сделали приемку оферов или отказ офером. по продуктам, которые записаны в реестре, но в самом реестре эти офферы не отражены. Давайте их туда и отразим. Что мы должны сделать? Мы, значит, должны перейти в нашу модель. Я немножко еще, чтобы руками не набирать, скопирую. Значит, модель нашего реестра, где продукты, и добавим туда свойства, ссылку на документ, в котором этот продукт упоминался, использовался. Сначала в словарик добавим отношения, которые назовем так назовем беспробелом, вот, и ему зададим, значит, range, только вот наш процесс request. Чтобы он других значений не имел, то есть это range мы ему задали. А мы еще по ограничивающим свойствам полностью не прошлись. То есть, как вы видите, ограничивающие свойства можно задать либо в самом словаре, в самом словаре, либо в модели. Скажем, если мы определяем свойства семейного положения, имеет супруга, то понятно, что мы прямо в самом словаре можем задать, вернее, фактически физически находимся в словаре, но фактически это не в словаре, а просто к свойствам можем задать ренч, что это будет персона. А можем определить здесь специфические раньше или другие какие-то ограничивающие свойства, можем их определить прямо непосредственно в модели, что мы уже делали. Значит, возвращаемся назад в модель, в модели реестра нашего, да, и добавляем наше свойство, наше свойство, и, наверное, все, никаких «а». Да, поскольку у нас множество значений может быть, офферов которыми участвует данный продукт, то нам нужно сделать multiple. И смотрите, это ренч, он уже включен, он подкрашен, потому что он включен в словаре, он глобально включен. То есть именно что продукт может быть относится только к этому документу, а нет, только к отношению, вот это отношение, оно может иметь отношение только к этим офферам. Обязательность здесь понятна, неизменяемое понятно, кондишн мы уже с вами делали, то есть это кондишн – это самое главное свойство в движке. Он определяет, когда должно совершиться событие. И этот кондишн обеспечивает выполнение бизнес-логики. И тут я не произнес еще одну фразу, поскольку используется практически чистый дата-флоу-подход, дата-флоу-архитектура, то можно утверждать, что исполнение бизнес-процесса, вот сама бизнес-логика, она череполна. То есть можно исполнить все, что угодно. Все, что можно исполнить на других нотациях, здесь можно тоже исполнить только с кучей преимуществ. Можно потом отдельно присудить, какие преимущества. Value condition определяет ограничение на значение, то есть можно задать больше, меньше в таком-то диапазоне. Любое выражение, которое я напишу с участием переменной value, я могу задать любые ограничения на вводимые значения. То есть он просто не даст вести вне этого выражения. Permission – понятно. SetValue – получение значения из графа, если нужно автоматически выполнить событие, вот как NamedName нас подтягивалось из реестра. Unique – значение, более-менее понятно, да, не буду рассказывать. И SetRange – ограничение на сам range. Ну, скажем, если у нас person есть отношение, range, то мы можем задать только мужчины или только старше 18 лет. То есть какие-то ограничения, которые запрещают выбирать из этого диапазона. Ну и default, обычное значение, которое предлагается по default. И теперь нам нужно на вот это значение получать его из графа. Нам нужно получить его через setValue. Еще я не показывал. Есть редактор запросов, отдельно состоящий. На нем можно экспериментировать вне модели. И здесь у меня этот запрос уже стоит, то есть модель нашего утверждения, в которой сам предмет оффера равен current индивидуалу, то есть тому индивидуалу, к которому сейчас мы будем смотреть. И можно проверить, скажем, Контекст. Вот я подключил контекст продукт 1. И выполняю. Вот он показал, что вот есть в третьем. А если 2, то будет... в первом. А, наверное, три у нас было. Я не дожал. Да, не дожал. Вот два. Хорошо, значит, мы берем этот опробованный нами уже проверенный запрос и вставляем нашу модель в Set Value. Ставлю Set Value. Так, сохранили. Сохранили. Так. Ошибки. А, ну да, все правильно. Я не сохранил multiple. То есть он возвращает несколько значений. Да, и это так, я знаю. То есть он сначала, если панцу выставить после того, как он уже запрос получит. А, ну вот как сделаем. Мы запрос просто удалим. И добавим запрос. Должно сработать. Это просто еще не поставлена защита, чтобы Да, все сработало, значит, и мы смотрим, вот у нас появилось, значит, что эта турбина участвовала в процессе квест-стройки, да, можно перейти, можно назад перейти, да. Вот, а наша третья участвовала в двух. Можно перейти и посмотреть, что здесь. В этом так, во втором было. перейдем, и четвертом, который мы делали. Интерфейсы строятся автоматически по моделям, связи все по моделям, то есть как бы ничего не нужно делать, потому что онтология, она есть онтология, то есть там мы по сути строили сейчас, мы сейчас по сути строили онтологию предметной деятельности, в которой есть реестр, в которой есть акторы, в которой есть какой-то бизнес-процесс, который вот мы совершали. То есть это вот ответ, кто строит граф. Граф строится по деятельности. Сначала аналитики без программистов строят модели, и по этим моделям проигрывается бизнес-процесс. Он может более-менее автоматический в зависимости от того, насколько участвуют акторы. Может быть, если актерами являются дикие датчики, он будет отрабатывать по датчикам конечный автомат. И теперь перейдем, у нас время уже наверное, да, чтобы на вопрос осталось как-то коротко, а кто строит и как антология, мы перейдем опять нашему Клоду, вот, и посмотрим, как Клод строит Антологии по тексту. Значит, проект. проект.bltllm. Да, наверное. Наверное, вот этот. Он же там просто поясняет. Нет, предыдущий. Пока поясняю. Есть идея, она подтверждена уже практически на экспериментах. Идея заключается в том, что никакой искусственный интеллект, никакой ЛНК и вообще никакая вероятность системы не обеспечит нам необходимой строгости выполнения деятельности, общей деятельности. юридической, финансовой, еще каких-то областях, где требуется строгая отчетность, строгая ответственность и строгая прослеживанность всей истории. И проведен ряд экспериментов, которые показывают, что можно обучить легкими, промытыми, несложными, как я вот сейчас показывал, лэмку на то, чтобы она по неким текстам тестовым, строила, ну уже пройдено, был взят документация банка, фрагмент, и она построила модели, собитийные модели, которые сейчас мы смотрели, которые строил по текстовому описанию, просто по промуту короткому, а так можно по, значит, Тексту построить модель этого текста. В чем здесь отличие от антологии? Не строится связь между концептами и прописывание каких-то отношений между ними и каких-то свойств, а строится именно бизнес-логика, то есть последовательность операций, которые излагаются в виде модели. И в дальнейшем эту модель можно использовать для анализа других текстов подобных. Вот здесь предметная область выделяется из предметной области событийной модели, бизнес-модели, и в дальнейшем они применяются для семантического парсинга других текстов. В принципе, если мы посмотрим, подумаем, что человек всегда только так и действует. Человек никогда не может распознать какое-то положение дел, какую-то деятельность, если он не обладает структурированным представлением, неким шаблоном, некой моделью, неким фреймом, именно динамическим фреймом этой деятельности. Ну, скажем, если человеку никогда не бывшему ресторану дать почитать книжку, где описано, поведение людей в ресторане, он вообще не поймет о чем-то. Но человек, который прекрасно знает все условности, все обуславливающие события, все акты, последствия, возможные пути проведения действия в ресторане, он любой текст прочитает и выделит в нем, даже если там будет, он сидит за столом, он махнул рукой. Человек, который не знает, он не поймет, а человек, который знает всю схему, которая есть, он поймет, интерпретирует. А это он зовет официанта. И поэтому во многих деятельностях, практически во всех деятельностях, мы должны иметь в любом случае, помимо ЛНК, помимо искусственного интеллекта, формальную запись. И вот сейчас мы работаем над тем, чтобы с помощью движка, который будет балидировать данные от LLM и записывать их к RAF, с помощью самой вот семантики создавать слой, формальный слой, на котором будет реализовываться деятельность. Вот, а в этом деятельности будут фиксироваться все шаги, да, и все документы будут, значит, не то что валидироваться, а просто парситься. Но парситься именно по моделям. То есть и CHAT-GPT, и CLOT довольно спокойно с этим справляются. Сейчас мы над этим работаем. То есть это условное название постоянной памяти LLM. То есть, если мы задаем, при наличии такой системы постоянной памяти, задаем вопрос какой-то системе, значит, если система оценивает, что это формальный вопрос, скажем, какой тариф там на таком-то, сколько стоит вот это СМС на таком-то тарифе, то Здесь достаточно просто делать запрос к графу. Он прекрасно пишет запросы, как вы видели, пишет формальный запрос к графу и получает ответ. Ну и плюс еще дает фрагмент текста, откуда это взято, потому что каждый акт парсинга какой-то фрагмента текста, подведение его под модель, он сохраняет этот фрагмент текста или фиксирует его положение в исходном тексте и связывает с графом. То есть мы всегда, подогнав под какую-то модель фрагмент текста, можем получить эти фрагменты в качестве либо дополнительного промта, либо просто цитаты. Либо в явном виде, то есть если там какая-то табличка с тарифами, он просто явно его выведет. Ну вот, наверное, все, что я хотел рассказать. Александр, спасибо. 

S00 [01:28:49]  : Давайте пойдем по вопросам. Сейчас отмотаю в начало. Про словари и про тезаурусы мы обсудили. Про материалы обсудили. Из YouTube есть вопросы. Можно ли в версии X сделать то же самое, что вы показывали с точки зрения событий? 

S01 [01:29:15]  : Именно в Excel, но он же не семантический. Если мы зададим некий словарь для Excel, в котором будут фигурировать поименованные сущностью с уникальными идентификаторами, то в принципе да. Я как-то писал на эту тему, что не хватает Excel для реализации бизнес-логики. В принципе, я реализовывал на Excel бизнес-логики, там больше ориентировано на расчеты, там нет пошагового перехода, вот чего там нет. То есть там каждый акт совершается со всеми таблицами. И все они находятся в едином состоянии. Здесь мы, делая какой-то выбор или получая какие-то данные, мы переводим систему в другое состояние, к другому этапу, вот как мы без слов проходили, к другому этапу переходим, к другому статусу, чего нет в Excel, и это очень сложно реализовать. Можно, наверное, но очень сложно. Но самое главное, там нет семантики. Нет хранилища, то есть мы не можем сделать и темпорального хранилища, мы не можем ориентироваться в бизнес-токе на прошедшие события какие-то. Вот в этой ячейке было число 5, 10, и эта последовательность тоже может иметь бизнес-значимость. 

S00 [01:30:42]  : Хорошо, спасибо. Следующий вопрос. Как вводятся эскалации из БПМН? 

S01 [01:31:03]  : Понятен вопрос? Да, понятен. Я в явном виде не сталкивался в бизнес-процессах с этим, но предварительно их Быть не должно. Они обрабатываются как обычный бизнес-процесс. Если нужно будет откатиться на какое-то состояние, то это обычный бизнес-процесс событий на семантике. То есть там нету какого-то специального, поскольку это субъективная семантика, то есть мы просто какие-то значения не будем учитывать в будущем. Кстати, да, удаления нету, они просто, скажем так, ветка повисает в воздухе. И мы возвращаемся на какое-то состояние, и от нее начинаем дальше. Здесь не нужно никаких специальных приемов, какого-то специального программирования. Еще можно сказать так, что для сложных систем, не таких, как я сейчас показывал, конечно, нужны еще иметь оркеструющие или, скажем, хореографирующие модели. которые отслеживают по каким-то своим моделям, то есть по каким-то своим условиям и ограничениям главный процесс. То есть если где-то что-то застряло или наоборот получилась ошибка, то эта вот сама модель должна перевести процесс на другой путь. То есть в любом случае это делает человек в каждом конкретном случае, а не какой-то отдельный процесс, что вот нужно откатить куда-то. 

S00 [01:32:46]  : Хорошо, спасибо. Там у Алексея Незнанного есть комментарий по поводу Вашего ответа, если останется время. Следующий вопрос от Кима Артамонова. Осталось провести границу между концептами и классификаторами. Давайте я зачитаю весь вопрос. Осталось провести границу, где концепты, а где классификаторы. Согласен с вопросом. Концепты – это только 4D-объекты. Не понял, что значит 4D. Или концептами и концепциями могут быть какие-то абстрактные понятия. Например, заказ. А если машина, транспорт, вертолет? У меня, например, для какой-то модели транспорт – это объект, а в рамках другой транспорт – это категория. Это вот про что мы на предыдущем семинаре говорили. И как связаны эти две сущности транспорта? Вот такой вот развернутый вопрос, если хотите… Хорошо, понятно. 

S01 [01:33:51]  : Значит, начнем с главного критерия. С главного критерия. Концепт – это то, что имеет активит. То есть если у нас концепт – это то, что имеет индивид, конкретный экземпляр какой-то чего-то, скажем, если мы можем ввести концепт адреса, И когда у нас есть полная база адресов некого города, скажем так, мы можем ввести город как концепт, когда у нас есть у него индивиды, которые используются в качестве индивидов нашей системы. И мы тогда из списка выбираем эти индивиды – Москва, Лондон. А если у нас нет этого реестра, то тогда город будет атрибутом, который мы будем руками вбивать. То есть действительно в разных случаях нечто может быть атрибутом, нечто может быть концептом. Но это не столь интересно, больше интересно это с классификаторами. Я принцип разделения вроде бы сказал, что у категории классификации не может быть индивида. То есть мы тыкая пальцем на любой предмет у себя дома, мы скажем это диван, это кресло, это шкаф. Вот шкаф, диван, кресло – это индивид. Мебель – это, в смысле, это и концепты. Мебель – это не концепт. Потому что у нас нет индивида мебели конкретной, поцарапанной. Вот поцарапанный стол, но не мебель. У нас нет цвета у мебели. То есть это концепт, то, что имеет индивид, а этот индивид имеет свойства конкретные свои. Поцарапанный там, сломанный, за которым я сижу. Да, действительно бывают ситуации погорничные и в некоторой предметной области что-то может служить не концептом, а классификатором, но это настолько редко, я не встречался. 

S00 [01:36:03]  : То есть вы отрицаете, что существует концепт поцарапанный стол, абстрактный поцарапанный стол? 

S01 [01:36:08]  : Нет, конечно, конечно. Класс можно ввести. То есть в том-то и дело, что я специально убрал это слово класс, можно класс поцарапанных столов. Но это всего лишь множество. Это классификационное множество. То есть мы когда будем, скажем, проводить какую-то операцию инвентаризации в школе, мы введем класс поцарапанных столов, и часть столов введем поцарапанные столы. Но это классификация. Это не концепт, у которого есть индивиды, потому что каждый из столов он подпадает под концепт стол. а не под поцарапанный стол. 

S00 [01:36:52]  : А разница где? Вот почему в одном случае мы, допустим, делаем классификатор «люди», а в другом два классификатора «мужчина» и «женщина»? Вот чем определяется граница? 

S01 [01:37:02]  : Или это чисто… Ну вот я, например, не делаю концепты «мужчина» и «женщина», а говорю, есть концепт «персона», «человек», и у каждого из них свойства «секс». То есть здесь, конечно, можно ввести, ну, скажем, у человека легко отличить женщину от мужчины. То есть, в принципе, можно сказать, это кто эта женщина, это кто этот мужчина. А если вы покажете, скажем, на лошадь, что вы ответите? Это конь, это лошадь. Вы не скажете, что это кобыла или жеребец. И опять же, вопрос в том, как мы это будем использовать. Если у нас есть реестр мужчин отдельный от реестра женщин, И есть набор свойств, которые приписаны именно женщинам. Значит, у нас получается, женщина от мужчины отличается только одним свойством. Имеет ли нам смысл вводить два концепта, которые отличаются одним свойством? Полу. То есть мы можем задавать еще какие-то свойства, которые их отличают, но это непродуктивно. То есть я просто, имея опыт моделирования на своей системе, я не вижу необходимости в этом. То есть мне проще вести свойства имея царапину, чем создавать отдельные концепты столб с царапиной. 

S00 [01:38:31]  : Хорошо. Ну и тогда последний вопрос. Может ли быть такое, что один и тот же транспорт в одном случае это объект, а в другом случае это категория? 

S01 [01:38:42]  : Я считаю, что, скорее, все-таки, некорректно. Нет. Потому что, если, смотрите, если мы по транспортам понимаем, есть гараж, да, и вводим Концепт транспорт, и при этом никак не различаем легковушки, самокаты, мы их не различаем никак, нам без разницы. Ну, скажем, в ПДД, да, это можно ввести, только, наверное, не транспорт я назвал бы, а транспортное средство. Тогда да, мы можем ввести, но даже не в ПДД, а где-нибудь там в ГАИ, или как у нас сейчас называется, не ГАИ, но очень понятно, в ГАИ они не различают крузовики от, скажем, легковушек и еще каких-то транспортных средств, и тогда они могут транспортные средства концепт и модель транспортного средства будет у них включать только скорость, направление, еще что-то, и будет ехать индивид, который имеет скорость и направление. Да, тогда да, можно. Но здесь все определяет тем, что различают ли в предметной области индивиды по каким-то специфическим качествам. Если не различают, то можно вводить транспорт-концепт. 

S00 [01:40:01]  : Хорошо. Спасибо. Давайте двигаемся дальше. Тут еще много вопросов возникает. Следующий вопрос. Мой как раз был по GUI. Вы показывали, как вы работаете с событиями, с их свойствами. И если я правильно понимаю, это такой так называемый универсальный интерфейс, типа бородилка, в которой можно создавать все что угодно и унифицированным образом работать со всем угодно. Я правильно понимаю? Да. 

S01 [01:40:35]  : Это административный интерфейс для аналитика. который создает модели. Это не пользовательские. А вот для пользователя... Сейчас расскажу. Смотрите. Я хотел сегодня показать, но на старом движке только есть эта старая версия. На новую версию не удалось мне сейчас. Ее закончили буквально в начале недели, сейчас допиливали, там какие-то баги были. Поэтому сейчас расскажу, как это должно выглядеть. Базовый принцип, помимо того, что никакие классификации не входят в создание моделей, и создание концептуальной структуры предметной области деятельности. Другой базовый принцип, это уже касается движка конкретно, административного интерфейса, всю бизнес-логику можно сделать в административном интерфейсе. Полностью, абсолютно, это полноценный редактор антологии и полноценный движок. То есть мне не приходится что-то типа вот это будет водиться пользователям. Нет, этого нет. То есть полностью вот тот экран, в котором я работал, вводя данные какие-то, это просто отображение модели на интерфейс. То есть тупое отображение со всеми ограничивающими свойствами. Вот. Значит, теперь переходим к пользователям. Да, и поэтому он довольно такой навороченный, поскольку работает аналитик. И сделано все предельно удобно для того, чтобы аналитику это было удобно работать, создать новые свойства, новые концепты, занести свойства в словарь, словарь подключить к приложению, создать новое приложение. Вот. Дальше там импорт приложения, экспорт приложения. Вот. Значит, теперь используйте. Решено таким образом, и оно работает сейчас, но не на 100%, что вы показываете. В смысле не то, что показывать можно, но еще не production. Что такое поведение пользователя в интерфейсе? Это некая деятельность. То есть это некая деятельность, практически ничем отличающаяся от подписания контракта. То есть есть некоторые концепты, есть некоторые свойства, и пользователь проводит какие-то операции. То есть у нас сейчас есть концепт view. Концепт view – это отдельный системный концепт. Может, вы видели, он показывался на экране. Концепт view. У этого концепта view есть множество моделей. Каждая модель соответствует какому-то типу страницы, скажем, тип страницы, на котором отображается индивид. И в этой модели есть View-свойства различные. Одно View-свойство – модель отображения списка индивидов. И вот View-свойство, у которого есть такие значения, как таблица, лист, список или витрина. То есть мы описываем интерфейс на событийном языке с помощью событийных моделей. Это очень интересное решение, и получается так, что никакие действия в интерфейсе пользователя не влияют на бизнес-процесс, они только внешне что-то делают. В интерфейсе нет ничего от бизнес-логики, только отображение бизнес-процесса. В общем, при наличии таких моделей интерфейс одной кнопкой, то есть там кнопка уже есть, переключается на пользовательский интерфейс, и пользователь в нем работает. И при этом в нем есть, скажем, view-свойства title, view-свойства комментарий, view-свойства image. То есть ты можешь граф записать, всю структуру, правильно, Граф – это некая структура. Страница – это тоже некая структура. И в этой структуре мы можем создать специальные свойства, которым переписать текст, картинку, ссылку, кнопку, задать какие-то свойства выше-ниже, справа-слева, и таким образом сконструировать страницу пользовательскую, которую CSS разукрасить в любой дизайн. Но это не исключает возможности и необходимости создания кастомных дизайнов для заказчика. То есть это именно пользовательский такой интерфейс, который убирает с экрана админского интерфейса все ненужные меню, все ненужную информацию, которая нужна аналитику, оставляет только голые данные. А, ну вот, чтобы еще понять, скажем, есть таблица со всем списком данных, которые вот мы только что заводили. Есть свойства включить и исключить. Я могу исключить из этой таблицы какое-то свойство. Я ввожу, то есть выбираю это свойство и выбираю список. И такое-то свойство, там нейм убрать, там комментарию убрать, еще убрать, и с экрана-то уходит. Могу что-то добавить, и появляется на экране. И здесь появляется такая возможность, которую еще не опробовали, но она будет точно работать, это управление интерфейсом с помощью LLAMP. Поскольку понятно, что LLAMP легко строит модели. Она может строить модели интерфейсов. Интерфейсные модели на порядок проще по своей структуре, по количеству свойств, чем бизнес. Они унифицированы, и по запросу ламки я могу перегенерировать мгновенно всю страницу. Я буду генерировать не HTML, как сейчас делают, а я буду перегенерировать модели. конкретный индивид по этой модели для этого интерфейса, а уже контроллер по этому индивиду построит конкретную страничку. Я могу сказать, выброси эту колонку, переведи вместо таблицы «дай-ка мне витринку», вот это и свойство «не отображай», и таким образом выбрасываем все меню к чертовой матери. Меню становится не нужно, потому что меню – это какая-то предустановленная структура, которая в данном случае не нужна. То есть я могу в конкретный момент по своему желанию вывести конкретный объект, по конкретной модели, И сепарировать, что показывать в этой модели, что не показывать, и как сортировать. Да, кстати, я уже сейчас упомянул, но раньше как-то не упоминал, что у одного концепта может множество моделей быть. Вот у Vue-концепта множество моделей. И у персоны может быть множество моделей. Одна модель для отдела кадров, другая модель для бухгалтерии, третья модель – его хобби, четвертая модель – его генетическое древо и прочие семейные дела. Любое количество моделей можно создать для одного концепта, и он будет в том или ином приложении, в той или иной предметной области использоваться. Это очень существенно упрощает, чего очень сложно сделать в традиционных семантиках. 

S00 [01:47:49]  : Спасибо. Давайте пойдем дальше. Есть вопрос по поводу… Сейчас что-то убежало вперед. Да, вот ссылочку про анализ банковских документов. Можно подробнее? Алексей Незнанок пишет. Можно ссылку на анализ банковских документов? 

S01 [01:48:10]  : Нет, ссылку не дам. Подробнее рассказать? По сути, я все рассказал. Могу только вкратце схему сказать. что на первом этапе с помощью ЛНК строятся модели предметной области, модели именно бизнес-модели, то есть модели действий, а не структура, не просто антология, состоящая из кучи узлов и связей. А вот именно тот граф, который сейчас я показывал, получаются такие модели. То есть модель прохождения транзакции, такое-то. И вот точно так же по событиям. Такое событие, условие такое-то, такое-то событие, ограничение такое-то, такое-то событие. То есть он строит эту модель. И вся предметная область состоит динамически из таких моделей, ссылающихся друг на друга. Вот модель реестра была. Они ссылались друг на друга. Один брал name, а другой брал результат, что заключен там, офер получен был, значит, там отобразилось. в этом реестре. Вот строится такая модель, она строится совместно с экспертом, обязательно с экспертом. То есть это никогда не будет работать автоматически, потому что ламки ошибаются, ну и плюс здесь скорее всего даже если не ошибаются, то под каждой моделью должен стоять подпись человека, кто ошибся. кто ошибся, кто должен вести ответственность человек. После получения вот этой модели, у меня заняло где-то час. 2 часа получения одного фрагмента документации, перевода его в модели, в деловом режиме. И там как раз возникали вопросы, это категория или это индивид. То есть мы строили еще категорию, классификацию. Классификация отдельно, она отдельно существует, она помогает делать навигацию предметной области. Она не заменяет бизнес-процесс. Это навигация. Это относится к этому или к этому. Или это искать вот там или здесь. Создание категорий, создание концептов, создание моделей концептов, актов еще в моделях. И дальше, имея вот эту структуру, имея уже трафарет, ты подсовываешь другой документ. Ты даешь этот документ, первоначально определяется классификация его, довольно просто все-таки ламки работают с классификацией. Дальше берутся фрагменты и ищутся, под какой... ламка делает, то есть она говорит, вот этот фрагмент подпал, значит, на проведение транзакции такого-то типа. И она берет из этого документа со строки такой-то, по строке такой-то, фиксирует фрагмент, не случайно, как фраги, нарезка это начанки, а именно под конкретную модель. То есть модель служит шаблоном для нарезки. И если в документе, может быть, модельные описания, то есть как себя вести в ресторане описано. Мойте руки, говорите так, заказывайте тот, берите меню. Это модель. Мы можем тогда связать, что вот это, описанное в этом тексте, соотносится с моделью. А может быть Маша с Сашей пошли в ресторан, заказали тот. Это индивид, это экземпляр уже этой модели. Тоже записывается, по модели выбираются эти данные, и зачисывается, в граф строится предметный граф. Ну а дальше уже дело техники, когда есть связь реестра текстов, реестра фрагментов, они также со своими идентификаторами ссылаются друг на другом, и предметная часть графа, и модельная часть графа, уже по ним отвечать возможно. И дальше, если совсем хорошо подумать, это после совершения такой операции документы перекочевывают в граф. Если я какой-то документ записал, параметр время прохождения транзакции 2 дня должно быть, если мне нужно заменить эти 2 дня на 3 дня или на 1 день, я не в документе буду, я в граф полезу и там изменю. И перегенерю документ. Мне проще перегенерировать по моделям и по индивидуум документ или вообще его не иметь. в принципе. А сейчас есть функция генерации PDF по индивидуам, то есть он может шаблончик сделать на штамеле и нажать кнопку и вылезет PDF со всеми данными, вот мы проводили там оффер, то есть кто провел, что когда, какие были решения, там есть и суммы, там суммы какие-то, то есть все это можно в PDF сразу выгрузить из бешка. 

S00 [01:53:12]  : Алексей здесь как раз комментирует, что он еще ни разу не видел, чтобы БИАМ делала анализ документов нормально. Вы утверждаете, что вы с помощью больших языковых моделей делаете это приемлемо для практического применения? 

S01 [01:53:28]  : Да. Два основных момента, которые я постоянно повторяю, это наличие модели. То есть ты должен построить модель. То есть ты можешь руками ее построить, но она должна быть. То есть здесь система такая, что можно автоматически чего-то нагенерить за неделю в раге, а потом полгода с этим иметь проблемы. Или ты можешь за два месяца сделать модели хорошие и потом не иметь никаких проблем. Это вот модель должна быть. И второе – это никогда не должно быть автоматически. Это всегда должен быть эксперт. Эксперт, который должен проверить модель, проверить все. Он знает, что это модель. Понятно, почему эксперт не используется сейчас. Какой эксперт полезет в векторную базу данных? Что он там увидит? Ничего не увидит. Либо даже если есть граф, скажем, обычный граф, объектный граф, то что там проверять? Ну да, он видит, что транзакция связана со счетом. Ну и что? Там нет моделей действия, то есть ты документ не можешь проверить по объектному графу. 

S00 [01:54:53]  : Спасибо. Дальше здесь еще есть набор вопросов или пожеланий от Алексея Незнанова. Первое – это масштабирование темпорального хранилища. Возможно ли применять вашу систему с вашим темпоральным хранилищем? И, кстати, у меня тогда сразу еще вопрос о том, какое у вас темпоральное хранилище, как оно устроено, я имею в виду долгосрочное, и как у вас разделяется Допустим, краткосрочное или долгосрочное хранилище. Если у вас разделение In-Memory Database или Persistent Database. Это первый вопрос. И можно ли работать более чем с 20-миллионными событиями в день? К вопросу о банке. Второй вопрос. Из чего можно делать ingestion? Третий вопрос. Масштабируемость и как у вас организована память. Нагрузочное тестирование пока не делали, поэтому про миллионы точно сказать не могу, где граница. 

S01 [01:56:07]  : Но есть чисто архитектурные решения, которые нам позволяют быть уверенными, что с нагрузкой и с масштабированием будет все в порядке. Прежде всего, граф жестко сегментирован, а разделен по веткам по отдельным приложениям. То есть нет, в отличие от графа объектного, когда мы делаем запрос по целому графу, но он может там из-под графа как-то состоять, мы можем его разделить, но здесь у нас жестко идет разделение. Вот мы сейчас работали с реестром продуктов и с офферами по ним. То есть это отдельная ветка графа, которую мы можем выделить, отделить и отдельно загрузить в память. И мы будем уверены, что никогда Да, за пределы вот этой ветки не уйдет запрос, потому что запрос делается по модели. Запрос делается потому, что есть в модели. Никакой запрос произвольный, но это мы говорим именно по бизнес-логике, по аналитике там немножко по-другому будет, когда мы аналитику делаем по графу. Как всегда, аналитика по данным отличается от создания самих этих данных. То есть здесь мы именно говорим, что мы можем разделять и загружать в память, сейчас рабочая ветка загружается в память, и синхронно при каждом событии, события записываются, хранилище, хранилище – это хранилище браузера, может быть, любое хранилище, потому что, понятно, это одна таблица, может быть, или множество таблиц по моделям. То есть вот как нарисован у меня там был вот этот Это может быть таблица из восьми колонок, и таблица может быть одна по недвижимости, другая по офферам, третья будет по голосованию. Они опять никак не связаны, поэтому можно разносить и загружать в память только ту часть, с которой конкретно мы работаем. И еще один момент по производительности. Не нужно забывать, что это DataFlow архитектура. А Dataflow-архитектура нам помогает запустить несколько движков даже на одной модели. То есть если мы знаем по анализу модели, что вот эти два события не перекликаются, или даже две модели не перекликаются по семантике, то мы можем их обрабатывать параллельно. Они где-то совместятся, в результате какого-то события они придут, но распараллеливание за счет именно дата твоего архитектуры, оно успешно применяется. И, конечно, продуман этот вариант, что, скажем, если у нас вот этих продуктов от реестра 4 или 3 продукта, а если у нас их 100 тысяч, то, естественно, нужно выделять отдельную таблицу и кэшировать туда данные. То есть, когда у меня есть запрос к этому реестру, он преобразуется из моего семантического запроса к графу, преобразуется в скейрный запрос, и получаются данные. Возможно создание кэш-таблицы, если большие объемы однотипных данных, то есть распараллельные кэш-таблицы и однозначная кластеризация данных по моделям, то есть несмешиваемость их, что позволяет, скажем, Мы делаем запрос ко всей базе, ко всем таблицам, не к отдельным транзакциям. Здесь мы можем делать к отдельным независимым веткам и еще внутри веток по независимым моделям запускать отдельные движки. 

S00 [02:00:12]  : Спасибо. Насколько я понимаю, вопрос про ingestion подразумевает, из каких источников вы можете загружать данные? 

S01 [02:00:21]  : Из любых. Если это внешний источник, не форматированный исходно под данную семантику, по данным словарям, то просто маппинг нужно делать, как обычно, здесь ничего не придумаешь. Я делал такой профоконцепт на предприятии в Екатеринбурге, которые занимаются безопасностью, и там у них приходили джейсоны. И нужно было движком построить модели, по которым эти данные каким-то образом классифицировались, и еще последовательных, чтобы они выдавали какие-то варники, предупреждения, что-то переключали или что-то игнорировали. Создали отдельный концепт, который назывался маппинг. В этом концепте модель определяла соотношение ключей и сущностей словарей. То есть прогонялось, переводился в событийный формат, а дальше событие посылалось по модели обычной уже своим путем, когда оно проходит как с интерфейса, я там набираю что-то, нажимаю кнопки. Точно так же можно и извне принять. Если мы работаем внутри своей области, то мы сразу можем все джинсоны, все ключи соотнести со словарями. Тогда оно напрямую пойдет без снаппинга. 

S00 [02:01:53]  : Спасибо. Следующий вопрос. Масштабирование вычислителя. Планируется ли возможность запуска в узлах современных ИИ-агентов? 

S01 [02:02:06]  : Понятен вопрос? Да. Я не произнес фразу и не особо уделил внимание запросам. Запросы у нас сделаны на джаваскрипте. То есть, по сути, это чисто джаваскрипт с нашими внедрениями семантическими. То есть, сама некий формат, который делает запросы, он семантический, как и по модели определяет. А вот обработка – это джаваскрипт, и если нужно что-то подсчитать, то просто пишешь на джаваскрипте внутри запроса или внутри выражения. А значит, если больше какие-то расчеты нужны, то планировалось, сейчас пока нет необходимости, но скорее всего это реализуемо, то есть какие-то специальные скрипты, скажем так, или как-то, которые написаны в каком-то языке скоростном, который могут сделать. Получаешь некое выражение, в котором есть ключевое слово, которое требует передать вот этот фрагмент в расчет на какой-то супроцессор, арифметический или математический, и вернуть. Но по поводу агентов это другой вопрос, не касающийся… Да, есть сейчас работа ведется над этим. То есть, по сути, что мы получаем? Помимо того, что LM-ки могут генерить модели, так эти сами модели могут и оркестровать, или как-то управлять агентами как таковыми. То есть здесь не нужно уже писать никакого кода. То есть то, что я могу написать на Питоне, я могу написать и событийную модель сделать. Эту событийную модель может еще и сама LM-ка подправить. То есть есть такие планы, что использовать эту платформу. Здесь еще какая-то проблема с агентами решается. То, что мы имеем единую шину данных. То есть работая моделью на графе, они все в одном формате в него записывают и реагируют на события, которые там появляются. То есть если множество агентов и нужно как-то стыковать, они просто по нужным моделям пишут данные в граф, другие агенты читают эти данные из графа и опять же записывают. То есть это получается некий валидируемый и фиксированный слой. на котором работают агенты, получая данные и возвращая в него. Ну, естественно, либо через ламки, да, или сама ламка может, ну, сама ламка ничего не может читать. Ну, в принципе, через какой-то агент она может читать данные дополнительно из графа. 

S00 [02:04:54]  : Спасибо. И последний вопрос. Планируется ли Вы процесс майнинг по историческим данным событий? Последний вопрос из данного пула. Там еще вопросы будут, я надеюсь, есть еще чуть-чуть времени. Итак, процесс майнинг по историческим данным событий у Вас предполагается? 

S01 [02:05:11]  : Это как бы само собой подразумевается. Сейчас у нас запроса темпорального нет. Но в следующей итерации языка запросов будут запросы, которые будут возвращать в зависимости от последовательности поступления событий. То есть сейчас запросы только актуальные. состоянию. Хотя можно сделать запрос к любому событию, но вот именно отследить последовательность была 1, 2, 3, 4, 5 или 5, 4, 2, 1, пока нет такого запроса, но в принципе можно написать запрос, который будет фиксировать исторические данные, их последовательность, частоту и возвращать какие-то значения в зависимости от Но это больше, наверное, актуально не для запросов, это для аналитики, а для срабатывания самих событий, что можно написать условия. которые по датафлогу архитектуры зависят не только от наличия каких-то данных, а еще предыстории, что они не просто получились, а еще было вот такой-то последовательности пришли данные. Тогда это может быть актуальным событием, которое сработает. То есть это как бы все запланировано, но пока это не столь актуально на данном этапе. 

S00 [02:06:29]  : Понятно. Это, оказывается, был последний вопрос. Тут дальше довольно много комментариев со ссылками от Алексея Незнанова в основном. Коллеги, еще у нас буквально есть 5-10 минут. Если у кого-то есть короткие вопросы или комментарии, то можно голосом включиться и добавить или спросить Александра. 

S01 [02:07:00]  : Могу пока думать, еще одну мысль сказать, которую я не проговорил. Что нам позволяет делать Dataflow архитектура? Это она нам позволяет делать действительно децентрализованные приложения. То есть на современной блокчейне, тот же эфириум, там нет никакой децентрализованных приложений. Здесь обычные приложения, которые просто запускаются на разных узлах. То есть обычное совершенно, я могу его запустить у себя на компьютере и выполнить полностью, децентрализации там никакой нет, там децентрализация идет только по консенсусу, то есть именно по распределенному хранилищу, но само приложение, оно нормально, обычное. А приложение написанное на Dataflow архитектуре, оно может быть действительно децентрализованным не только по исполнению, но и по его созданию. То есть любое дополнение модели бизнес-процесса никак не может сломать эту модель. То есть если работающая модель есть, если дерево работает, ссылаясь на предыдущие события, то добавление любого нового события, работающего на этих событиях, никак сломать не может вообще приложение никаким образом. То есть я могу взять некое приложение, тот же blockchain какой-то, и дать доступ каким-то аналитикам, которые могут, используя вот эти события, которые есть, на которых построены, добавлять еще новые события, которые будут обусловлены, и это никак не повлияет на работу предыдущей версии. То есть новый функционал появится. И он ничего не сломает, и на старом функционале работы он будет продолжать работать так же, как работал, даже не заметить ничего. Но если его повестить, что появилась новая функция, что он посмотрит, да, он может перейти на новую версию модели, либо в своей модели написать то, что будет использовать данные дополнения и другие, которые принесли. То есть это вот безопасность изменения. Полная безопасность дополнения, а вот вопрос с удалением и изменением, там не так прозрачен, там есть свои вопросы, которые нужно решать, но вот дополнением она абсолютно дезинформирована. 

S00 [02:09:13]  : А можно вот тогда... Да, вот вы в самом конце как раз упомянули самую интересную проблему, которую я где-то в начале как раз обращал внимание. Как все-таки с удалением быть в распределенном приложении? 

S01 [02:09:30]  : Ну, сейчас решается двумя способами. Есть события длит. То есть оно приписывается, и по нему также проходит консенсус, он проходит по кластеру, и все удаляются. То есть это обычное событие, то есть как появляется, так и появляется новое событие delete, и оно больше не учитывается ни в запросах, не индексируется в памяти, всего как будто и нет. Это один вариант, он нечасто используется. Другой вариант, что если в свойстве стоит так называемый кардинальный C1, не позволяет множественное значение делать, Актуально учитывается последнее значение. Все предыдущие существуют, есть забор зеленый, красный, синий, черный, белый. Это все последовательность событий. Они друг на друга ссылаются, поскольку они последовательны, и к одному забору имеют отношение. Но при запросе учитывается только последнее. Есть кардинальность 1. Вся история хранится, и тут не нужно особо ничего отслеживать. Да, и тут даже так получается. Я могу в модели поменять кардинальности 1 на кардинальности 0, и у меня сразу все они выпадут, как будто они все актуальны. Но это уже ошибка, если это про забор, то это будет ошибка аналитика, если он ошибется, как знаете. 

S00 [02:11:13]  : Спасибо. Коллеги, есть еще вопросы или комментарии? Нет? Тогда огромное спасибо, Александр. 

S01 [02:11:25]  : Значит, на днях, может завтра, сегодня уже точно не успею. Открываем тестирование свободное. То есть, может, завтра, а может, понедельник сейчас посмотрю. Значит, есть канал Болтси открытый. Вроде как бы я даже добавил ссылку на него, но болти найти легко. И будет закрытый канал для тестировщиков, в котором будет лежать документация, ссылка, и там будет обсуждаться именно вопросы конкретных багов, ничего не достает, так что кто желающий, объявление будет в болт-си канале, я кину, наверное, в Эджер Дашу, а там может быть, или прямо ко мне в личку, чтобы подключил к текстированию. 

S00 [02:12:23]  : Александр, спасибо большое. Просьба прислать ссылку на видео, которое Вы обещали в начале и ссылку на демо-версию, про которую Вы только что сказали. Также большое спасибо Алексею Нюзнанову за вопрос и большое количество ссылок по теме. Я потом выложу лог дискуссии. Можно будет посмотреть, кто не посмотрел логи. Спасибо всем участникам. И через две недели мы в это же время и в этом же месте встречаемся с Егором Чуриловым. Александр, спасибо и успехов. Спасибо всем за очень хорошие вопросы. Всего доброго, всем до свидания. 






https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

## 21 октября - Какие графы нам нужны, какие сети нам важны? Куда ловить данные для AGI и как их хранить - круглый стол - Антон Колонин, Александр Болдачев, Николай Рабчевский — Семинар AGI
[![Watch the video](https://img.youtube.com/vi/90NDhLUDuqs/hqdefault.jpg)](https://youtu.be/90NDhLUDuqs)

Суммаризация семинара:

Семинар посвящен обсуждению темы, связанной с графами, схемами и хранилищами данных в контексте искусственного интеллекта (AGI). Участники семинара обсуждают различные аспекты, включая философию определения причинности событий, эмпирические результаты работы с данными, а также методы описания временных процессов и информации внутри системы.

## Ключевые моменты

1. Философские и технические вопросы
   - Участники обсуждают философские вопросы, связанные с определением причинности и статистической зависимостью между событиями.
   - Внимание уделено техническим аспектам, таким как работа с интервалами вместо абсолютных временных отметок.
   - Обсуждаются различные подходы к описанию временных процессов, включая событийную логику и антологию.

2. Онтологии и универсальность
   - В дискуссии поднимается вопрос о балансе между размером онтологии и универсальностью системы.
   - Участники отмечают, что выбор размера онтологии влияет на писательскую способность и универсальность системы.

3. Генеративные языки и начальные данные
   - Обсуждается вопрос о том, как начальные данные могут быть получены и как они используются для генерации новых данных.
   - Внимание уделено теореме о машине Тюринга и возможности описания любого алгоритма с помощью двух логических операций.

4. Проекты и агенты искусственного интеллекта
   - Участники семинара обсуждают различные проекты, включая обучение языку без учителя и создание персональных агентов.
   - Внимание уделяется вопросам хранения и структурирования данных, а также их применения в различных системах.

5. Временные процессы и информация
   - Обсуждаются различные подходы к представлению временных процессов и информации внутри системы.
   - Участники семинара поднимают вопросы о времени, его измерениях и взаимосвязи времен.






S01 [00:00:15]  : Коллеги, добрый вечер. Сейчас я убеждаюсь, что у нас уже идёт трансляция. Да, трансляция у нас уже идёт. Поэтому позвольте сделать небольшое вступление к нашей теме. Иступление обусловлено тем, что… На самом деле, я не помню, почему мы эту тему решили обсудить. Вообще, мы эту тему обсуждали два раза на семинарах примерно год назад. Так, шоу фуллскрин. Шоу фуллскрин. Вью. Сейчас я сделаю шоу фуллскрин. Почему я не могу сделать вью? Слайдшоу. Вот, это фуллскрин. Да, мы обсуждали ее пару раз в прошлом году. Сколько-то семинаров назад эта тема снова возникла. Соответственно, я ее поставил в план. Но недавно возникло обсуждение у нас в узком кругу, вообще стоит ли эту тему обсуждать. запустил голосование и выяснилось, что довольно существенным большинством голосов предложено было эту тему все-таки обсудить, хотя были недовольные, которые высказывались, что зачем обсуждать и говорить о столь непрактичных вещах, что меня сильно удивило, потому что на самом деле более практичные темы, например, со своей колокольни я не вижу, то есть можно сколько угодно рассуждать о сознании, о мышлении, о том, как они соотносятся. Но в данном случае речь идет о том, что нужно делать все-таки некоторую грязную работу на самом низком уровне абстракции. И как ее делать, в общем, мне непонятно. То есть на те вопросы, которые обсуждались два года назад, я для себя не получил внятных ответов. На сегодняшний день я пытаюсь сделать какие-то ответы, которые я сегодня озвучу, но они для меня самого являются неубедительными. Поэтому, если вдруг кто-то год спустя даст какие-то ответы, которые для меня кажутся внятными, я буду считать, что вообще затея удалась. Ну, может быть, кто-то еще что-нибудь унесет из этой темы более полезное. Итак, речь пойдет о, скажем так, данных, которые искусственному интеллекту, общему искусственному интеллекту надо где-то хранить. Причем я умышленно не говорю о знаниях, я не говорю о понятиях, я говорю просто тупо о данных. Потому что с моей точки зрения, как программист, есть код, есть данные. Кто под MS-DOS Программируя, он знает, что вообще память компьютера делится на две части. Одна часть является кодом, вторая часть является данным. Если случайно мы переместим данные из области кода в область данных или наоборот, то со структурой данных ничего не поменяется. Поменяется просто отношение процессора к ним. Если мы случайно область кода пропишем каким-нибудь массивом, то у нас все сломается. А когда мы компилируем код, то на самом деле он компилируется в области данных, а потом мы просто его записываем в бинарно исполняемый файл. Поэтому я бы сказал так, что у нас есть некоторые биты или байты, или единицы информации, которые мы как-то хотим структурировать для того, чтобы на основе этой информации наш искусственный интеллект что-то делал. А являются ли эти кусочки данных первичными данными или вторичными? Информация ли это? Знание ли это? И какого уровня это знание и информация? А может быть это вообще декларативное знание или процедурное? Это уже вопрос отношения к ним того, так сказать, кода, который эти данные обрабатывает. Но опять-таки, если вспомнить добрый старый ЛИСП, который изначально разрабатывался как язык программирования искусственного интеллекта, там вообще Код и данные – это одно и то же. То есть, все являются списками, и, соответственно, есть исполняемые списки, есть неисполняемые списки, и одно легкое движение в руки превращается в другое. Предположим, что мы хотим делать вот такого вот искусственного агента, у которого есть какие-то фундаментальные знания, на основе которых он строит все свои модели. Мы можем называть это мета-знаниями, то есть это знания о его знаниях, если говорить в терминах знания. Дальше у нас есть какие-то модели, которые описывают реальный мир, в котором этот агент существует. Наконец, есть какие-то данные, которые описывают его события, которые он воспринимает из окружающего мира, и есть какие-то данные, которые фиксируют те действия, которые он направляет в окружающий мир. Я сейчас не буду обсуждать архитектуру этого агента, потому что это было в ряде других докладов. Важно, с моей точки зрения, является то, что если мы говорим об AGI, или ANERU-AGI, чуть-чуть понизив планку и сказав, что у нас не обязательно сразу делать совершенно универсальный искусственный интеллект, тем более мы знаем, что это невозможно. А если мы будем делать какой-то ограниченный искусственный интеллект, например, в рамках задачного подхода, то с моей точки зрения можно считать ограниченным искусственным интеллектом систему, которая, будучи загружена некоторым преконфигурирующим скриптом, например BIOS. Если у нас может быть некоторый BIOS, который будет, например, описывать какую-то базовую или фундаментальную антологию, или какой-то bootstrapping скрипт для какой-то предметной области, допустим, для управления финансами, или для игры в пинг-понг, или для чат-бота, А все остальное на основе этого бутстраппингового скрипта или базовой антологии или базового скрипта будет уже системой дообучаться в режиме реального времени, но при этом как бы физическая реализация будет одна и та же, то на самом деле это, наверное, можно сказать в каком-то смысле общий искусственный интеллект. То есть мы как бы создаем некоторый фреймворк в котором может исполняться любой интеллект на любые случаи жизни, но некоторый базовый слой этого интеллекта мы должны за-хардкодить на начальном уровне, а потом он уже Этому будет обучаться в режиме реального времени. Вот это, мне кажется, основное базовое требование для того, что мы называем общий искусственный интеллект. Если мы хотим его сделать совсем общим, то от нас нужно что? Нам нужно дать возможность эти знания формировать. То есть, мы можем постепенно уменьшать количество фундаментальных знаний, которые мы загружаем в систему при старте, понизив его до минимума. В минимуме может быть только одна цель – не навреди себе и своим сородичам. И все. А все остальное он сам научится. Если его положить на криптобиржу, он будет учиться торговать криптой. А если его загрузить в машину для игры в пинг-понг, он будет учиться играть в пинг-понг. А цель будет одна и та же – получать бонусы и покупать за эти бонусы электричество, чтобы не сдохнуть от отсутствия электричества. Соответственно, значит, мы должны иметь возможность каким-то образом загрузить в него некоторые структурированные данные, которые будут описывать его цели и какие-то правила игры или антологии, в рамках которых он будет, или описать параметры операционного пространства, в которых он будет работать. Соответственно, это вот то, что я здесь обозначил стрелочкой, как структурированный ввод. Он должен иметь возможность модифицировать те знания или данные, которые находятся внутри него для того, чтобы из наблюденных данных строить модели первого уровня абстракции, а из модели первого уровня абстракции строить модели второго уровня абстракции, а потом удалять ненужные данные, а потом, возможно, формировать себе новые цели или подцели на основе имеющихся целей и наблюдений о том, как его поведение в реальном мире влияет на выполнение текущих целей. Ну и, конечно же, эту информацию как-то надо хранить. То есть, собственно, Store – это на самом деле то, с моей точки зрения, о чем было бы интересно поговорить прежде всего. Что интересно, когда мы говорим, прежде чем мы поговорим, вернемся в сторону, что у нас еще требуется? Кроме возможности получать структурированный ввод. Должна быть возможность получать неструктурированный ввод, то есть кроме того, что нам в явном виде отходят там какие-то цели или какие-то задачи, а может быть по ходу действия нас еще поправляют, какой-то дидактический материал. нам дают какие-то правила, которые корректируют наши выученные модели, у нас, естественно, может быть не структурированный. Это видео потоки, аудио потоки, численные данные котировок с биржи, какие-то тексты из социальных сетей, какие-то, я не знаю, данные термометров или метеонаблюдения, которые у нас валятся. Мы должны, возможно, этот не структурированный структурировать, но это уже как бы внутренние работы системы. Ну и, наконец, мы должны иметь возможность каким-то образом осуществлять вывод информации в окружающее пространство, где частым случаем вывода информации в окружающее пространство является приложение информации к нашим экторам или актуаторам, воздействием которых информация о приведении их в действие или выключении их, мы влияем на окружающий мир. Причем я сознательно нарисовал на выход только стрелочку «структурированный вывод», потому что мне кажется, что говоря о выходном потоке действий, Его нет не структурированного. То есть, мы либо встаем, либо садимся. Мы либо говорим, либо молчим. Или нажимаем кнопку, либо нет. До уровня конкретного мускула или конкретного слова, которое мы произносим или нет. В то время как поток, он требует дополнительной структуризации. Но если кому-то очень нравится, можно нарисовать еще одну выходную стрелочку, обозвав ее unstructured output, но я, честно говоря, не понимаю, что это такое будет. Так вот, возвращаясь к проблеме хранения информации. Значит, мозг эту проблему как-то решает, причем унифицированным способом. То есть у нас есть большое количество нейронов, большое количество сегментов мозга, и есть ощущение, что они все хранят информацию единообразно. То есть, нет такого, что кора хранит информацию на файловой системе, мозжечок хранит ее в РДФ-стор, а спинной мозг хранит ее, к примеру, в какой-нибудь реализационной базе данных. Такого нет. То есть, каким-то образом вся наша нервная система хранит информацию каким-то образом, очевидно, распределенным Единообразно. Причем мы пока что не точно знаем как и на каком уровне она хранится. Мы можем выделить по крайней мере четыре уровня, где возможно хранятся какие-то части этой информации. То есть первое это уровень нуклеотидов, кодирующих гены. Второй уровень это уровень аминокислот, которые тоже что-то кодируют. И посылают сигналы друг другу, а также других химических соединений, вроде тех же нейромедиаторов, где букеты нейромедиаторов тоже могут кодировать. Один букет может кодировать одно, другой букет может кодировать другое. Вот эндорфин, замечательный запах, который кодирует все, что на свете. И третий уровень – это у нас, собственно, Последний уровень – это у нас, собственно, структура нейронов, которые, соединяясь друг с другом, тоже формируют какую-то информационную структуру. Каким образом и как это работает, мы пока не знаем, но вроде как больше ничего другого нет. Хотя, кстати, у нас есть в группе достаточно активные участники, которые на полном серьезе считают, что на самом деле информация хранится не в мозге, информация хранится где-то за пределами на каком-то неизвестном пока науке носителе, а мозг является просто приемником-передатчиком. Я это озвучиваю, потому что вот такая точка зрения есть. Итак, вот теперь практические примеры, где какие данные мы имеем и в каком виде мы должны их обрабатывать. Первый пример, который я как раз буду в Сбере рассказывать. Мы пытаемся строить адаптивного агента для активного управления инвестиционными портфелями. Соответственно, в ходе у нас есть как не структурированный ввод в виде новостных потоков и рыночных данных, не структурированный ввод. У нас есть структурированный ввод в виде рыночных данных, то есть это просто транзакции, ордера, которые мы черпаем из баз данных. ну и соответственно информацию которую мы получаем у нас временные ряды у нас то что я называю rich graphs или обогащенные графы но собственно обогащенный граф это как раз транзакция да то есть что такое транзакция транзакция это очень если очень грубо это или триплет между значит типом включающий тип транзакции счет покупателя и счет продавца. Но проблема заключается в том, что счетом покупателя и счетом продавца это не ограничивается, потому что есть еще валюта покупки, есть еще валюта продажи, есть еще дата. И как мы дальше увидим, для того чтобы описать элемент графа в транзакционных данных, нам на самом деле в конечном итоге нужно иметь дело с добрыми старыми отношениями дедушки кода, придумавшего и сформировавшего понятие методы реляционной алгебры. И все становится гораздо веселее. Ну и, наконец, у нас есть статистические модели. Где-то у нас есть коэффициенты линейной регрессии, где-то у нас есть натренированные нейросетки. И это часть того знания, с которым мы хотим работать. И нам нужно модифицировать это все. То есть из одних временных рядов с элементарными показателями мы строим другие временные ряды с более сложными показателями. Из обогащенных графов мы строим упрощенные графы, а также мы строим показатели, основанные на этих графах. После чего мы строим статистические модели, а статистические модели мы тоже на самом деле увязываем в какие-то графы, потому что у нас одни статистические модели подходят для одних инструментов, а другие для других инструментов, и все это еще для разных параметров рынка. И дальше на выход мы должны уже генерировать структурированные данные, либо явные сигналы на какие-то действия, либо уже даже конечные операции, как выставленные ордера и совершенные транзакции. Другой пример. Вот у нас проект, которым мы занимались в SingularityNET, который я сейчас пытаюсь запустить по новой. Если здесь есть люди, заинтересованные в проекте обучения языка без учителя, то можно отдельно эту историю обсуждать. Вот у нас на входе опять-таки есть неструктурированные данные, на основе которых нужно учить грамматики антологии. На входе у нас могут быть какие-то начальные антологии или какие-то символы, являющиеся граундингом для неструктурированных текстов, которые нам будут помогать этот текст структурировать и выяснять, выявлять какие-то закономерности в нем. Ну и по ходу дела мы накапливаем, во-первых, тексты, во-вторых, деревья разбора, антологии, которые нам даются, либо которые формируются в результате обучения, грамматики, которая используется для разборов в рамках этих антологий, ну, опять-таки, статистические модели, которые мы учим применительно к этим корпусам, начиная от каких-то коэффициентов регрессии или частотности и кончая теми же самыми глубокими моделями типа BERT, которые мы использовали на данном этапе. Но операции все те же самые. Единственное, что на выходе мы уже получаем не какие-то сигналы, а мы получаем просто переструктурированные антологии грамматики и, возможно, какие-то тексты, которые на них основаны. Ну и третий пример. Это, опять-таки, мой любимый персональный агент, которым я занимаюсь уже, по-моему, скоро седьмой год. У нас, опять-таки, на входе не структурированный текст, это просто новостные потоки. А в качестве структурированного текста у нас взаимодействие в социальных сетях. А также в онлайн-коммуникациях типа мессенджеров, например, то, что мы делаем в нашей группе, все идет в качестве структурированного и не структурированного ввода на вход агенту, который пытается из этого что-то извлечь. Пока что не очень удачно. Потому что времени нет это дело все оформить. Ну и, соответственно, внутри мы имеем примерно то же самое. Мы имеем тексты, онтологии и два новых вида графа. То есть, на самом деле, и то, и другое – это, можно сказать, богатые графы. Богатые графы с некоторыми специфичностями. Во-первых, есть понятие субъективный граф. То есть, это граф, который имеет смысл только в контексте отдельного человека. То есть, у меня свой коммуникационный граф. Он включает в себя коммуникации всех людей, с которыми я общаюсь в тех группах, которые доступны агенту. А если у Пети Сидорова будет другой граф, который связан с теми группами, в которых он взаимодействует со своими друзьями, которые доступны агенту, и я могу этого вообще не видеть и про это не знать. Где-то коммуникации могут пересекаться, где мы с Петей Сидоровым находимся в одной группе, у нас в части пересекающихся групп у нас графы будут совпадать. но в целом у каждого свой граф коммуникации, модель мира. Так. Чего? Сейчас кого-то секундочку. А, хорошо. Так, можно набьют? Коллеги, можно всех набьют? Пожалуйста. Так, включили. Александра Соколова, продолжаем дальше. Итак, естественно, у нас есть статистические модели, которые мы на основе всего этого учим, а на выходе у нас выходят какие-то тексты, которые агент генерирует, например, summary и дайджесты из новостных потоков, и рекомендации, которые он дает пользователям в части контента или в части других пользователей, с кем нужно подружиться, с кем лучше поссориться. Какого типа у нас данные выявляются на основе рассмотренных случаев? Это тексты, это онтологии, это деревья грамматического разбора, это грамматики, это обогащенные графы с множеством как источников, так и приемников, началом и концом этих связей. Представьте себе РДФ-триплет, у которого тип у связи один, а источник из двух концов два. Вот, причем эти источники имеют один и тот же тип. Кстати, как у финансовой проводки. Если мы возьмем проводку по счетам аналитического учета, то там у нас есть счет дебета и счет кредита, а есть счет аналитического учета. Дальше у нас есть субъективные графы, которые аннотированы конкретным человеком, временные графы, которые имеют привязаны к конкретным временам. То есть, если мы возьмем сумму проводок в один день или транзакции, то и совокупность проводов других денег транзакций, это будет граф, который уникален для конкретного промежутка времени, для часа, минуты или секунды. Например, если мы возьмем один блок транзакций в блокчейне, то вот каждый блок транзакций в блокчейне, он описывает такой вот маленький подграф, который специфичен времени существования и формирования данного блока в блокчейне. Наконец, у нас есть временные ряды. данные, которые хранятся по времени, и статистические модели. Если в виде бинарных файлов с параметрами нейросети, коэффициентами линейной регрессии или коэффициентами сплайнов, Итак, давайте теперь посмотрим, где мы можем хранить всю эту информацию. Статистические модели и тексты, а также временные ряды, а также грамматики формальные, они обычно на сегодняшний день хранятся просто тупо на файловой системе. В крайнем случае, они могут быть запиханы в блобы, хранящиеся в каком-нибудь MySQL, Oracle или Postgres. Если мы возьмем графы, то большинство, антологии, парсы, грамматики, в том числе, они легко заталкиваются в любой Triple Store или NoSQL DB. Рич графами и субъекты графами сложнее, потому что рич графы или субъективные графы, их в обычный граф не заталкаешь, их нужно очень сильно денормализовывать. То есть, каждую связь нужно превращать в вершину, а уже атрибуты этой вершины подвязывать к вершине. И на самом деле, как мы увидим на следующем слайде, это говорит о том, что эту информацию лучше хранить в реляционной форме. Ну и, наконец, сверху всего этого лежит пресловутый гиперграф. Собственно, идея гиперграфа возникла 22 года назад, по крайней мере, в моем сознании, в полном объеме, когда мы проектировали всю эту историю, про которую сейчас говорим. 101 проекта Бена Гюрцеля «Вебмайн». Кстати, это было даже не 22 года назад, а 24 года назад, в 1998 году. И как раз тогда родилось понятие «гиперграф». А зачем нам создавать простые графы с бинарными связями, когда у нас, во-первых, связи могут быть н-арные, А во-вторых, каждая связь может являться не связью, а может являться атомом, который может являться источником другой связи. То есть мы можем связывать атомы, где каждый атом может быть либо унарной связью, то есть просто концептом, вершиной, либо он может быть бинарной связью, которая связывает две вершины. А может быть тернерной связью, которая связывает три вершины и так далее. Собственно, вот идея опенкога и идея гиперграфа опенкога, она как раз очень хорошо это все описывает. То есть, вот классический слайд, достаточно древний слайд, который говорит о том, что в опенкоге мы просто можем выявлять различные слои. На самой правой стороне у нас находится максимально абстрактный слой, где мы храим. Мы храним самые абстрактные концепты, вроде абстрактного стола, абстрактного поднятия руки и абстрактной еды, а на промежуточном уровне мы храним Совершенно конкретные экземпляры столов, например, 754 стол, который мы видели за свою жизнь, или там конкретное поднятие руки. Значит, когда мы 55-й раз за свою жизнь подняли руку, у нас вот отдельный концепт на это дело хранится. Ну а на самом нижнем уровне у нас уже есть совершенно конкретные пикселы, совершенно конкретные звукогармоники аудиосигналов, которые мы слышим. Примерно в том ключе, как это рассказывал Лайнесс на своем докладе на нашем воркшопе 15-го числа. Ну и в этом смысле все получается единообразно и регулярно, то есть ровно таким образом единообразно и регулярно хранит информацию мозг. Таким образом мы можем считать, что с точки зрения хранения данных и регулярности представления любых данных в единообразной модели. Мы имитируем архитектуру человеческого мозга, что по себе хорошо. Здесь показана концепция того, что такое гиперграф. Я год назад про это рассказывал. Можно посмотреть видео прошлогоднее. Я сейчас просто коротко упомяну, что мы можем строить любые хитерархии те концептов не иерархия хитерархии потому что у нас одна и та же вершина вот допустим которая здесь сетлинк это вот одна такая вершина которая объединяет множество других вершин под вершиной подразумевается атом да то есть у нас атом это все что угодно это концепт это бинарная связь это тернарная связь это последовательность это сет все это является атомом да и у нас любой атом может быть быть элементом любого другого числа атомов любой арности. Ну и здесь примеры разных арностей. Например, есть бинарный концепт inheritance link, который связывает некоторое облако концептов, set link в данном случае, с концептом география. Соответственно, все, что находится в этом сером облаке, это является предметами изучения географии. А тут в этом сетлинке есть еще два эндлинга. Эндлинг – это объединение некоторых концептов по условию. Допустим, влажность воздуха, повышенная влажность и низкое давление, объединенные вместе через эндлинг – это некоторые природные явления, которые связаны бинарной связью с другим природным явлением. в серой связи, в другом светло-сером облаке. Это природное явление предподразумевает наличие тумана и некоторые причинно-следственные связи облака, потом дождя, потом наводнения, которые соединяются тернерной связью последовательности. То есть, это связь, которая обозначает временную последовательность некоторых событий. Проблема в чем? Проблема в том, что на самом деле, когда мы понимаем, что мы сделали с этим OpenCog, мы обнаруживаем, что мы просто переизобрели реализационную базу данных. То есть я очень хорошо это почувствовал, когда 15 лет я не работал с Беном, а в 2017 году я вернулся к работе с ним, они к тому моменту выхватили как раз, у них уже была рабочая версия OpenCode, и я стал разбираться о том, как Lingramr Собственно, работа грамматика связи Lingrammer хранится в OpenCog. С помощью обычных графов грамматика Lingrammer не описывается. Опять-таки, это можно посмотреть наш доклад и доклад Лайнесса с воркшопа. по интерпретируемой обработке естественного языка, где он рассказывает, что такое линграммар, но с графами это не описывается. Но это описывается гиперграфами. И вот здесь вот я пытался распутать в 1917 году, как это описывается как раз гиперграфами Опонкога, и на самом деле я в какой-то момент понял, что я просто делаю, что делается обычно, когда приходишь на новый проект и разбираешься, как устроена реализационная база данных. То есть просто воссоздаешь антипериловший шип-модел для конкретной предметной области Другой пример того, как это могло быть реализовано. Когда я проект E-agency свой затевал, я долго самомучился понять, с чего начать. И был большой соблазн просто сделать свою версию OpenCog, потому что OpenCog к тому моменту был, во-первых, непригоден для промышленного использования, во-вторых, интерфейс к нему был на SCIM. а мне нужно было запускать мобильное приложение на Java на мобильном телефоне, куда исполнительный модуль Schema никаким образом не пролазил. Ну и в какой-то момент я все-таки решил, что нет, гиперграфа мы делать не будем, но возникло необходимо все-таки создать то, что я называю сегментированный граф, где мы можем создавать некоторую сетку графов, индексируемых либо по времени, либо по персонам. То есть мы можем создавать множество простых тернерных графов или триплетов, где с одной стороны каждый триплет достаточно простой, то в нем есть как бы источник, назначение и тип. Или там from to type, или там subject, object, verb. То есть как бы обычные триплеты, но Мы можем это облако триплетов сегментировать либо по времени, либо по субъекту, к которому этот граф относится. Второе дополнение – это то, что на каждую ребро в этом триплете помимо того, что оно имеет тип, может навешиваться нечто. Вот где нечто является в общем случае объектом, где частным случаем объекта является либо число, которое может иметь разный смысл в зависимости от типа графа, либо вес, либо вероятность, либо число лайков. Допустим, вес вероятностной связи или вес какой-то условной связи, вероятность вероятностной связи, amount какой-то финансовой транзакции. Или это может быть пара значений, если мы описываем связь в терминах неаксиматической логики переванга. Или это может быть пара количества и числа. сумма и количество, если мы описываем финансовую транзакцию, или это может быть сумма и валюта, если мы описываем финансовую транзакцию в конкретной валюте, или это вообще может быть какой-то абстрактный объект, каким-то образом интерпретированный. Но на практике такая схема все равно имеет ограничения, потому что если мы сегментировали систему по времени, мы ее не можем сегментировать одновременно по субъекту. А если мы ее сегментировали по субъекту, мы не можем ее сегментировать по времени. А если нам нужно сегментировать систему и одновременно по субъекту, и одновременно по времени, то у нас эта система уже не работает. Мы должны вручную смерживать графы по субъектной оси, а потом разбирать их на подграфы по временной оси. Это очень дорогостоящая операция. Ну и, собственно, вывод, к которому я все больше и больше прихожу с практической точки зрения, я уже закругляюсь, что в конечном итоге все это кончается в доброй старой религиозной алгебре, где, в общем, любое явление Мы описываем на самом деле не какими-то связями, мы описываем на самом деле просто каждое явление написывается некоторым отношением, или это описывается некоторой точкой в векторном пространстве, где измерение – это те, собственно, параметры тех событий, которые мы хотим изучать. И, соответственно, все, что нам нужно сделать на уровне некоторого гипотетического хранилища, это способность работы с разреженными пространствами, где измерения этого пространства заданы изначально, где мы можем добавлять измерения в это векторное пространство, а уж вопросы эффективности работы по конкретным изменениям в этом векторном пространстве они должны определяться на каком-то отдельном слое, который, вообще говоря, абстрагируется от, собственно, самой вот модели, самого набора вот этих вот измерений. Вот. Ну, кстати, вот здесь вот внизу как раз показано, что, с одной стороны, мы, так сказать, можем иметь нормализованное представление информации, да, где, так сказать, упоминание Джона со стороны Мэри Кей – это вроде как связь, да, И мы можем это закодировать RDF-трайплом, да? Mention John to Mary. Или платеж от Джона к Мэри тоже вроде как может быть закодирован в РДФ триплетом, где у нас платеж является простой связью. Но поскольку у нас и платежи, и упоминания не могут иметь разные параметры, например, упоминание может иметь определенное количество, может быть определенное число упоминаний, а контекст может быть связан с какой-то группой, например, в группе AGI могут быть одни упоминания, а в группе Collective Intelligence могут быть другие упоминания. А платёж он вообще может быть в разных криптовалютах или валютах. То в конечном итоге нам это всё нужно раскладывать либо на реляции, либо расписывать это на полностью нормализованный граф, как показано с правой стороны. Итак, вот те вопросы, собственно, больные, на которые хочется понять, кто как отвечает в своих проектах. какой-то опыт работы в прикладных проектах. Первое – время. Как мы храним время? Либо это у нас просто в базе данных хранятся реляции, и мы индексируем по полю timestamp. Либо мы в RDF заводим линки, специальные и привязываем. У нас есть тип концепта «время» и мы линками типа «время» привязываем вершины, которые описывают события. Либо мы опять-таки в рамках CRDF Store Мы просто атрибут «время» навешиваем на линк и уже дополнительно фильтруем эти связи по атрибуту «время». То есть, у нас время является не типом связи, а время является атрибутом связи. Где мы храним вероятности? Например, в НАРСИ вероятность – это атрибут связи. Когда мы говорили о языках, это упоминалось. У нас НАРСИ время является не только элементом выражения, описывающим любую связь, оно предполагается, что и хранится вместе со связью. Или же вероятность, Просто это некоторый концепт, который типизированной связью привязывается. То есть у нас в TripleStory есть связь типа вероятность, и мы эту вероятность подвязываем к любой вершине, которая описывает отношение, которое должно характеризоваться какой-то вероятностью. Ну либо опять мы вероятность заталкиваем просто в атрибуты линков. Где хранить субъективность? Опять-таки, либо у нас индексируем базу данных по какому-то контексту, который указывает на пользователя или потребителя или кооператора, любую именованную сущность, либо это какие-то у нас тип связи субъект или персона, либо это у нас заталкиваем ID-шник пользователя или кастомера в или какого угодно субъекта в атрибуты самой связи. Как представлять процессы и диаграммы? Опять-таки, то ли мы храним в декларативном виде, декомпозируем любое процедурное знание в виде какого-то семантического графа, а потом, когда его надо исполнять, либо генерируем исполняемый код, либо интерпретируем сам граф. Как вот, например, в движке, которым занимается Дмитрий Иванович Свериденко с Евгением Витяевым. Либо мы храним исходные коды, как, например, на LISP делается. В LISP мы храним, по сути, исходный код программы, которую исполняем по ходу дела. Либо мы компилируем бинарный код. То есть, либо у нас в бинарном коде каким-то образом все компилируется. Как, например, в Java. То есть, в Java мы можем на лету создать какой-нибудь класс и через рефлекшн сделать его исполняемым. Дальше. Нужны ли нам графы или метаграфы? Первый вариант ответа – да. Опенкок – это крутая вещь. Сейчас товарищи из Singularity.net и уважаемые спонсоры делают очередной рефакторинг. Может быть, после рефакторинга им можно будет пользоваться. Или мы эти графы и метаграфы просто громоздим на базу любой революционной базы данных, либо мы это заталкиваем на поверх графической базы данных, либо мы просто все работаем с обычными трипл-сторами, как есть. Где мы храним модели? Либо бинарии из сериализованной файлы на файловой системе, либо заоблобы в рельсионных базах данных, либо мы каким-то образом их просто разворачиваем и заталкиваем в графы. Нужны ли нам транзакции? Либо мы считаем, что искусственному интеллекту транзакции не нужны. Это слишком большие накладные расходы. Подумаешь, что-то забыл. С людьми же тоже бывает. Мы же AGI делаем, а не транзакционную систему. Забыл так забыл. Зачем нам весь этот overhead с транзакциями? Вариант нет, что все-таки транзакции нужны. Давайте все-таки у нас все консистентно будет. Как вариант, можно сделать это опцией, как часто делают в приложениях. Ну и, наконец, что делать? Либо ждать, когда кто-нибудь сделает опингок или что-то подобное, либо делать некоторую надстройку над реляционными базами данных и сверху генерить какой-нибудь маппинг, который будет отображать вот это разреженное векторное пространство в заданную RDBMS. Ну, либо, значит, инженирить это в зависимости от каждого конкретного случая. Но вот последняя опция – это будет, по-моему, не про AGI, а про какие-то костыли для конкретных приложений. Все. Спасибо за внимание. Извиняюсь, что отнял много времени. И если у нас есть Михаил Ишенин, который обещал к нам подключиться, то мне хотелось бы, чтобы он высказался. Михаил, вы с нами? Так, Михаила нету. Так, раз Михаила нету, тогда давайте посмотрим. Михаил сказал, что он подойдет, но может в какой-то момент отойти, потому что у него какое-то другое мероприятие. Так, у нас Александр Балдачев и Николай Робчевский еще хотели высказаться. Пожалуйста, Александр. Александр, вас не слышно. 

S02 [00:39:35]  : Да-да-да, я забыл. 

S01 [00:39:36]  : И, Александр, вопрос. Мне нужно вопросы вывести на экран? Или не нужно? Или у вас своё будет? 

S02 [00:39:42]  : У меня вопросы эти есть. Дайте мне экран, я их сам себе и выведу. Да, давайте. То есть, экран у меня доступен, да? Ага, я думаю. Так, экран. Делюсь. И вопросы у меня. Вот здесь есть они написаны. Хорошо. Так, сейчас я отключу. У меня здесь Telegram. Как раз то, о чем я буду рассказывать. Программист сейчас бомбит меня вопросами по реализации. Значит, давайте начнем с того, что все-таки Я предлагаю кардинальное решение всех этих вопросов, один ответ на все эти вопросы. Я уже год назад рассказывал о своих разработках, и теоретических, и практических, под общим названием субъектно-событийный подход, или сейчас это называется event-flow-архитектура. Где-то месяца два вышла статья, можно посмотреть где-то в архиве, она хранится в группе. Основной ответ на все эти вопросы, что мы всегда имеем дело с деятельностью, с неким действием, с неким потоком действий. с некими процессами, которые организуют действия, и с множеством действий, которые формируются, организуются или представляют какую-то деятельность. И всегда любую деятельность, любое действие является просто представлением борща, либо является мышлением. Мышление тоже деятельность, оно состоит из потока событий. То есть это исходное понятие, что да, если мы зафиксируем все события, ну, скажем, здесь важно то, что нужно фиксировать значимые события. Мы не должны, скажем, на производстве фиксировать каждое движение напильника. То есть достаточно зафиксировать, скажем, производство деталей. Если мы делаем модель на уровне более высоком, достаточно отгрузку деталей. Если еще выше, в зависимости от уровня описания, мы можем иметь под событиями различные изменения, фиксируемые различные события. И если мы это сделаем, если мы зафиксируем в виде потока событий какую-то деятельность, запишем их в виде графа, где каждое какое-то событие инициирует другое событие, следующее событие инициируется предыдущими событиями, то, по сути, у нас будет полное описание действия или деятельности в целом. И здесь ответ возникает сразу же, как мы должны хранить эти события. Эти события мы должны хранить в этом же графе, который образуют эти события. То есть ничего изобретать не нужно. Если есть некое событие, деятельность производства печатного макета в издательстве, Гриша сделал картинку. 10 событий зафиксировали. Маша редактировала текст. принесла текст, то есть тоже одно событие. Вася приступает к формированию макета, и мы фиксируем, что у него должно быть прийти сколько-то событий для начала, записываем условия, условия в его событии, когда он должен приступить к началу макетирования, когда будут картинки, когда будет текст, и фиксируем это как событие. Когда он завершит макетирование, это будет новое событие, макет готов, и уже дальнейшие деятели, акторы, будут ориентироваться на это событие, делать свои события. То есть в виде предметного графа в котором фиксируются все события, мы записываем все данные. Все данные. Никаких данных, кроме событий, нет. Если мы фиксируем, что забор красного цвета – это событие, зафиксировали забор красного цвета. Если мы зафиксировали, что Вася произвел деталь номер 25, мы зафиксировали, что Вася произвел деталь номер 25. При этом существенно, что каждое событие всегда исходно привязано к субъекту, к актеру. Это проблема Антона. Где нам выходить актеров? То есть ни одно событие не может быть зафиксировано без указания того, кто является актером этого события. Либо он его зафиксировал, или он его произвел, это событие. И мы имеем вот такой формат события записи. Событие есть ID. у каждого события, обычно это будет хэш, чтобы уникальный идентификатор. Что происходит? Записывается триплетом. Этот триплет не является Родеговским триплетом в явном виде, хотя он действительно триплет. Он указывает, на каком событии зафиксировано это событие. То есть здесь решаются вопросы номерных свойств. Скажем, если мы зафиксировали, что температура у Пети 37 градусов, это событие, мы на этом же событии можем зафиксировать, что температура растет. Это следующее событие будет. Температура растет. И на событии температура растет, можем зафиксировать, растет медленно. И так далее. То есть н-арность событий заложена исходно в самом формате. То есть мы на каком-то событии basic event фиксируем некий тип событий и его значения. Существенным элементом фиксации событий является, конечно, то условие, при котором должно совершиться событие. Здесь важно, в отличие, скажем, от текущего описания бизнес-процессов, что мы не предписываем, что должно произойти после данного события. То есть нет развилки этого вентиля, в котором мы говорим, что если будет что-то, то пойдет туда, если будет что-то, то пойдет туда. Мы переворачиваем эту логику и фиксируем, что при каких условиях произойдет это событие. То есть, как я уже говорил, Вася принес картинки, Маша принесла текст. Этого достаточно для того, чтобы я начал вырастать. Что произойдет после того, как я закончу, – это уже дела последующих событий. И в событие включается актор, и фиксируется время события. Но можно фиксировать два времени события. Время самого генерации событий, время записи транзакции в хранилище. Но со временем здесь отношения другие. То есть, по сути, это запрещенный прием фиксации времени, когда у нас множество акторов с множеством часов, и тем более, если система распределенная. Поэтому время в данной системе фиксируется только относительно предыдущих и последующих событий, раньше-позже. И вся система не является однозначной упорядоченной по времени, частично упорядоченной во времени, имеется только по веткам. То есть если мы рассматриваем некоторую ветку, то в этой ветке события точно упорядочены по времени. Относительно других веток нельзя сказать. И если нам нужно действительно синхронизировать какие-то процессы по времени, времени, то мы должны либо свести к какому-то одному событию, которое зафиксирует, закончить все ветки, либо вводить специальные события, оракул, скажем, мировое время, вводится событие, относительно него фиксируются другие события. Так, значит, в итоге что мы имеем? В итоге мы имеем граф, двойной граф. Вот эта картинка показывает, как выглядит, как хранится в реальном хранилище этот граф. В этом графе есть связи, серенькие связи. Это связи между объектами. Это граф голосования. Вот есть моделька, реальная действующая модель, и вот граф, который был построен по действующей модели. Если мы завели индивид Voicing1, то к этому голосованию будут привязаны поинты. Будут поинты. К поинтам будут привязаны конкретные голосования. Это будет объектный граф, который фиксирует отношения между сущностями, отношения между свойствами и сущностями. А вот синеньким обозначен темпоральный граф. Он говорит, что вот это событие возможно только тогда, когда статус «старт» и когда Иванов имеет статус «войтер», то есть роль «войтер». Связи условные, они синенькими прописаны. По сути, мы имеем два графа, обложенных один в другой. И можем делать запросы либо по предметному графу, скажем, можем сделать запрос, когда Иванов, то есть по каким пунктам голосовал Иванов в таких-то голосованиях. Это объектный граф. Или можем сделать по темпоральному графу, то есть при каких условиях было совершено вот это событие, и отследить эти условия на глубину, какую нам нужна. Выглядит реально этот граф вот таким образом. Это рабочий граф. Вот таким образом. Сейчас он хранится просто в table и запросы делаются к нему тупо по запросам по значениям type value, basic value, value. Но при увеличении его размера, скорее всего, придется делать дополнительные таблицы и поддерживать их консистенцию относительно событийного графа. То есть событийный граф содержит все данные, все данные о деятельности в некой системе, и возможно сделать еще отдельный граф, скажем, объектный, который поддерживает состояние системы, то есть отношения и связи, и отдельные может какие-то таблицы для ускорения доступа, скажем, к каким-то реестрам, которые тоже хранятся в виде событий. Как хранятся модели исполняемые? Они хранятся в этом же графе, то есть вот исполняемая модель, Вот модель исполняемая анахра записывается в таком же событийном формате, прописывая условия, когда должны совершиться какие-то события. То есть, по сути, здесь получается полная система, то есть только указав обусловленность выполнения событий, мы можем реализовать любой алгоритм. Здесь я хочу показать, откуда вообще растут ноги этой системы. Это значит у нас, если вы знакомы, что у нас есть наши компьютеры, работают на архитектуре Control Flow, машины Неймана. То есть, когда каждая последующая операция выполняется по завершению предыдущей. Так идет по алгоритмам. Но еще где-то в 80-х, даже в 70-х годах прошлого века был развит другой подход, дата-флова подход, когда каждая операция в компьютере выполняется по готовности данных. Вот это типичная картинка для dataflow архитектуры. У нас есть некое выражение математическое, которое можно рассчитать. Есть исходные значения. Математическое выражение расписывается в граф. по независимым выполнениям действий. Как только пришли два значения x и y, выполняется суммирование. Как пришло z, выполняется все выражение. И таким образом асинхронно, параллельно выполняются данные в компьютерах на дата-флоу-архитектуре. Они есть, такие компьютеры. Ими серьезно занимаются у нас в стране. но у них есть свои недостатки, поэтому они до сих пор не получили большого развития, хотя используются в различных микроконтроллерах, то есть используется эта Flow-архитектура. А вот Event Flow-архитектура. Она действует по тому же принципу, как я сказал. То есть есть некое событие, которое совершается при наличии условия, скажем, другое событие, которое совершается при событии условия 4 и 3. Существенное отличие от Dataflow архитектуры в том, что каждое событие не знает, не посылает токен к следующему узлу. То есть вот это событие не знает о наличии вот этого узла, этого, вообще не знает, но просто сработало и сработало, записало данные. То есть при срабатывании события модельного записывается данный в граф. И уже остальные события следят за наличием этого предшествующего, обуславливающего события, выполняются или не выполняются при выполнении условий. То есть если у нас в Dataflow Если результат записывается только в конце, а передаются токены, то результатом работы event flow модели является предметный граф, в котором зафиксирована вся последовательность действий. Давайте еще к вопросикам вернемся. Как хранить время? Никак не хранить время. Сам граф распределен во времени и фиксирует раньше-позже события. Нужны ли гиперграфы и метрографы? Да, они получаются автоматически, если мы моделируем педагогическую учебную деятельность в каком-то ВУЗе. то естественно, что есть несколько уровней событий. Есть уровень событий, скажем, лекции, занятий лабораторных. Есть уровень событий зачетов. Есть уровень событий экзаменов курсовых. И есть два события, к которым можно свести все эти события. Это значит, поступил в МУС, получил диплом. И, естественно, это образует некий уровень, иерархический граф, то есть когда мы можем переходить с уровня на уровень, и есть разработана система, когда мы можем очищать граф от событий нижнего уровня. Скажем, вот у нас есть накопились события относительно экзаменов, То есть они все заканчиваются событием получения диплома, мы выносим это событие за пределы этого графа и вкладываем в граф верхнего уровня, а нижний архивируем. То есть мы всегда можем к нему обратиться, к нижнеуровневому графу, но он не отягощает, мы его в принципе можем отключить от нашего графа рабочего, но при этом целостность графа сохраняется. Значит, что еще там вопросы какие у нас были? Как представляются процессы программы этими же событиями, то есть модель, которая генерирует предметный граф, она сама является событийным графом. Если посмотреть, как она выглядит, то приблизительно вот такой код модели. То есть это те же события, которые записаны, то есть это рабочий код, Вот этой модельке. Что мы еще есть? А, модели хранятся. Какие базы данных годятся? Это нужно смотреть. То есть, скажем, если мы работаем с устройством пользователя, тем же мобильником или ноутбуком, то там достаточно может быть даже хранилище браузера, как сейчас у меня и работает. в хранилище браузера. Если это какой-то крупный реестр, то там должны быть специализированные базы данных. И в проекте, который на этом движке, Event Cloud движке, я делал proof-concept для компании, Зимой профконцепт делал для крупной компании Екатеринбургской по безопасности. Там подразумевалось, что будет несколько типов базы данных, будет и k-value, и графовая база данных, и используется хранилище кавки для обработки большого потопа событий. То есть этот proof-of-concept был принят, разработан. Что интересно, когда я год назад говорил, того еще не было, что на этом proof-of-concept я столкнулся с конкурентом компании, которая занимается RDF-овскими системами. И у нас было одно и то же ТЗ. Это же ТЗ, который я реализовал в браузере, и содержала… сам граф, сама модель содержала где-то около 100, ну, полторы сотни событий, то реализованная на RDF эта система подразумевала запуска два сервера, два сервака должны быть запущены, а на одном не работало, и под десяток тысяч записей. То есть вот такое различие, и, естественно, компания выбрала… мой вариант, но пока он еще бесит, болтается в виде возможного развития, но именно как концепт он был принят и оплачен, то есть это была платная работа. Сейчас я с программистом делаю вторую версию, уже пилотную, в которой помимо простых отношений, Событие есть математические расчеты, то есть можно сделать условия по значениям события, рассчитать какие-то значения, и куча-куча много различных. Вот так выглядит генезис граф новой версии, то есть это исходная базовая модель. То есть базовые примитивы – 109 событий. 109 событий достаточно для того, чтобы смоделировать любую деятельность. То есть дальнейшее моделирование деятельности, оно заключается в введении атрибутов, отношений, отношения отношений и так далее, в сущности. Значит, да, я делал акцент в начале, но думаю, что нужно повторить, что эта система, Event Flow архитектура, она предназначена для моделирования деятельности. И в данном случае мышление я рассматриваю как деятельность. То есть то, что оно можно применить для всяких моделирования бизнес-процессов или процессов обработки событий безопасности – это естественно. Но дальнейшее развитие этой архитектуры позволит по моим расчетам, надеждам моделировать деятельность, а это, по сути, и есть агент. Хотя я для себя решил и всем бы тоже рекомендовал не использовать термин «интеллект», чтобы не путаться, то есть не вводить в людей заблуждение, достаточно просто говорить о функциональном мышлении, который обеспечивает все интеллектуальные функции. Если нет мышления, то это уже не интеллект. Я, наверное, уложился довольно коротко, все-таки не 40 минут. 

S01 [01:00:12]  : Да, Александр, большое спасибо, что уложились коротко, и поэтому будет время ответить на вопросы. Я единственное коротко скажу, что вот по тем за комментарием и вопросом, которые в мой адрес поступили, то, что Алекс Бур написал, я практически совсем либо согласен, либо, по-моему, это отвечает очень хорошо на то, что я спрашивал, и близко. Не могу сказать, что я этим удовлетворен, но подкрепляет мои сомнения. Александр Соколов, то, что вы спрашиваете, как я уже сказал, мы не будем сегодня дебатировать по поводу того, чем информация отличается от данных, и как это связано с мыслительными процессами. Мы сегодня говорим об очень скучных технических вопросах, от которых вы, наверное, далеки практически. Теперь по поводу вопросов к Александру. К Александру от меня и от Кентбура. Я тут перемешку буду задавать вопросы. Во-первых, Александр, я правильно понимаю, что поскольку вы относительно жестко отдаёте задаете сейчас вот эту схему для описания деятельности, то можно сказать, что ваша система это некоторый narrow AGI для тех задач, где требуется именно работа с процессами. То есть, допустим, с помощью вашей системы задачу Разбора обучения языку описать, наверное, не получится, потому что там, например, время не имеет смысла, когда мы разбираем какой-то корпус текстов и пытаемся излечь из-за него закономерности. Я могу сказать, что это у вас NeuroAGI для описания деятельности. 

S02 [01:01:55]  : Любые виды деятельности. Языковая деятельность – это тоже деятельность. И если говорить о работе с текстом, то здесь очень существенный момент связан именно с событийной логикой и с событийной антологией. То есть я могу пояснить на простом примере, скажем, как можно декомпозировать текст в событийную запись. Основная проблема при анализе текста возникает тогда, когда мы работаем с множеством субъектов и работаем с разными временами. То есть разбираем предложение, которое сказано было о будущем, сказано в прошлом, а упоминается сейчас. И вот анализ вот этих предложений очень сложен. И событийная логика, и событийный подход, он предлагает отказаться вообще от времени и записывать в последовательном потоке событий все, что происходит. Мы можем взять текст, выделить из него события и разместить эти события в последовательность, как они обуславливают друг друга, именно как они происходили. В дальнейшем мы можем на этом потоке формировать уже языковые выражения, то есть мы можем выбрать точку, относительно какого события мы можем говорить, что мы размещаем себя в событии. Я в прошлом году был на курорте, и когда я был на курорте, тогда случилось то-то, или позже случилось то-то. То есть я могу оперировать с событиями относительно каждой точки в этом графе. Поэтому здесь языковая деятельность как бы построена на этом графе. То есть мы можем сказать, что у нас в голове, условно так, существует вот этот событийный граф, и каждый раз, когда мы хотим что-то сказать, что-то сказать, мы его трансформируем в предложение, которое уже построено по правилам языка, где есть соотношения временные и оценочные какие-то. Но исходно в самом событийном потоке этого не было. И вот, скажем, можно придумать такой кейс, когда мы декомпозируем текст на событийный поток, А потом его переводим уже на любой язык, и притом не столько на его язык, именно как перевод литературный, чтобы соблюсти там высший литературный перевод, обязательно должен быть соблюден все времена, от первого лица, от не первого лица, а перевести вообще на любой язык анализы, на любой язык уровня анализа. То есть либо это ребенок может рассказать об этом, либо это будет научная статья. То есть это очень существенно. И мышление у нас строится на декомпозированном тексте. а не на тексте, который… То есть мы не читаем учебник, мы не запоминаем, как в учебнике, предложение, а мы запоминаем структуру событий, вот этот граф, который там заложен был в учебнике в последнем, и работаем с этим графом, мы его строим, а не с предложениями. Именно, скажем так, понимание – это способ… То есть запомнить знание – это запомнить предложение и пользоваться ими, вот правилами, а понять – это декомпозировать на событийном уровне. на уровне потопа событий, который является по сути потопом понятий. 

S01 [01:05:16]  : Хорошо. Спасибо, Александр. Еще блок вопросов от нас с Алексом Буром. Кстати, по поводу времени Алекс Бур тут с вами как раз уже в чате согласился с вашей аргументацией. По поводу акторов. А почему всегда один, а с другой стороны нужен ли он вообще? Или может быть их много? Я просто приведу примеры. Например, вы говорите о мышлении. С помощью этой деятельности, с помощью вашей модели мы можем описывать мышление. А вот если я описываю свое собственное мышление, то кто у меня актор? Актор всегда буду я сам. Да, конечно. Окей. Дальше. А если я описываю финансовые проводки, то проводка от Васи к Пете, то тут актор кто? Человек, который эту проводку выполнил? 

S02 [01:06:05]  : Нет, смотрите. Всегда есть пользователь и актор. Пользователь тот, который его занесет. Скажем, если врач совершил некую операцию с пациентом, он актер, изменивший нечто пациенте или замеривший что-то. А есть медсестра, которая сидит, которая занесет. Поэтому я вот сейчас не внес еще юзера, но, скорее всего, он будет, потому что он будет подписывать своим плечом. То есть есть некая разница – юзер, который внес, и актер, который выполнил или зафиксировал. И здесь существенно, почему существенно фиксировать акторов. Может, в какой-то деятельности можно захардкодить актора абсолютного. То есть я, например, сейчас работаю с моделями, я особо не обращаю иногда. Но в большинстве случаев это важно. Прежде всего, есть разные мнения. То есть нужно зафиксировать… А в одном и том же событии, если три человека его фиксируют, то есть нужно зафиксировать три события. И этот именно актор должен зафиксировать. Скажем, есть разные датчики, которые фиксируют одну и ту же температуру. Тоже должен именно конкретный датчик, который со своим плечом подпишет событие, которое он послал. И плюс есть еще такой момент интересный. Когда вы, Антон, говорили, что у нас есть субъектные онтологии, то есть если мы фиксируем все события, которые связаны с неким актером, он их зафиксировал либо выполнил, то мы можем одним запросом получить, вытянуть всю онтологию этого актера в данной деятельности. Все, что он совершил… У нас есть Петров такой. А ну-ка посмотрим, что он фиксировал и что он делал. И мы, сделав запрос, мы получим все события, которые Петров… И при этом эти события можно проанализировать, как они связаны темпорально, как они связаны через объектные связи. То есть это принципиальнейший момент для событийной онтологии – кто зафиксировал события. 

S01 [01:08:08]  : Спасибо. Мы ещё вернёмся к акторам, потому что тут есть блок вопросов от Виктора Казариного. Но сначала попросил бы Алекс Сабура. Алекс, у вас по актору есть что сказать? Ответил Александр на ваши вопросы? 

S04 [01:08:26]  : Добрый вечер. Понимаете, какая штука? Вообще говоря, путаница достаточно большая. Очень большая. Во-первых, Правильно говорится сначала, что всё, есть процессы, и эти процессы мы можем представлять только как последовательность состояний. Некие состояния мы фиксируем и называем их событиями. Всё это правильно, всё это верно. И вот эти последовательности... это я говорю, что это последовательность событий, да, это, по сути дела, частично упорядоченная граф, решетка математическая. Некоторые веточки могут быть одновременно, некоторые не одновременно, узлы событий и так далее. Тайны стампы, конечно, нужны, там стайпы стампы обязательны. В каждом узле должны быть таймстампы. Как именно они ставятся, зависит от преследуемых целей. Естественно, по числам этого узла или по числам субъекта. Надо ли события привязывать к субъектам, зависит от цели. Некоторые события можно привязывать к субъектам, некоторые нельзя. Субъекта нету на месте, он не может фиксировать события, и что не было событий, ну и так далее. 

S02 [01:09:51]  : Хорошо, я отвечу. Не может быть события зафиксированы никем. Субъект, а актором являются и программный агент, и датчик. Вот кто зафиксировал события, тот и является актором, это не обязательно человек. И при этом очень существенно, потому что, скажем, датчики могут иметь разную настройку, акторы могут иметь разные мнения, и поэтому всегда... Скажем так, это вопрос сущностной онтологии, вообще такой, самой глубинной. Нет вообще события как такового, вообще нет. Есть события только фиксации чего-то актором. Вот если кто-то что-то зафиксировал, то и значимо. То есть, скажем, если что-то произошло, и этого никто не зафиксировал, это незначимо для данной деятельности. 

S04 [01:10:39]  : Вполне может быть значимо для данной деятельности. 

S03 [01:10:43]  : Датчик, например… Хорошо, коллеги. 

S04 [01:10:45]  : Я говорить не буду, конечно, дальше. Да, я понял. Алекс, вы прослушали самое главное. 

S02 [01:10:50]  : Датчик – это тоже актор. Не может быть ничего зафиксировано без актера. 

S04 [01:11:02]  : Ну, то есть, не смотрим на Луну, Луны нет, да? 

S01 [01:11:04]  : Хорошо, коллеги, давайте все-таки, значит, здесь Николай Рабчевский уже делает замечание, что мы удалились от темы главного вопроса, как хранить данные. Поэтому давайте все-таки закончим с вопросом Александру. Во-первых, вот у меня, собственно, вопрос как раз по теме. Я правильно понял, исходя что вы сказали, что вы фиксируете определенную модель, которая с вашей точки зрения является универсальной. И на самом деле мне ваша позиция близка с точностью до тех вопросов, которые с Александром Буром обсуждаем. И вы предполагаете, что вот эту фиксированную модель вы можете отображать на различные хранилища. Где-то вы это все в хранилище браузера, Там, я насколько понимаю, KeyValue Store используется. Либо вы это на реализационную, либо где-то вы в какой-то задаче до Postgres это мапите, где-то вы это можете на какой-то TripleStore мапить, где-то это вообще у Mongo может сливаться, но это уже вопрос реализации конкретного приложения. Правильно? 

S02 [01:12:12]  : То есть сам граф, как есть, здесь нужно выбрать. Скорее всего, это будет K-value, либо специальные базы данных, которые хранят для последовательности. Скорее всего, это будет что-то более-менее универсальное, и сам граф всегда должен быть в нетронутом виде. Он, естественно, разделен на ветви. То есть для каждой модели своя ветвь, поэтому нет никакой необходимости хранить все на каждом узле, на каждом устройстве. На каждом устройстве хранится только те данные, те ветви графа, по которым моделям работает данный актер, данный узел, можно сказать. И универсальные запросы делаются именно к этому графу. Но для ускорения работы придется кэшировать. Но акаширование данных – здесь еще и два направления. Либо это таблицы с множественными однотипными данными реестры. Реестр недвижимости лучше вынести в отдельную таблицу и синхронизировать с графом. Потому что графу выуживать какие-то запросы очень сложно. И второй момент – это хранение текущего состояния. То есть у нас у графа есть конечное текущее состояние, которому нужен ускоренный доступ к чьим-то темпоральным данным. поэтому здесь, в общем случае, три хранилища. Общее хранилище для графа, распределенное по веткам, и хранилище для реестров, вполне скверное могло бы давлиться, и, скорее всего, графовое хранилище для текущего состояния, для актуального текущего состояния системы. 

S01 [01:13:53]  : Александр, спасибо. Давайте еще вопросы от Виктора Казариного. Значит, только просьба коротко. Первый вопрос. Чем ваш EvenFlow-подход отличается от обычных продукционных правил? 

S02 [01:14:07]  : Ну, самое главное, продукционные правила предписывают, что нужно сделать по этому правилу. А Event Flow не предписывает вообще будущее, а ориентируется только на текущее событие, когда оно может произойти. И в этом плане, если я сейчас добавлю сюда еще какое-то событие, просто добавлю модель какое-то событие и сформирую условия, скажем, еще событие 7 добавлю, там 10 сюда, и сформирую, что оно свершится при этом условии, при этом, то оно никак не изменит работающую модель. То есть модель может модифицироваться свободно любым актором, не затрагивая существующую модель, наращивая функционал перманентно. И это существенно отличается от описания бизнес-процессов текущих, от всех основанных на машинах этих. Фу, забыл. Ну, в общем, это именно существенное отличие. 

S01 [01:15:08]  : Спасибо. Второй вопрос Виктора, что вы во главу угла поставили события. Подробнее о процессах в вашем подходе можете рассказать? Вот у меня здесь такое замечание, что мне кажется, о процессах вы рассказывать будете очень долго. Нет, одно слово. 

S02 [01:15:24]  : Давайте. Одно слово. Вообще, блин, два слова. Что у нас под процессами поднимаются разные. И поэтому очень сложно. Есть бизнес-процессы – это, по сути, действие. Вот есть модель некого действия, и действие – это множество событий, которые реализуют какое-то действие. Я же использую вообще процесс как посвятенность событий. То есть вот у нас есть процесс 1, 4, 6, 7, вот процесс из последовательности событий. То есть в графе можно отследить все процессы. В целом это действие, завершающее результатом 7 и состоящее из последовательности процесса. 

S01 [01:16:10]  : Спасибо. Можно ли кратко определить, что именно относится ко времени в вашей системе? 

S02 [01:16:17]  : Ко времени относится каждое событие, которое свершается после обуславливающих и до тех, которые он обуславливает потом. То есть вот событие 4, оно обусловлено наличием события 1 и обуславливает событие 6. И вот это отношение – это временное, раньше-позже. А конкретно, как Алекс говорил правильно, там прописан еще стамп, но это служебная информация, которая зависит уже от конкретных реализаций, конкретных часов на конкретной машине. 

S01 [01:16:48]  : Извините, а можно вот здесь уточнить, я правильно понимаю, что только что вы сказали, что времени 2, одно таймстамп, а другое… Нет, вообще времени 3. 

S02 [01:16:58]  : Есть время, которое фиксирует сам субъект. когда свершилось событие. Он записывает это через 5 минут после того, как оно свершилось. Он не может его когда-чем зафиксировать. Прошла операция, и он пишет, что в такое-то время произошла операция. Он фиксирует по своим часам, по которым сколько минут прошло. Есть время записи этого события в хранилище, именно когда было записано конкретно. Если это распределённая система, то это может быть время консенсуса, когда был завершён консенсус по данному событию. И есть ещё время антологическое. которая внутри системы именно определяется раньше-позже и относительно других событий. То есть если мы, скажем, ведем периодически через каждую секунду или через 10 секунд или через минуту время от мировой, будем генерировать события мирового времени через какой-то то относительно этого времени мы будем получать уже времяонтологическое в системе. Поэтому три времени здесь, и каждый раз нужно понимать, с каким временем мы работаем. 

S01 [01:18:10]  : Тут у меня есть нехороший комментарий, что как минимум одно из этих времен может на самом деле описываться не таймстемпом, а интервалом. То есть, например, в тех же самых задачах финансового анализа. 

S02 [01:18:22]  : Да, да, да. Конечно, интервалы. здесь чаще всего, то есть проще работать с интервалами, то есть если мы имеем некую автоматическую модель, которая автоматически отрабатывается, то мы задаем не абсолютное время, когда должно совершиться событие 4, а мы задаем событие, в котором прописано условие совершения события 4 через 10 минут, через событие 1. через интервал, и есть программный агент, то есть это уже разработано, то есть сейчас программист будет делать, то есть программный агент, который фиксирует это событие, отслеживает время, через 10 минут выдает событие, конец этого промежутка. Оно является обуславливающим для события 4, оно выполняется. 

S01 [01:19:05]  : Ну и тогда модель нужно будет вам расширять еще, правильно? Нет, сразу в модели написано. То есть у вас все-таки временем подразумевается интервал, а не таймстэмп? 

S02 [01:19:15]  : Нет, в модели вообще таймстэмпа нет вообще. В принципе, в модели только последовательность определяется. Но если в модели ввести еще дополнительные временные события, которые будут обуславливаться, тогда можно синхронизировать по времени. Но эти события нужно получать откуда-то. 

S01 [01:19:31]  : Но эти события будут описаны интервалами, правильно? 

S02 [01:19:34]  : Либо интервалами, либо абсолютно. Если я ставлю будильник, я могу поставить будильник на 6 утра, и будет сгенерировано событие 6 утра, будильник сработает, сколько-то событий, сколько нужно. То есть, может быть, абсолютное событие с абсолютным временем введено по оракулу, либо интервальное время введено. Есть в зависимости от модели. 

S01 [01:19:56]  : Спасибо. И последний вопрос, чтобы нам двигаться дальше, все остальные вопросы уже на потом. Значит, если произошло, например, обрушение горной породы на склоне горы, кто является актором, сейсмоприемник или природа? 

S02 [01:20:12]  : Сейсмоприемник, конечно. 

S01 [01:20:13]  : Хорошо, спасибо. Если вопросы остались, я вижу от Виктора и Владимира Смолина, давайте это в конце, если время останется. Сейчас, пожалуйста, Николай Робчевский. 

S00 [01:20:25]  : Вам слово. Да, добрый день. Ну, я попробую пройти в том порядке по вопросам, который предлагался вначале. Значит, вот первое – это время. Время может быть использовано в двух разных способах, об одном из которых мы дискутировали только что. То есть это время, когда нечто произошло, и в таком виде это… очевидно является атрибутом сущности, которая описывает, что именно произошло. Вторая ипостась времени не упоминалась вообще. Речь идёт вот о чём. Поскольку мы говорим о General Intelligence, то она должна быть пригодна для управления чем-то в реальном времени. Управление чем-то в реальном времени сложно реализовать, если у нас не используются понятия в зависимости чего-то от времени. А зависимость чего-то от времени, естественно, в компьютере представляется функцией времени. Поэтому нужно предусматривать два способа хранения времени. Одно – это как атрибут некой сущности, а второе – это как функцию, которая, вообще говоря, тоже может быть атрибутом. То есть тип атрибута может быть либо число, которое отражает время, либо функция, которая отражает зависимость от времени. Второй момент вот о контексте Поскольку мы говорим, опять-таки, о возможности работы в реальном времени, то самое радикальное ограничение в этом случае — это производительность системы. То есть все решения и весь анализ данных, который должна проводить система, должен проводиться быстро. И способность выполнить все анализы и действия, принять решения раньше, чем ситуация изменится и найденные решения перестанут быть. актуальными – это радикальная проблема. Поэтому единственный способ обеспечить приемлемую производительность real-time системы – это все данные, которые используются, загрузить в оперативную память. То есть загрузиться должны, во-первых, те данные, которые более или менее постоянные, а именно семантический граф, который отражает отношение между логическими сущностями. И последовательности, которые отражают последовательность событий, которая имела место в прошлом, последовательности, которые отражают программы или процессы, которые могут выполняться. И они должны храниться именно как последовательности, потому что это… И значения атрибутов, которые могут храниться как триплеты, упомянутые неоднократно тут, триплеты из первой сущности, которая описывается этим атрибутом. Второе – это сущность, которая указывает на тип атрибута. И третье – это значение атрибута, которое может быть числом, текстом, функцией и чем-то может быть ещё в зависимости от необходимости. Ну и соответственно, я уже ответил тем самым на вопрос о том, как хранить процедуры и функции, как последовательность неких символов, а конкретно, с моей точки зрения, то, что я, так сказать, реализую. Удобный способ хранения процедур, которые должны выполняться самой системой, которая ею же конструируется, это использование языков, которые теоретически называются concatenative, то есть языки, у которых процедура, которая состоит из двух последовательно вызываемых процедур, из которых первое формирует некие данные, они передаются во вторую, и которая использует их в качестве входной. Так вот, для таких языков код, суммарный для этих двух процедур, будет это просто соединенный, записанный один за другим код, каждый из них, то есть ничего добавлять не нужно. К таким языкам относится всем известная польская обратная запись, то есть постфиксная арифметика, например. И язык форт, и вариации на эту тему. Следующий вопрос насчёт гиперграфов, метаграфов и так далее. Антон Колонин и Александр Балдачо описывали различные версии того, как можно имплементировать графы в одном случае, в другом, в третьем, в четвертом. Базовым элементом, который позволяет имплементировать каждый из записанных вариантов, является обычный ориентированный граф, который очень компактно может представляться в памяти. А как он будет представляться вне памяти, куда он записывается, когда система делает аварийное запоминание или запоминание перед тем, как её остановят до следующего запуска. Оно не имеет значения вообще. То есть важно то, как граф представлен в оперативной памяти. В оперативной памяти эффективное представление графа заключается в том, что для каждого узла задается множество узлов, куда направлены ребра графа. И все это соответствие между узлом и множеством узлов, куда направлены ребра, хранятся в хэштаблице. Производительность такого хранения не соизмерима совершенно с производительностью ситуации, когда мы используем внешнюю базу данных, к которой обращаемся. То есть запрос на информацию от такого представления позволяет на обычных компьютерах теперешних иметь время отклика, которое меряется единицами микросекунд. А доступ к внешней базе данных или даже внешне, не по отношению к компьютеру, а внешне по отношению к данной программе, но на этом же компьютере. Он измеряется миллисекундами, то есть просто доступ, даже без поиска. Поэтому вот речь идет о том, Графы и последовательности, которые нужны в момент исполнения, в момент работы интеллектуальной системы, они должны находиться в оперативной памяти. А то, каким образом они хранятся вне, оперативной памяти большого значения не имеет, лишь бы мы могли их записать и прочитать их оттуда. Я использую обычные файлы для этого. Но нет проблем использовать реляционную базу данных и так далее. Следующий момент заключается вот в чем. Универсальность достигается разделением данных по типам, то есть отношения между логическими сущностями хранятся в графе. Атрибуты сущностей хранятся в таблице атрибутов, и все последовательности хранятся как последовательности. И это отражает, в общем, логическую суть и обеспечивает, если это реализовано на нижнем уровне, построение, любых упомянутых сегодня вариантов графов, структур и так далее. То есть обеспечивается вот та самая общность, которая от General Intelligence требуется. То есть если иметь в виду вот такую базовую структуру, то на ней можно построить и то, о чём говорил Александр Балтычёв, и то, о чём у Антона Колонина было в нескольких примерах, от партийных текстов до финансовых. То есть если у нас есть time-серия каких-то данных, так её и надо хранить именно как последовательность. Не нужно ничего изобретать, а использовать естественную форму представления данных. Для таких вещей, естественно, есть и библиотечные представления, эффективные, несложно настраивать над ними какие-то свои собственные варианты, если есть серьёзные аргументы в пользу того, чтобы использовать не библиотечные реализации, а собственные. Например, есть реализация для ориентированного рафа, о которой я говорю. Она есть в GitHub, можно брать её. При вполне приемлемых размерах операционной памяти, как на теперешних компьютерах, можно хранить миллионы узлов, то есть миллионы логических сущностей туда в глазах. В случае использования телефонов, может быть, будет не несколько миллионов, а один, но как минимум один точно может влезть. Ну вот, я думаю, что я на вопросы ответил. А, пожалуй, вот еще о чем. О контексте. Есть еще одно деление данных, которое должно использоваться, если мы хотим эффективно работать, а именно то, что у меня называется описанием текущей ситуации. То есть если мы получаем большой объем входной информации, то на самом деле мы в большинстве случаев используем только маленькую часть в дальнейшем для того, чтобы запомнить. извлечь из него самое важное, внести в семантическую сеть, внести в хранилище атрибутов и так далее. А большая часть выбрасывается. Поэтому логически сделать таким образом. Есть описание текущей ситуации, которая хранит всю входную информацию, но за короткий период времени. и некие промежуточные данные, которые мы используем для того, чтобы отсеять ненужное, для того, чтобы выработать решение о том, что мы будем делать. И только наиболее важная информация, которую мы обнаружили, которая достойна того, чтобы её запомнить на будущее, Вот только она вносится в семантический граф и в историю прошлых событий, которые система держит для того, чтобы использовать в дальнейшем для принятия решений. На этом у меня всё. Если есть вопросы, я могу отвечать. 

S01 [01:36:17]  : Николай, спасибо огромное. На самом деле, все, что Вы говорите, очень близко, но я попытаюсь тут конкретно уточнить. Во-первых, Вы упомянули GitHub. Вы что имеете в виду? Какой репозиторий на GitHub? Вы можете дать ссылку, если это про Ваши репозитории? 

S00 [01:36:39]  : Давайте я завтра выложу. Я давал на него ссылку, когда были соответствующие ссылки на мои... 

S01 [01:36:53]  : А вы дайте, пожалуйста, ещё раз ссылку, мы просто на сайте сообщества к вашему проекту подцепим. 

S00 [01:37:01]  : Да, я дам и на Фейсбуке, и в Телеграм я дам ссылку. 

S01 [01:37:05]  : Вот, ладно. Теперь, значит, интереснее. Значит, смотрите, если я правильно понимаю нашу с вами дискуссию год назад, то то, что я в своём докладе обозначал как Рич Граф, Сложные отношения, где есть много источников, где есть много приемников, вы предлагаете описывать просто как вершины. То есть, если есть сложное какое-то отношение, это просто вершина, у которой есть много бинарных направленных связей на все свойства этой вершины. Правильно? Да. Принято. Второй момент. На самом деле, я когда начинал свой проект семь лет назад, я тоже долго медитировал гиперграфом и в конечном итоге сделал все ровно так, как вы сейчас рассказали, исходя из ровно этих соображений. Единственное, что я услышал интересного для себя, это то, что вы предлагаете явно в дополнение к направленному графу вы предлагаете дополнительно ввести такую сущность, как последовательность. Я правильно понимаю, что у вас есть такой системный примитив последовательность, который тоже сериализуется в файловое хранилище? Она в явном виде у вас участвует, как элемент описания структуры? 

S00 [01:38:18]  : Да, есть. Основное хранилище знаний состоит из трех частей. Ориентированный граф для семантических отношений между сущностями, последовательность событий, которая имела место и которая представляет собой ссылки на сущности в этом графе, но она упорядочивает их во времени. И третья часть – это текущее значение атрибутов сущностей. При этом само понятие атрибута – оно тоже сущность. То есть если у меня, скажем, есть некий объект-ведро и есть понятие атрибута «объём», то я имею в семантическом графе понятие «ведра», имею понятие «объём». Для понятия «объёма» я имею заранее заложенное понятие о том, что это действительное число, А в хранилище данных у меня ключом является пара ведро-объём, а значением является действительное число. 

S01 [01:40:01]  : Окей, то есть, получается у вас граф содержит, глубоко говоря, айдишники сущностей, а значение – это привязка айдишников к их численным значениям. Да, да, да. А строки? 

S00 [01:40:15]  : И строки точно так же? Да, да, только если у меня там есть адрес, скажем, в качестве атрибута. то у меня есть сущность адрес, в которой говорится, что эта сущность является атрибутом и что ее тип – строка. И в треплете значением будет, опять-таки, два идентификатора логических сущностей, и третье – это значение в виде строкового значения. 

S01 [01:40:56]  : То есть, всё-таки в явном виде у вас в графе присутствуют строковые значения? 

S00 [01:41:01]  : Нет, не в графе, в хранилище данных. 

S01 [01:41:06]  : То есть, у вас граф чисто на айдишниках или на адресах, а хранилище – это, собственно, key value pair из айдишников или адресов и, собственно, строковых численных значений? Да, да. 

S00 [01:41:23]  : Делаю таким образом, для коротких строк. я совмещаю, то есть одно хранилище может хранить там действительные или короткие строки, то есть данные битовые, которые интерпретируются в соответствии с типом атрибута. Если речь идет о больших текстах, то нужно, так сказать, ввести отдельную таблицу, которая имеет такую же структуру, но хранит строки переменной длины, скажем так. И отдельно есть еще четвертая необязательная компонента, а именно таблица, которая связывает идентификаторы именованных сущностей с их именами на конкретном языке. В ней, естественно, присутствуют не все они, а только те, которые действительно именованные. Их можно подгружать в зависимости от языка. 

S01 [01:42:35]  : Николай, скажите, это у вас C, насколько я понимаю, да? C, C++? 

S00 [01:42:39]  : Да, C++. 

S01 [01:42:41]  : Да, и это Open Source или Closed Source? 

S00 [01:42:45]  : Это Open Source, да. 

S01 [01:42:46]  : Понятно, то есть ссылку вы дадите. 

S00 [01:42:48]  : У меня не всё выложено из того, что есть. Но я имею в виду выкладывать по мере того, как я хоть какие-то описания даю, потому что… Ну, в общем, известно, что просто исходники, к которым есть доступ, но нет толкового описания, их, в общем, использовать практически невозможно. Но если у кого-то есть желание использовать что-то из того, что есть, можно ко мне обращаться напрямую, я дам объяснение тем вещам, которых нету пока там. 

S01 [01:43:30]  : Спасибо, Николай. Вопрос по структуре еще один. Вы в какой-то момент сказали, что еще есть момент, связанный с контекстом. Для реализации контекста у вас еще какой-то примитив есть? 

S00 [01:43:45]  : Нет, я имел в виду описание текущей ситуации. Это и есть аналог контекста. 

S01 [01:43:53]  : А что такое описание текущей ситуации? То есть оно как-то с точки зрения схемы хранения данных как-то выделено? 

S00 [01:44:00]  : С точки зрения хранения данных оно, в общем, наиболее зависимо от области применения этой системы. Точно так же, как, скажем, набор сенсоров и актуаторов. То есть в первую очередь это то, что принято в качестве входных данных за некий последний период времени от внешних источников, от сенсоров или от собеседников, если это речь идет о разговорных системах. или данные о маркете, которые сыпятся каким-то потоком. 

S01 [01:44:49]  : Как это описано? Понятно, что это такое, но это же по идее вам надо под граф выделять? 

S00 [01:44:55]  : Нет, оно не связано напрямую. Оно связано только кодом системы, которая их обрабатывает и анализирует. В схеме хранения этого нет. Оно целиком зависит от характера выходных данных, поэтому эту часть нереально сделать независимой от типа приложения. 

S01 [01:45:29]  : Так, хорошо. Николай, спасибо. Последний вопрос от меня, потом будут вопросы от Сергея Тереха и Виктора Казарина. Значит, смотрите. Вот мой опыт, что я начинал с примерно такой же схемы, как у вас, за отличием некоторых несущественных деталей концептуальных и технических. Но на сегодняшний момент у меня есть проблема с памятью. То есть, памяти не хватает. Соответственно, вопрос – это просто я жадничаю и не хочу платить лишние 100 долларов Амазону. для удвоения мощности сервера. Или же все-таки есть какая-то необходимость делать так, чтобы часть данных была в памяти. Я двумя руками за InMemory Database Да, и даже Сбербанк, значит, у него, я не знаю, чем все кончилось, когда я там работал, был проект про переводу вообще всего финпроцессинга на In-Memory Grid DB. Вот, не знаю, чем кончилось. Но вот смотрите, вы сказали в какой-то момент, что какие-то данные должны быть всегда In-Memory, а какие-то данные должны быть всегда на диске. Но как это можно разделить? То есть, это вот где граница проходит? То есть, два вопроса. Первое, правильно ли я понимаю, что не нужно жадничать, а нужно иметь столько памяти, сколько требует твоя задача, чтобы всегда все в память влезало? И второй вопрос, что если что-то выносится на диск, то вот где граница проходит на уровне той модели, которую вы описали? 

S00 [01:46:59]  : Да, жадничать не нужно – это первое. в семантическом. Вот там двух-трёх гигабайт оперативной памяти хватает для того, чтобы хранить несколько миллионов сущностей, потому что там присутствуют только их идентификаторы. В последовательность событий, которую мы считаем достойной помнить в прошлом, Она ещё более компактна, но сколько там их может быть? И в ней есть тоже только идентификаторы. Что может храниться на внешней базе данных без существенного снижения эффективности? Во-первых, то, что касается значения атрибутов. Но и тут, в общем, есть смысл делать не просто внешнюю базу, не просто внешнее хранилище, а делать хороший кэш в оперативной памяти. Второй момент – это имена. Если мы имеем именованные сущности, то процесс обработки логической имена их не используют вообще говоря. Я, правда, не занимаюсь анализом разговорных систем, поэтому текст мало используется, но хранение связей, мэппинга между сущностями и их словарным представлением В принципе, наверное, можно хранить снаружи, поскольку скорость конверсации, обмена данными текстуальными, она обычно низкая. То есть, если преобразовали текст в последовательность идентификаторов, Быстро его обрабатываем в оперативной памяти, когда мы сочинили что-то, это последовательность Identity ID, и потом мы можем не спеша её превратить в актуальный текст. 

S01 [01:49:50]  : Николай, спасибо. Короткий комментарий насчёт преобразования текста последовательности в ID. Я тоже это делал, но там есть такой нюанс, что когда текст идёт с большим количеством ошибок, то у нас происходит небольшой взрыв, потому что одно слово может быть в большом числе вариантов, связанных с опечатками. И это как-то нужно нормализовывать. 

S00 [01:50:10]  : Это проблема, да. Кстати, один из приёмов, который я в своё время использовал когда-то, заключается в том, что когда мы встречаем неправильное слово, то мы пытаемся искать его правильный вариант, исходя из множества символов, которые в него входят. И перебираем только те, которые подходят. А поскольку символов у нас всего обычно входят в 64, то можно эту таблицу наборов символов привести для каждого слова в виде отдельной таблицы. 

S01 [01:51:09]  : Да, наверное, многие заметили, что чат в Зуме вот этим активно занимается, и часто ты что-нибудь пишешь в Зумовском чате, нажимаешь Enter, а потом выясняется, что написан какой-то бред, потому что он поправил твои ошибки, но поправил совсем не так, как нужно было поправить. А исправить неправильно нельзя. Вот, хорошо, значит, есть два вопроса вам от Сергея Терехова и Виктора Казаринова, а потом, значит, у нас Владимир Смойн еще хотел высказаться, поэтому, наверное, критиковать выступающих до Владимира не удастся. Значит, от Сергея Терехова Николаю Рабчевскому. Как быть, если требуется поисковое вероятностное поведение, много пробных вариантов, перемещение в следующий случайно выбираемый узел? Затем требуется обратная агрегация. Ведь весь такой поиск должен идти быстрее реального времени. Нужна специальная память пробных траекторий. 

S00 [01:52:10]  : Я не совсем... Сергей, я тоже, честно говоря, не совсем понял. Идет ли речь о поиске на графе? 

S03 [01:52:25]  : Нет, речь идет вот о чем. Если приложение связано с управлением, вот не со смыслением, то есть не с авторегрессией на старое, вот вы очень аккуратно все описали, я законспектировался, прямо вот мне прямо это самое. Как все сохранить то, что вы знаете сейчас? Но как только вы начинаете решать задачу управления, вам надо теоретически продвинуться пробно, так сказать, потенциально по какому-то графу перемещения. Если это те же самые узлы, которые в схематическом графе, то по ним. Если нет, а какие-то состояния, тогда это какой-то отдельный граф возможных состояний. И эти траектории осмыслить и потом как-то агрегировать, чтобы вам в текущий момент принять управляющие решения. Вот это такой один из подходов управления. Либо это вообще не рассматривается в вашем подходе, вам такое не надо, либо вот надо, то есть это много динамических траекторий, суть которых они вот экспериментальные, должны очень быстро собираться, их много, потом их надо агрегировать, большинство из них выкинуть, вообще все выкинуть, а только там оценку оставить и на основе нее принять решение. 

S00 [01:53:25]  : Да, понял. То есть для себя, видимо, это то, что я называю прогнозирование, то есть пробуем прогнозировать последствия тех или иных наших собственных действий для того, чтобы выбрать наиболее разумный, при этом прогнозировать не на один шаг вперед, а на несколько шагов дальше. Получается дерево вариантов, или точнее даже лес вариантов, у которого, так сказать, каждое дерево – это одно из тех операций, которые в начальный, теперешний момент возможны. И это действительно структура, которая вот, по идее, именно как дерево, должна реализовываться, и у меня это имеется в виду, и так и делается. Но это, поскольку это не связано с хранением продолжительным, а используется только в текущий момент, то, в общем, я об этом особо не говорил. Но принцип именно такой. Дерево. И при этом, вот поскольку это лес, а не дерево, так сказать, изначально, то есть текущее действие может быть, скажем, 10. Для каждого варианта, который может рассматриваться, мы можем параллельно рассчитывать из которых начинается с одного из возможных действий. 

S03 [01:55:14]  : – Николай, очень коротенький вопрос. Дерево, оно возможные пути описывает, но не все возможные пути. Вы же там некоторые пути не стали просматривать. Вы просмотрели какие-то цепочки. Вот вы думаете, что надо все дерево хранить с возможностями? 

S00 [01:55:30]  : – Оно строится, оно выбрасывается потом. То есть оно строится, исходя из текущей ситуации, но оно выбрасывается почему? Потому что последствия каждого моего действия зависят не только от того, что я делаю, но и от того, что происходит вне, в окружающей среде. Поэтому актуальность, так сказать, этого пути, она, как только я использовал или отбросил её, она в любом случае теряется, потому что внешняя ситуация изменилась. Спасибо, спасибо, я понял. Поэтому строятся параллельно эти деревья, и в реал тайм это означает следующее, их можно строить далеко, но построить далеко не получится, не только потому что вариантов много, а потому что время закончилось. То есть мы строим и параллельно с построением у нас есть некий наилучший вариант, который на данный момент находится. Как только мы построили что-то лучшее, мы его апдейтаем. И как только поступает момент, когда нам нужно, так сказать, принять решение, то вот какое есть наилучшее, такое и будет. А все остальные выбросили на следующем шаге и начали заново всё. 

S01 [01:57:12]  : Николай, спасибо. Короткий комментарий по поводу вопроса Сергея. В Аппенкоге есть такая специальная фишка, которая называется Space. То есть там в Аппенкоге есть Atomspace, их база данных называется, и там кроме атомов где каждый атом – это либо концепт унарная связь, либо бинарная связь, либо тернарная связь, то есть последовательность, либо множество. У них еще атрибутом обязательным каждого атома является space. Соответственно, если мы пытаемся построить разные варианты решения, в которых участвуют одни и те же концепты, одни и те же отношения, то мы, по сути, пытаемся построить разные картины мира и выбрать какую-то одну из них. И вот эти разные картины мира с использованием одних и тех же сущностей могут делаться в разных спейсах. Правда, на сегодняшний день, опять-таки информация старая, когда я последний раз с Беном разговаривал, эта фишка не используется, но вот она как бы была задумана специально под это, чтобы можно было расщеплять реальность на различные состояния. Но, правда, тут есть еще важный такой момент, что, в принципе, как я понимаю, в систему Николая можно ввести это понятие вот этого спейса для того, чтобы вычленять под графы, то есть мы можем довести дополнительную связь типа space, и все вот эти отношения могут быть в принципе описаны. И это, наверное, может быть будет даже более правильным. Соответственно, мы можем просто ввести понятие варианта в схему модели данных и поверх схемы Николая реализовать то, что вы говорите. Но это уже будет второй уровень. И еще вопрос от Виктора Казарева. 

S03 [01:58:57]  : Я прошу прощения, звук какой-то идет. Видимо, с переденко Дмитрия включен микрофон. Так, ну видимо уже выключил. Нет. 

S01 [01:59:12]  : Так, хорошо. Еще один вопрос от Виктора Казаринова Николаю. Правильно ли он понимает, что у вас есть класс ведро вообще и объекты ведро 1, ведро 2? Из вашего словесного описания я упустил эту подробность. 

S00 [01:59:29]  : Да, конечно. Есть понятия ведро, есть экземпляры ведра. Могут быть под класс этого ведра маленькое ведро, большое ведро и так далее. 

S01 [01:59:46]  : Так, и еще вопрос от Игоря Романенко. То есть, если к Вам приходит одна и та же информация, то у Вас каждый раз будет строиться это дерево и каждый раз будет вычисляться правильный вариант. Правильно ли? Да. 

S00 [02:00:00]  : Хорошо. Спасибо. В принципе, можно добавить ситуацию, которая будет отлавливать повторяющиеся последовательности событий и ускорять поиск, начиная их… того, что уже хорошо зарекомендовало себя в прошлом. Но, так сказать, это пока на уровне абстракции. Абстрактные возможности. 

S01 [02:00:33]  : Хорошо. Николай, спасибо. И теперь слово предоставляется Владимиру Смолину. Владимир. Меня слышно? 

S06 [02:00:43]  : Да. Может быть, даже видно. Хорошо. Такой сперва абстрактный вопрос, на который не надо ответить. Правильно я понимаю, что все, о чем было рассказано, это, собственно, обработка данных, которые кто-то взял. Или какая-то система граудинга. Ну, в основном, конечно, человек на данном этапе. Здесь идет речь про уже обработку данных, которые введены еще кем-то. То есть, если это какая-то часть, агент сильного искусственного интеллекта, то не весь агент. Но это так. Если кто-то захочет ответить... Николай Владимирович, можно я сразу отвечу? 

S01 [02:01:18]  : Потому что, по-моему, вы пропустили начало, потому что как раз на одном из первых слайдов моих было, что данные могут появляться либо извне, их действительно должен кто-то внести, либо они могут генерироваться совой системой. То есть, мы сейчас говорим не откуда берутся эти данные, а о том, как они хранятся и каковы их схемы. 

S06 [02:01:38]  : Нет, про генеративные языки Хомского, про то, что можно делать логические выводы, это известно, да. То есть, это данные, могут производить данные, но начальные данные, они, значит, тем-то должны быть взяты. Я только про это. А то, что их потом можно обрабатывать, никаких сомнений не вызывает. 

S01 [02:01:52]  : Ну, они могут... Почему обязательно введены? Они могут быть получены по наследству от мамы, например. Или от папы. Или от обоих родителей. 

S06 [02:02:00]  : Ну, как бы сказать... Либо должна быть эволюция, которая произойдет к маме. Либо, значит, человек должен к маме служить. Ну, это да. Давайте, как бы сказать. Я сейчас понимаю, что это длинный философский отчет. Более, значит, такой технический вопрос у меня, собственно. Александр Балдачёв. Описать данные. Он предлагает список 102 различных действий, которые всё позволяют описать. Допустим, в английском есть такое понятие как basic English. Там, не помню, то ли две, то ли три тысячи слов, они тоже позволяют всё описать. А есть теорема про машину Тюринга, что, в принципе, двух логических операций достаточно для того, чтобы выполнить любой алгоритм. То есть может ли Александра рассказать, что 109 – это та самая золотая середина, что 50 – это мало, а 10 – это уже как бы много. Что 109 – это самое оно. 

S02 [02:02:57]  : Здесь ответ очень простой. Мы часто на эту тему с Миколой дискутировали. Это вопрос золотой середины, что принять. Можно минимизировать, и тогда упростится структура. но появятся накладные расходы большие. То есть действительно, либо ты должен строить очень большую онтологию на тысячи элементов, и тогда у тебя писательная способность увеличивается, но универсальность теряется. Либо ты абсолютно универсальный делаешь, как Микола, но тогда возникают докладные расходы на какую-то реализацию конкретных процессов. 

S06 [02:03:37]  : Это все понятно, что есть какая-то середина. Вопрос в том, что это у вас такой эмпирический результат. Эмпирический, сугубо эмпирический. 

S02 [02:03:45]  : Нет, нет, нет, никаких сугубо эмпирических, то есть и вполне возможно будут увеличиваться, то есть это конкретно для работы, вот я беру конкретную работу, конкретные модели. Понял, понял, я все понял. 

S06 [02:03:58]  : Вот, теперь вот на самом деле Сергей Тереков хотел задать, но что-то сейчас не знаю, почему-то не задавал, я там уже пропустил. Значит, вот про то, что из данных улавливается только статистическая зависимость между событиями, а причинность она просто из данных не является. Это ему вчера задавали вопрос о том, что петух прокукарекал, потом зашло солнце. Является ли то, что петух прокукарекал, значит, причиной того, что зашло солнце? То есть мы, конечно, можем действовать. Допустим, взять петуха, опустить на сухо, он не прокукарекает, солнце взошло. Но тут же мне расскажут, что соседний петух прокукарекал. Допустим, уничтожить всех петухов или остановить вращение Земли, чтобы солнце не входило. Я ничего не могу. Если у вас философский подход о том, как определять причинность событий, 

S02 [02:04:51]  : Это к кому вопрос? Наверное, к вам. 

S06 [02:04:56]  : Никак. То есть никакой причинности событий вообще нет? 

S02 [02:05:00]  : Понимаете, это вопрос такой абстрактный, никак. Но если, скажем, смотрите, хороший пример приведу. Допустим, асфальт мокрый. Какова причина? очень много разных причин. мы можем указать дождь и сказать, что если был дождь, то будет асфальт мокрый. это правильный логический вывод? является однозначной причиной? нет. Потому что асфальт мокрый может быть от того, что пролили ведро воды, от того, что поливальная машина прошла или дождь. Но в моей системе этот вопрос не стоит, поскольку когда мы указываем события, асфальт мокрый, мы обязаны просто указать обуславливающие события. Это не является причиной, а это является обуславливающим событием. Почему асфальт мокрый? Потому что обусловлен тем, что пошел дождь. Не дождь является причиной того, что асфальт мокрый, а асфальт мокрый потому, что есть обуславливающие события. 

S06 [02:06:11]  : То есть в том примере, который вчера приводили Сергея Тирохова, то, что Петух покукарекал, это не причина того, что взошло солнце, а это обуславливающие события. 

S02 [02:06:19]  : Нет, это не обуславливающее событие. Это обуславливающее... то, что крикнул петух, может обусловить только то, что я проснулся. Но солнце с ним не имеет никакого отношения. 

S03 [02:06:28]  : А как вы различите это? Вы говорите, что у вас просто... у вас единственное, что есть, это время. Больше ничего нет. 

S02 [02:06:33]  : Нет, есть событие, я проснулся. И у этого события в кондишоне стоит через О различные условия. Меня толкнули или толкнула мама, разбудила, либо прокричал петух, либо сработал будильник. И когда я буду фиксировать в графе, что я проснулся, то это будет зафиксировано по одной и по одному из обуславливающих событий. 

S03 [02:06:57]  : То есть они прописаны, они там прописаны. 

S02 [02:07:00]  : Вот это был вопрос. 

S03 [02:07:01]  : То есть если это задано, то все в порядке. 

S02 [02:07:03]  : В модели прописано обуславливающие события, естественно. 

S06 [02:07:06]  : То есть если какое-то событие не прописано, допустим, там землетрясение произошло, а вы это у себя не прописали, то это не является обуславливающим событием? 

S02 [02:07:13]  : Да, но так обычно и есть. Это же продукционное правило. Хорошо. Ну, это продукционное правило, да. Кстати, Виктор еще хотел, не ответил, что система event flow, она семантическая, то есть она нагружена семантически, а не только на каких-то абстрактных событиях. 

S06 [02:07:48]  : Время в системе важно, в каком смысле, что оно вообще-то и есть. Человечество долго жило без часов, и сейчас не каждый заглядывает на телефон. Есть разговоры о том, что у нас есть в голове биологические часы, но анатомически их никто не нашел. И, собственно, мое представление о том, что просто есть как бы постоянное время развития, динамические события различные, но мы их сравним и говорим, что это быстрее, это медленнее. А часами мы, конечно, можем измерить, вот насколько обязательно в системе иметь представление о времени. Это, наверное, Николь у меня вопрос. 

S01 [02:08:33]  : Николай, это к вам вопрос, как я понимаю. 

S00 [02:08:39]  : Но если это ко мне, то, безусловно, время в реальном мире играет очень существенную роль. Если вы посмотрите на мой блог, ссылку на который я давал и в Фейсбуке, и в Телеграм, то как раз вот последние мои заметки там в блоке, они касались вот использования времени для того, чтобы строить зависимость неких значений атрибутов от времени для того, чтобы использовать это для предсказания будущих событий в внешнем окружении, для того, чтобы обнаруживать причинно-следственные связи, Аккуратно использовать, не считать их по корреляции, а делать это аккуратно, по тем принципам, о которых в своё время нам рассказал Сергей Терехов. И для того, чтобы обнаруживать во внешней среде объекты, которые мы не можем опознать как уже известные, то есть для того, чтобы обнаруживать неизвестные нам объекты и таким образом создавать наши новые понятия. 

S06 [02:10:25]  : Как для новых объектов влияет время? 

S00 [02:10:30]  : Вот если вы посмотрите последний мой блог, там продемонстрировано это. Это, так сказать, слишком долгое, наверное, объяснение. Дело в том, что новый объект – это, по своей сути, нечто, свойства чего сохраняются во времени. То есть новый объект существует в нашем понимании, в том случае, если у него есть нечто, сохраняющееся от одного момента времени к другому. То есть существует некий инвариант, который нам, если удастся найти, то мы распознаем это как новый объект. Ну, я уже знаю, куда вы клоните. 

S02 [02:11:27]  : А мелодию, Михаил, есть вариант, который сохраняется от момента времени ко времени? Это мне вопрос. Звучащая мелодия – это объект конкретный. Что там с вариантом сохраняется? 

S06 [02:11:42]  : Там гармония сохраняется, как известно. 

S02 [02:11:45]  : Нет, по этой гармонии мы не узнаем мелодию. 

S00 [02:11:51]  : Если речь идёт об одномерной ситуации, то есть о последовательности во времени, то время пропадает на самом деле. Время присутствует только тогда, когда мы говорим о пространстве. Когда у нас пространства нет, а есть только время, о нём говорить бессмысленно. Есть только последовательность во времени. 

S02 [02:12:18]  : Мелодия не является объектом и не может быть распознана, как новая мелодия, которую вы слушаете. 

S00 [02:12:22]  : Нет, она может быть распознана, но как... последовательность. Для того, чтобы ее распознать, нужно, чтобы она встретилась дважды. Другого способа нет. 

S02 [02:12:38]  : Но это не подпадает под ваше определение инварианта во времени. Значит, нужно иметь другой инвариант и другой критерий. 

S00 [02:12:45]  : Да, инвариант есть, но он не во времени, поскольку в одномерном случае времени нет. 

S02 [02:12:54]  : Ну, значит, ваша семья не распознает. Хорошо, понятно. Спасибо. 

S01 [02:12:58]  : Хорошо. Коллеги, мы стремительно двигаемся к завершению. У меня есть пожелание, чтобы Виктор Владимирович Смолин и, если есть у него готовность, и Виктор Казаринов очень кратко, буквально, может быть, по 5 минут не больше высказали свои комментарии к докладчикам и свои собственные ответы на заданные вопросы. 

S06 [02:13:22]  : Можно вопрос повторить? 

S01 [02:13:25]  : Ну вот, собственно, по повестке дня у вас есть что высказаться, если кратко, или какие-то дополнительные комментарии дать по имевшим место докладам? 

S06 [02:13:35]  : Ну, я, как бы, достаточно далек от этой тематики. В каком смысле? Что я, естественно, не против религиозных баз данных. Они полезны, эффективны, так же, как, допустим, колесо или, там, не знаю, компьютеры. Водопровод — это полезный инвентарь для цивилизации. Они могут приносить большую пользу, но с моей точки зрения к агентам искусственного интеллекта они имеют очень косвенные отношения. Потому что с моей точки зрения главное является научить их жить в той среде, в которой они, соответственно, действуют. То есть то, что вы рассказываете, это там атрибуты, мало того, что их нужно в чем-то измерять, нужно им какую-то размерность давать. Я так понимаю, что это все в наследство от мамы должно приходить, потому что иначе откуда это взяться. Решение этих вопросов, это как раз то, что должно входить в свойства искусственного интеллекта агента. А нагрузить эти вопросы, если он умеет формировать все эти вопросы, то есть какие там новые объекты, какие у них атрибуты, в какой размерности, как их сравнивать, вот это то, что должен уметь. А уже если он умеет их сравнивать, то он в компьютере может создать базу данных и, соответственно, с этой базой данных работать. И мы тоже можем с этой базой данных работать. 

S01 [02:15:00]  : А какая это будет база данных? 

S06 [02:15:03]  : Ну, значит, те, которые есть, я не хочу сказать, что их нельзя совершенствовать, конечно, их тоже можно совершенствовать. Нет, их просто много. То есть любая... Ну, значит, исторически, значит, как бы процесс проверяет, какие базы данных полезны, какие, значит, менее полезны. Те, которые более полезны, они выживают. Естественно, я не думаю, что их нельзя еще совершенствовать, их можно и нужно. 

S01 [02:15:26]  : Ну, то есть, любая, короткий ответ, база данных не важна. 

S06 [02:15:31]  : Нет, как сказать, она так же, как и колесо, понимаете, говорить о том, что это колесо любое, ну вот, понимаете, если вы там на свою новую машину поставите колесо от телеги, ну, в общем, как бы не комильфо. 

S01 [02:15:41]  : Владимир, извините, давайте конкретно, то есть, либо вы говорите, что база данных любая, либо вы говорите, не знаю, либо вы говорите, что совершенно конкретная. 

S06 [02:15:52]  : Я говорю о том, что в зависимости от задачи выясняется, с какими базами данных. 

S01 [02:15:57]  : В зависимости от конкретной задачи. База данных не является общим решением общего AGI. Для общего AGI в каждом конкретном случае нужно будет применять конкретную базу данных. 

S06 [02:16:10]  : Скажем так, у меня нет доказанной теоремы на эту тему. 

S01 [02:16:14]  : Вы не знаете, хорошо. 

S06 [02:16:16]  : Я, скажем так, пока что знаю, что ситуация такая. Может быть, она изменится, но пока что ситуация такая. Для разных задач нужно использовать разные базы данных. И, на мой взгляд, это не является центральным вопросом развития сильного искусственного интеллекта. Вот мой комментарий. 

S01 [02:16:32]  : То есть, база данных не входит в систему общего искусственного интеллекта. Данные должны храниться неизвестно где. 

S06 [02:16:42]  : Нет, конечно, они должны, естественно, храниться на каких-то носителях, в базовых данных они могут храниться. Так же, как книги, которые мы пишем, они тоже могут использоваться агентами, но это не значит, что книги – это часть агентов искусственного интеллекта. Вот примерно такое же отношение. 

S01 [02:17:00]  : Спасибо. Виктор? Вам есть что добавить? 

S05 [02:17:07]  : Я могу говорить. Да, я хотел чуть-чуть оставшиеся крошки времени исчерпать. У меня, значит, такие небольшие заметки. Мне кажется, что и Александр Булдачев, и Николай Робчевский представили частные случаи представления, в частности, времени, ну и вообще информации внутри системы. Почему частные? Но я согласен с Владимиром Смолиным, что он хотел, добивался долго от Александра. Почему у него там 119 или сколько-то типов событий. Я уже 10 лет, наверное, для себя этот вопрос решил и поэтому уже и говорил об этом. могу просто сейчас сообщить такую вещь действительно надо взять более общее представление при этом оно довольно краткое представление времени в частности ну смотрите время это некоторая последовательность правильно это можно взять понятие список, последовательность. И про списки и последовательность много сейчас говорили. В частном случае последовательность списка является процесс, временной процесс. Это значит список, упорядоченный во времени. Это второе понятие. Третье понятие – ресурс процесса. Это всё то, что является необходимыми и достаточными условиями процесса. И четвёртое – это результаты процесса. Это всё, включая момент времени окончания процесса, результаты процесса, положительные отходы процесса и всё что угодно. Все, вот этих пяти понятий достаточно для того, чтобы построить все то, о чем мы сегодня говорили. И моменты времени начала, и момент времени окончания, и последовательности, и что за чем идет последовательно, и параллельные процессы, и события. События есть начало процесса и конца процесса, все. Вот этих пяти сущностей достаточно для того, чтобы работать со всем этим. Николай Рабчевский еще добавил одну вещь про время. Говорит, это еще одна вещь. Для этого и существуют таймеры. Вот человек в голове, он говорит, нужно проснуться или нужно сделать через час, иначе надо говорить для себя. Надо не забыть, надо не забыть. Или подсознательно, или еще как-то. Но это таймеры, это не представление информации. внутри системы – это механизм таймера, это другая часть работы со временем. Я согласен, что он необходим, но это не представление информации. И еще, значит, почему я и сказал, что, возвращаясь к Александру, что у него есть только события, и при этом не только события, он связал события, информацию, хранящуюся входными данными событиями, с этими триггерами, которые срабатывают, когда события к необходимому условию. То есть у него получилась какая-то смесь хранения информации и движка, который работает с этой информацией. Поэтому вот это некоторые смесовые представления не отделены одно от другого. Еще, если есть время, буквально чуть-чуть. Вот про петуха и про солнце. Так вот спор этот простой, просто решается. Если Александр Булдачев сказал, что я не знаю, почему, если петух прокурил, то солнце встало, какая причина следственная связь? Легко определяется в меру мыслительных способностей данного субъекта. Если это Тузимис, он это сделает, в голове зацепит. Если это цивилизованный человек, Он по-другому запомнит результат своего мышления. Не потому, что петух прокошировал, а всё по-другому. Вот и всё. Это процесс самомыслительного, результат мышления данного субъекта. Ещё прокоширование, если можно. Кэширование должно быть семантическим, а не так, как сейчас с данными происходит. Оно может быть осуществлено по ассоциации. Ну, допустим, сейчас мы дергаем одни данные, а к ним идут связи. Вот эти связи заблаговременно можно и вытянуть. ассоциативно. Это первое. Второе. Система, которая более высокого уровня интеллектуально, именно мы стремимся к АГИ, она имеет возможность прогнозировать. Так вот, все, что связано с прогнозированием, то есть человек настроился, какой-то контекст у него есть и куда-то он движется, он, соответственно, может это тоже изымать из внешней длительной памяти. Это дополнительная вторая вещь. И поэтому постоянно большая память и оперативка, они связаны между собой, являются двумя частями, потому что я работал с оперативкой, все в памяти делал, у меня 64 гигабайта уже тоже отпрещали по швам, 64. из-за того, что я все в памяти делал и обрабатывал. И там не только идентификатор, как я написал, хранится, там должны быть связи и еще способ быстрой работы с этой информацией, с этими идентификаторами. Они же не просто так должны быть храниться числами. Надо, чтобы мы четко понимали, что куда идет. И поэтому вот этот небольшой винегрет, который представили два докладчика, о том, как хранить вот в одном случае и обрабатывать, и в другом случае, где вот у Александра Николаевича Рыбчевского, там еще у него есть данные, то есть четыре типа хранилищ. Все это в обычных РДВ-графах делается, там есть объектные данные и данные типа строки, числа, плавающих все это в одном формате, не нужно ничего нового изобретать. А у него есть и вот такой вариант с помощью антологического представления, еще есть отдельные. Но это его решение, я просто не критикую, я просто хочу сказать, что существует более простое решение всех этих вопросов, о чем сегодня обсуждали. Все. 

S01 [02:23:22]  : Виктор, спасибо. Сделаю несколько коротких комментариев в заключение. Во-первых, я услышал то, что интересно было узнать с точки зрения того, что в памяти, наверное, проще всего хранить в обычных направленных графах. А сериализовать, наверное, удобнее в революционную базу данных, которая для этого предназначена. Но остался нераскрытый вопрос о том, что же делать с пресловутыми статистическими моделями, которые тогда нужно все-таки понять. То ли мы их храним блобами. и заталкиваем в ту же самую революционную базу данных, то ли мы их нормализуем в графы и опять-таки заталкиваем в эту революционную базу данных при стерилизации. То есть, здесь вопрос остался не раскрыт. Видимо, потому что здесь в группе у нас мало людей, которые заняты башенным обучением и работают с нейросетевыми моделями. А по ходу возникло два вопроса, которые, может быть, мы обсудим. Я потом в группе закину ближе к делу. Есть тема выявления представления каузальных зависимостей. То есть, если вдруг у кого-то есть желание и готовность, или понимание того, у кого есть такое желание и готовность рассказать свою перспективу про выявление перспективы представления коллузиальной зависимости – это одна тема для обсуждения. И вторая тема – это представление процессов. То есть, как действительно мы представляем и храним поведенческие программы, бизнес-процессы, бизнес-правила. Заслуживает ли это отдельного обсуждения и представления в рамках тематики EGI. Но это мы, наверное, будем обсуждать уже отдельно. Коллеги, всем большое спасибо. Было интересно. И до новых встреч. 










https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

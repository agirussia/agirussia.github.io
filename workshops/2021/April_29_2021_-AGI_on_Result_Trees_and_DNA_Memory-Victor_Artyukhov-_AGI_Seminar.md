## 29 апреля 2021 - AGI на Деревьях Результатов и Память ДНК — Виктор Артюхов — Семинар AGI
[![Watch the video](https://img.youtube.com/vi/n6akIjT2d2s/hqdefault.jpg)](https://youtu.be/n6akIjT2d2s)


Суммаризация семинара:

ТЕМА
- Семинар посвящён обсуждению проекта AG для всех, который представляет собой общий искусственный интеллект для всех.

СУТЬ
- Основная идея проекта заключается в реализации афферентного синтеза, что отличает его от других проектов в области искусственного интеллекта. В проекте делается акцент на то, что синтез является первичным, а распознавание образа - вторичным. Это позволяет системе не только распознавать, но и активно взаимодействовать с окружающей средой для достижения целей.

ДЕТАЛИ
- Проект направлен на создание минимально необходимого и достаточного каркаса для интеллектуальных систем, способных к развитию. Система должна развиваться во всех направлениях, включая не только распознавание речи, но и изображений и любых других образов. Части проекта могут реализовываться разными методами.

РЕЗУЛЬТАТЫ
- Цель проекта - предоставление мощного инструмента для создания разнообразных интеллектуальных систем, которые смогут развиваться и улучшать свои возможности со временем.





S05 [00:00:32]  : Хорошо, коллеги, давайте уже тогда начинать. Мы в эфире. Виктор, вы готовы, да? Да, готов. Да, ну вот у нас сегодня Виктор Артюхов более подробно расскажет про свой проект, на который он недавно коротко у нас рассказывал. Сегодня будет подробный рассказ с возможностью задать вопросы. У нас все подробности. Виктор, пожалуйста, вам слово. 

S03 [00:00:56]  : Итак, мой проект, который я хотел бы сделать совместными усилиями, называется AG для всех, то есть общий искусственный интеллект для всех. Его отличие от существующих проектов, видимо, состоит в том, что в первую очередь он реализует афферентный синтез. Все презентации будут по сути об этом. Я на отдельных слайдах концентрирую внимание по отдельным проблемам. Но в целом этот проект, по сути, это и есть афферентный синтез. То есть синтез первичен, а все остальное здесь вторично. То есть отличие от других как раз состоит в этом, потому что, например, многие коллеги, которые занимаются искусственным интеллектом, они делают упор на другую сторону, обратную, на распознавание образа. И я в этом проекте как раз хочу показать, что есть способ распознавания через синтез. Наверное, я Америку не открываю, это всем известно, но я просто в этой архитектуре хочу показать, что все это достаточно быстро может работать и достаточно эффективно. Итак, цель проекта – создать минимально необходимый и достаточный каркас для создания интеллектуальных систем, способных к развитию. то есть слово развитие здесь не случайно потому что общий искусственный интеллект это наверное все-таки как бы не просто распознавание речи к примеру а это система которая способна именно со временем после накопления больших знаний ну становиться все лучше и лучше то есть но как бы по мере Обычная распознавалка речи не может стать лучше, потому что она выполняет всего одну функцию. Данный проект должен развиваться во всех направлениях, это будет не только распознание речи, но и распознание изображений и любых других образов. Здесь особенность проекта в том, что части проекта допускаются реализовывать разными методами. То есть архитектура проекта, она допускает использовать и нейросети, и генетические алгоритмы, и любые другие математические методы, которые максимально хорошо реализуют какую-то часть общей системы. Предполагается, что проект эволюционирует до системы, обладающей достаточным для полезного использования интеллектом. То есть, предполагаю, что с течением времени система должна стать умнее. Ну и дальше я объясню, почему это так. Значит, первый источник, с чего как бы проект начинался. Здесь вот краткое литературное описание. Но я все читать не буду, вы, наверное, сможете прочитать. Как в целом должна работать Adjifa, то есть это общая идея, как это все должно работать. И эта общая идея была сформулирована Анохиным Петром Кузьмичем достаточно давно. Из этого очень емкого описания видно, что аджифа должен искать и успешно находить новые решения, а не пытаться повторять ранее запомненные. Память нужна для синтеза новых улучшенных решений. То есть это вот мой вывод на основании вот этого вот текста, как должно работать аджифа. смысл в том что общая система искусства интеллекта она должна все время искать новые решения то есть это разница между допустим системами построенными на нейросетях когда нейросеть допустим обучается она тренируется запоминать какие-то успешные решения и потом повторять их. Вот здесь отличие в том, что новые решения синтетизируются, то есть даже если система не знает, как действовать, она все равно будет искать новые решения, и это новое решение, оно будет синтезировано на основе известных знаний. Краткие требования к системе. Это распределенность peer-to-peer, то есть это будет много узлов, которые соединяются между собой. Масштабируемость REST API для простоты связи со сторонними системами. Простой веб-интерфейс для настройки базы знаний. Возможность обмена структурированными знаниями. Тут имеется в виду, что дерево результатов это и есть структурированные знания и, соответственно, должна быть возможность обмена ветками дерева результатов. Возможность использовать разные хранилища данных, в том числе крипто-хранилища. То есть некоторые коллеги считают, что на блокчейне вполне можно реализовать системы искусственного интеллекта. Данная система GIF позволяет сохранять данные в криптохранилищах. Я тему блокчейна хорошо знаю, потому что я некоторое время работал в проекте, связанном с криптовалютами. и поэтому тут не просто написано, что можно сохранять криптохранилище, я просто знаю, как это делать. Возможность расширения функциональности для работы с данными разных типов, текста, изображения, звука, видео и так далее. Ну и C++ для максимизации производительности, то есть основные критические куски кода должны быть написаны c++ но так как система позволяет связаться со внешними компонентами и другие компоненты могут быть написаны на каких-то других языках не обязательно c++ простая схема вот для того чтобы она влезла на один экран я здесь не стал усложнять схему здесь только самое важное и так значит от живо имеет входные данные выходные данные как обычно я не стал это детализировать что имеется ввиду подходными данными потому что это могут быть самые разные типы данных и основная часть системы это дерево результатов то есть это структурированные данные которые строятся на основании нескольких простых правил и вот соответственно дерево результатов она может храниться в хранилище дерево результатов С этими данными работает блок синтеза образа требуемого результата действия для его достижения. Вот этот самый главный компонент – большой блок синтеза. На нем, по сути, все построено. И блок сравнения входных данных с требуемым результатом — это тот блок, который практически занимается распознанием образов, но это распознавание через синтез. То есть вот эти два блока, блок сравнения и блок синтеза, они очень тесно между собой связаны. Чуть позже я подробнее про это расскажу. Смысл в том, что система постоянно активна. Блок синтеза работает все время. Даже если входные и выходные данные будут отключены, то блок синтеза не перестанет работать, потому что он самодостаточный, он все время что-либо синтезирует на основе предыдущих знаний. Соответственно, слева управляющий образ требуемого результата – это то, что заставляет систему подчиняться требованиям человека, то есть человек может стоять через вот этот компонент. некие задания и система будет их выполнять. Соответственно, без вот этого блока, управляющего образ требуемого результата, система будет предоставлена сама себе и будет заниматься непонятно чем. Как-то так. То есть понятно, да? Вот смысл. Общая схема работы GIF. Все знания хранятся в структурированном виде дерева результатов. Образ требуемого результата приходит как управляющая часть входных данных. Блок синтеза на основе знаний дерева результатов создает набор действий для достижения образа требуемого результата. Блок исполнения исполняет действия. окружающая среда изменяется то есть система она постоянно находится во взаимодействии с окружающей средой и на каждое действие системы окружающая среда немедленно реагирует и и система точно также как бы опять же создает новые действия и опять же изменяет окружающую среду и это ну как бы бесконечный цикл то есть пока система работает она изменяет окружающую среду своими действиями Блок сравнения сравнивает поступившие данные с образом требуемого результата и в случае успеха условная зона внимания переходит на родительский узел DR. Иначе блок синтеза создает новые действия. Смысл здесь в том, что если система знает, что нужно делать, то есть у нее есть уже знание дерева результатов, она просто их выполняет как алгоритм ветку дерева и, соответственно, достигает поставленной цели. А иначе, если система не знает, что делать, то блок синтеза создает новые действия. но в реальности это два параллельных процесса то есть блок синтеза она работает все время память деревья результатов она тоже как бы постоянно работает параллельно блоку синтеза и соответственно я не знаю я как программист наверно в детали не буду погружаться потому что это наверно тяжело сразу представить как это происходит дальше блок хранилища dr Возможны варианты реализации это файловое хранилище, база данных, реляционная какая-нибудь блокчейн. Краткое описание методики дерева результатов на этом слайде вот по ссылке есть более подробное описание и соответственно я здесь записал только самое важное основное полезное правило нельзя получить родительский результат без достижения всех дочерних результатов это по сути делает из веток дерева некий алгоритм который ожидает выполнения дочерней ветки до тех пор пока не не будет получен требуемый результат и после получения требуемого результата мы переходим дальше как бы вверх корню дерева на следующий узел и так далее. То есть получается, что это дерево результатов, это по сути алгоритм, который состоит из параллельных и последовательных частей. Следующее полезное свойство. Узлы дерева результата просто сравнят друг с другом, потому что все их дочерние элементы имеют зависимость друг от друга. То есть для программной реализации это важно, потому что алгоритм сравнения, если данные у нас не структурированы, их очень тяжело сравнивать. В данном случае алгоритмы сравнения будут работать очень быстро, потому что все заранее отсортировано и имеет строгую структуру. Дерево результатов имеет строгую последовательность исполнения терминальных узлов вверх к родительским. То есть если вы попробуете составить вручную свое дерево результатов какой-нибудь, то вы увидите, что если двигаться от веток, от терминальных узлов дерева к корню дерева, то это по сути есть алгоритм. То есть вот я там пример приводил, что перерезультаты построить дома. Вот по сути, если вы будете выполнять эти действия, которые описаны в ветках дерева, то вы построите в результате дом, то есть получите требуемый результат. В DR сразу видны зависимые последовательные друг от друга процессы и независимые параллельные. То есть когда мы рисуем дерево результатов вручную, то мы сразу понимаем какие процессы последовательные, а какие параллельные. для программирования это кстати очень удобно потому что нарисовав дерево результатов можно сразу понять как бы какие процессы можно запускать в отдельных поток как так то есть вот даже на этом уровне это можно использовать я как программист это постоянно использую потому что когда мне тяжело например спроектировать какой-то код Я рисую дерево результатов и, соответственно, сразу вижу, какие функции у меня выполняются последовательно и их тяжело будет распараллелить, а какие независимые и их легко будет распараллелить. примеры дерева результатов но здесь его три примера я нарисовал самых простых вот я показываю как выполняется дерево то есть от терминального узла до корня вверх приблизиться к яйцеклетке проникнуть внутрь яйцеклетки Оплодотворить яйцеклетку – это дерево для сперматозоида, то есть это очень абстрактное описание и по сути отражает алгоритм для сперматозоида, как оплодотворить яйцеклетку. Кстати, если вы заметите, то же самое, очень похожее дерево будет для ируса. И очень похоже дерево для дверного ключа. То есть приблизиться к отверстию замка, проникнуть внутрь замка, открыть дверной замок. Это дерево для дверного ключа. И, соответственно, я на предыдущем семинаре говорил, что почему Возникают у людей такие ассоциации, что деревья результатов очень похожи, и они сравнимы друг с другом. И, соответственно, и здесь ассоциация включается с перматозоидом. Казалось бы, но очень тяжело понять, что между ними общего. в виде дерева результатов, если нарисовать, то становится понятно, почему такая ситуация. Или вот, например, дерево результатов для воды. То есть мы берем кислород, водород. Для того, чтобы произошла реакция, нужно создать условие, нагреть. Получаем отдельные атомы кислорода и водорода. и они соединяются если находятся близко друг с другом получается вода и вот этот процесс синтеза я дальше покажу как он постепенно усложняясь превращается в офференный синтез то есть вот синтез воды это по сути то же самое что любой другой как бы синтез мыслительных процессах Меня хорошо слышно, а то я просто слышу только тишину в ответ. Все хорошо. Спасибо. Блок синтеза образа требуем результаты действия для его достижения. здесь я в упрощенном виде нарисовал схему как работает блок синтеза он состоит из двух частей условно их можно назвать синтез того что мы уже знаем то есть на основании как бы синтез новые действия на основании тех знаний, которые мы уже знаем. И вот синтез корректирующих действий — это когда мы выполнили какие-то, ну, какие-то уже действия выполнили и не смогли получить требуемый результат, то тогда у нас работает второй блок синтез корректирующих действий. Он корректирует выполненные действия таким образом, чтобы получить требуемый результат с заранее заданной точностью. Ну, может, я не очень понятно объясню, как это работает, но смысл в том, что корректирующие действия, они примерно похожи на то, что происходит, допустим, у артиллеристов. Когда они стреляют один раз, у них снаряд прилетает к цели. Потом они выполняют корректирующие действия. и потом снаряд не долетает. Они еще немножко подкручивают и соответственно с третьего раза снаряд попадает точно в цель. Вот примерно такая же аналогия как работает синтез корректирующих действий. Основная память, которая хранит дерево результатов, она, соответственно, клонируется во временную память дерева результатов. И здесь у нас получается два компонента, которые работают независимо друг от друга и постоянно синтезируют какие-то образы. Это можно назвать воображением. И вот эти два компонента, они работают параллельно. но при этом зависимы друг от друга то есть если мы к примеру захотим проанализировать самих себя как у нас это работает схема я приведу такой пример я например могу куда-нибудь идти или ехать метро допустим и задуматься о чем-нибудь и, допустим, проехать свою станцию или куда-нибудь иду и поверну куда-то не туда. И через некоторое время я понимаю, что я получил не тот результат, который хотел. И, соответственно, начинает работать как раз вот синтез корректирующих действий. То есть включается сознание, и я на сознательном уровне уже понимая то что да я попал куда-то не туда и соответственно нужно скорректировать свою свою траекторию таким образом чтобы прийти туда куда нужно или там вернуться на станцию назад например метро Наверняка это, наверное, не только со мной так происходит, но, в общем, то, что называется блок синтеза, корректирующий действия, это, по сути, есть аналог сознания, как это работает у человека. И, соответственно, синтез просто действий промежуточных результатов, это то, что называется подсознание. Общая схема работы блока синтеза. Синтез действий происходит во временной памяти DR от узла DR с требуемым результатом до текущего результата. В итоге формируется набор проверенных действий, который исполняется блоком исполнения действий. Работу данного блока человек идентифицирует как подсознание или автопилот. То есть здесь из описания понятно, что если мы заранее знаем и уже выполняли какие-либо действия и достигали при этом требуемых результатов, то соответственно нам не нужно обращаться к сознанию, мы всю задачу решаем на автопилоте. Не задумываясь, просто делаем, и у нас все получается. Если промежуточных действий недостаточно или исполненные проверенные действия не достигают требуемого результата, то блок синтеза корректирующих действий создает новые варианты действий в рамках возможного набора действий. Работу данного блока человек комбиницирует как сознание. И, соответственно, вот эти два компонента, они работают независимо, но при этом мы можем их по аналогии с человеческим мозгом наблюдать у себя, как они работают. Если прислушиваться к самому себе, то можно понять, что у нас примерно то же самое происходит в голове. Блок сравнения входных данных с требуемым результатом. Ветви DR требующие сравнения выполняются во временной памяти до получения образа результата. Образ результата сравнивают с образами от входных данных. Варианты реализации алгоритмов сравнений могут быть разные от самых простых до сложных. Здесь как раз одна из полезных характеристик от GIF – это блоки сравнения могут быть самые разные. То есть можно сравнивать вообще очень простым алгоритмом. А можно туда поставить какую-нибудь очень сложную ресурсоемкую нейросеть, которая будет сравнивать входные данные с тем образом требуемым результатом, с которым нам нужно найти что-то похожее. Этот способ сравнения активный. Человек никогда пассивно не распознает, он всегда активно распознает. Чтобы распознать какой-то образ, человеку нужно подвигать глазами, навести резкость. получить стереокартинку максимального качества если глаза просто расслабить то мы получим 2 размытых картинки перед собой то есть нам нужно провести какие-то действия только для того чтобы получить стереокартинку то есть некий образ голове соответственно вот от жив она должна работать точно также то есть она не пассивно распознает а прежде чем распознавать распознать что-то она должна выполнить набор действий даже если эти действия выполняются почти моментально их нужно все равно выполнить то есть система может в голове прокрутить какие-то картинки какие-то 3 трехмерные Ну в общем фактически это как дополненная реальность. То есть в голове, во временной памяти прокручиваются различные действия, получаются образы требуемых результатов и потом они сравниваются. Вот я тут пишу, например, можно покрутить образ пирамидки во временной памяти, одновременно перемещая тело и точку зрения, пока он не совпадет с образом обходных данных. То есть процесс распознавания здесь занимает какое-то время. Но если это реализовано эффективно и быстро, то это может занимать доли секунды, и это будет даже просто незаметно. И здесь опять же возвращаемся более низкому уровню. Это можно представить, как две молекулы соединяются в более крупную молекулу. Обе стороны взаимосодействуют в получении требуемого результата. Вот про молекулы я здесь пишу специально для того, чтобы вы могли представить себе картинку, как работает процесс распознавание через синтез то есть у нас обе стороны синтез и сравните оба блока они работают параллельно независимо но при этом они синхронизируются между собой таким образом чтобы вот как в примере с молекулой две молекулы могли соединиться более крупно то есть прежде чем им соединиться им нужно занять определенное положение в пространстве и занять место в пространстве, то есть они должны находиться достаточно близко между собой и при этом должны выполняться некие условия, при которых эти молекулы смогут соединиться более крупно. Следующий слайд. Молекулы тоже думают. этот слайд как раз для того чтобы можно было еще более детально представить как происходит синтез в данном случае аференный то есть я здесь рассматриваю процесс синтеза как непрерывный процесс от самых начиная от атомов и выше хорошо видно, что это один и тот же процесс, который постепенно усложняется вплоть до ферентной синтеза. Не знаю, сможете вы это представить или нет, но мне как программисту это видно, что все очень похоже. атомы молекулы более крупные молекулы и так далее то есть это все ведет себя одинаково и когда это все превращается какую-то сложную систему уровня центральной нервной системы то не уже возникает эфиренный синтез который по сути продолжение вот этих всех процессов только на намного более высоком уровне. Начнем с синтеза воды. Например, для синтеза воды нужно обеспечить наличие молекул кислорода и водорода, затем поджечь. То есть поджечь в том смысле, что нужно создать условия для синтеза. Точно так же в аджифе чтобы блок синтеза корректно работал он должен иметь определенные условия чтобы у него все получалось то есть просто так там если ну то есть иначе он просто превратится в генератор случайных чисел то есть если не создать условия для корректного синтеза целенаправленного то это просто будет ну просто мусор на выходе клетки создает еще более сложные условия для еще более сложных процессов синтеза внутри клеток. То есть понятно, что молекула ДНК, к примеру, не сможет существовать, если клетка не создает условия для существования этой молекулы. нейроны создают условия для быстрой передачи сигнала от одной клетки к другой. То есть здесь тоже достаточно сложный процесс происходит передачи, но вот коротко его можно описать следующим образом, что нейрон существует именно для того, чтобы сигнал быстро передавать от клетки к другой клетке, потому что химическими веществами как это делает, к примеру, муравьи, сигнал от клетки к клетке передавать достаточно долго. И, соответственно, природа, видимо, придумала такой способ, как ускоритель передачи сигнала. То есть нейроны, по сути, это и есть ускоритель передачи сигнала. Нервная система организма в целом создает условия для эфферентного синтеза. То есть вся центральная нервная система человека, ну и не только человека, а многих других, фактически всех живых существ, у которых есть нервная система. Она создает условия для эфиретного синтеза, то есть любое существо, Оно всегда активно и оно все время пытается что-то делать, двигаться и так далее. То есть это, по сути, сначала идет синтез афферентный, а потом уже идет процесс сравнения. То есть сравнение вторично. Блок исполнения действия. Он самый простой. Он передает команды из временной памяти на внешние исполнительные механизмы. Временная память DR – это память, в которой выполняются различные операции с частями основного дерева результатов. Это сравнение веток, выполнение веток, операции перестановок частей веток, синтез новых веток, удаление ненужных веток. Временная память – это, по сути, воображение и место, где наблюдается процесс мышления. То есть это легко представить, потому что мы с этим процессом сталкиваемся постоянно. То есть если мы хотим что-то себе вообразить, вот этот весь процесс происходит у нас как раз во временной памяти. То, что у нас называется воображение. И аналогия здесь опять прямая с человеком, то есть если отключить входные и выходные данные, то у системы начнутся галлюцинации, они же сны. Так как процессы синтеза веток дерева результата будут продолжаться, но без синхронизации с окружающим миром. здесь тоже наверное достаточно просто все понять потому что если у нас процесс синтеза никак не прерывается он существует сам по себе то галлюцинации у нас похоже отвалился спикер 

S05 [00:33:03]  : Если я ничего не понимаю. Нет. Виктор, вы нас слышите? Виктор, мы вас не слышим. 

S03 [00:33:15]  : Сейчас слышно? 

S05 [00:33:16]  : Да-да, сейчас снова слышно. Все, продолжаем. 

S03 [00:33:21]  : Так, еще раз, значит, переменная память – это, по сути, воображение и место, где наблюдается процесс мышления. Если отключить входные и выходные данные, то у системы начнутся галлюцинации, так как процессы синтеза веток DR будут продолжаться, но без синхронизации с окружающим миром. Естественные процессы сна очень легко объяснить, если мы понимаем, что у нас эфферентный синтез происходит постоянно. Не наоборот, как это привыкли думать. Сначала распознавание, которое вызывает какие-то процессы в голове. В данном случае все наоборот, то есть если у нас идет синтез, то у нас все время есть галлюцинации и сны. Соответственно, если мы подключаем входные и выходные данные, то есть синхронизируем с окружающим миром, то у нас галлюцинации прекращаются и начинается нормальный процесс мышления, то есть он синхронен с окружающей средой. Таким образом происходит коррекция ошибок при обучении в дереве результатов. Вот, опять же, главное свойство ДР и здесь играет важную роль. Нельзя получить родительский результат без достижения всех дочерних результатов. если мы в процессе выполнения ветки dr не смогли получить требуемый результат то мы не сможем двинуться дальше Если исполнить ветку DR, то в итоге получим набор лиц соседних пересекающихся веток, корешки которых стремятся к нормальному распределению. Каждый раз пытаясь выполнить ветку, которая наиболее близка к вершине кривой Гаусса, система будет стремиться к улучшению требуемого результата за счет работы блока, корректирующего действия. Сознательная коррекция. вот я уже ранее говорил то что это можно представить перелет недолет попал то есть здесь нормальное распределение но в принципе тоже работает но это как сказать, это достаточно просто представить, потому что система выполняет какие-либо действия и если эти действия проверенные, то мы попадаем в вершину кривой Гаусса или близкие к вершине. А если это действия не очень проверенные и более случайные, то мы соответственно отклоняемся все больше в сторону до тех пор, пока мы просто-напросто не сможем получить требуемый результат. А если мы не сможем получить требуемый результат, мы не сможем продвинуться дальше на уровне выше по дереву. И, соответственно, до тех пор, пока не получим правильный требуемый результат с нужной точностью, мы не продвинемся. На этом фактически остановимся. Поэтому здесь особо сложной коррекции ошибок при обучении не требуется, потому что у нас процесс останавливается, если мы не получаем требуемый результат. И отсюда же возникает повторяемость результатов. То есть если у нас ветка дерева проверена и выполняя ее мы получаем требуемый результат с заранее заданной точностью. то тем самым мы получаем свойства повторяемости результатов. То есть мы из раза в раз выполняем одну и ту же ветку, либо какие-то группы соседних веток очень похожи друг на друга. И каждый раз мы получаем результат с нужной точностью. То есть при выполнении веток DR движение вверх по DR в сторону корня невозможно, пока не достигнут ближайших требуемых результатов. Это свойство обеспечивает повторяемость всех промежуточных результатов при движении к конечному требуемому результату. При этом точность достижения дочерних результатов возможно сознательно регулировать при помощи блока синтеза, корректирующего действия. То есть здесь от GIF дает возможность корректировать точность достижения, то есть мы не константу для всех требуемых результатов где-то записываем в программе и всегда как бы с одной и той же точностью работаем, а мы можем эту точность изменять. К примеру, люди Хирурги имеют более точные движения, чем обычные люди, потому что они натренировались этим движением. И, к примеру, обычный человек не сможет выполнить хирургическую операцию, хотя конструктивно он тот же самый человек, но операцию хирургическую он выполнить не может, потому что у него недостаточная точность движений. и вот здесь в аджифе есть возможность эти движения делать более точные достаточно простым способом 

S05 [00:39:11]  : Так, Виктор, мы вас снова не слышим. 

S03 [00:39:17]  : Антон, как слышно? Сейчас нормально. Часто задают вопрос, чем отличаются мои подходы от генетических алгоритмов. По сути, генетический алгоритм – это алгоритм оптимизации. Я как программист понимаю, что дальше оптимизация, кроме как использовать его по назначению его не имеет смысла и соответственно киндийский алгоритм в аджифе можно использовать вот в тех местах где он будет необходим то есть например для оптимизации параметров действия и образов требуемых результатов. Но, соответственно, нельзя генетические алгоритмы путать с отживой. То есть тут ничего общего нет. Кроме того, что алгоритмы оптимизации нужно использовать в тех местах, где они нужны. Вот, собственно, и все. Какие могут быть задачи для аджифа? Задача падающего ключа. Я эту задачу довольно часто привожу в своих кабах. при общении своими коллегами. Сложная задача в том, что когда ключ падает на пол, нельзя заранее обучиться, научить систему поднимать ключ, потому что он все время падает в разные места. И здесь есть большая проблема, потому что какие-либо то есть нейросеть например просто так не обучить искать ключ каждый раз в новом месте то есть здесь нужно как это какой-то комплексное решение которая в любом случае решает эту задачу. То есть люди, когда роняют ключ, они очень просто его берут, поднимают, открывают самок, все. Вообще не думая на автопилоте. Но современные алгоритмы, они не позволят это сделать простым способом. Хотя можно написать программу, которая это делает, но это будет уже никакой не искусственный интеллект и не общий интеллект, а это будет просто программа. Аджифа с такой задачей справится. То есть она за счет того, что она все время синтезирует новые решения на основе старых знаний, ее можно научить поднимать ключ из самых разных мест. Ну, если, соответственно, будет какое-то тело, которым Аджифа будет управлять. Задача управления движением глаз. Здесь опять то же самое, то есть траектория движения глаз, они похожи на случайные, потому что по сути они каждый раз новые. Требуется управлять глазами так, чтобы две картинки выглядели как одна, за исключением частей разных из-за разных точек зрения. Есть сложность в том, что траектории движения глаз будут все время разные, так как объект поля зрения может находиться ближе, дальше, левее, правее и так далее от глаз. Невозможно запомнить все возможные варианты. То есть, если мы возьмем какую-нибудь нейросети, попробуем ее просто обучить, управлять движением глаз, решая задачу в лоб, то, скорее всего, у нас это не получится. 

S05 [00:43:04]  : Виктор, снова пропали. 

S03 [00:43:07]  : Да, что-то связь рвется. Да, сейчас слышим. Алло. Так, значит, да, я здесь. То есть задача управления движением глаз, она сложна тем, что невозможно запомнить все возможные варианты. Единственное, что здесь постоянно, это образ требуемого результата, величина допустимых отклонений картинок друг от друга. А значит от GIF'а все необходимые дочерние варианты веток дыр может синтезировать за ограниченное время. То есть это для от GIF'а задача решаемая, потому что она не будет запоминать все комбинации вариантов движения глаз, она просто придумает новые. за ограниченное время. Но так как у людей это работает достаточно быстро, в Adjif это тоже будет работать, просто я как программист могу точно сказать, что это делается быстро. Задача обучения речи. Здесь несколько как бы на первый взгляд неоднозначны, наверное, будут потом вопросы, но с точки зрения архитектуры AGIF слышать и говорить это одинаковый процесс синтеза DR, то есть когда мы делаем распознавание через синтез, мы по сути для того чтобы слышать мы учимся слушать мэра странно это звучит но то есть мы когда синтезируем деревья результатов, мы обучаемся слышать. И это можно примере людей показать, что композитор, например, имеет слух намного более развитый, чем любой другой обычный человек, который не тренировался. Ну и, соответственно, какой-нибудь музыкант, он, соответственно, тоже имеет слух натренированный, то есть он намного больше слышит, чем обычные люди. Хотя, казалось бы, у всех людей уши одинаковые, но при этом они эти уши используют по-разному. но, видимо, за счет того, что они распознают звуки через синтез. То есть они деревья результатов синтезируют таким образом, чтобы лучше слышать именно то, что им нужно слышать. Ну и, соответственно, говорить это то же самое, что и слышать. то есть слышать синтез цветок DR максимально похожих на входные данные от уха. Говорить синтез цветок DR опять максимально похожих на входные данные от уха, но с задержкой по времени. То есть мы обычно как учимся говорить, то есть мы слышим какой-то звук, потом, так как у нас синтез все время работает, афферентный синтез, он не может остановиться, и соответственно мы пытаемся повторить услышанное повторяем уже выполняя какие-то свои собственные действия то есть мы пытаемся управлять своими мышцами и у нас получается какие-то звуки из потом за счет того что мы постоянно корректируем действия мы постепенно приближаемся к тому, что мы должны услышать. И блок сравнения у нас сравнивает потом то, что мы услышали и то, что мы сказали. То есть сами себя мы тоже слышим. И получается такой циклический процесс. постепенным приближением к требуемому результату. То есть мы услышали, сказали, опять услышали сами себя, сказали, услышали, сказали, ну и так далее. Через какое-то количество итераций у нас данные будут очень похожи. То есть то, что мы слышали, то, что мы сказали, образы требуемых результатов будут сравнимы с достаточной точностью. Таким образом мы научимся говорить. И у попугая происходит, по сути, то же самое. То есть у него ограничены возможности по сравнению с человеком. То есть он не может запомнить много слов, не может сказать слова с требуемой для нас, привычной, скажем так, для нас точностью. Но, тем не менее, он достаточно хорошо умеет повторять звуки. И там какое-то количество слов он тоже может сказать. И, соответственно, он даже может эти слова использовать в контексте. То есть он, по сути, иногда люди думают, что попугаи достаточно умные и говорят правильные слова и даже фразы по делу. То есть используют контекст. То есть тот процесс очень простой. И, соответственно, если его реализовать в Adjif'е, то мы сможем ее обучить разговаривать. То есть здесь нет никаких препятствий для того, чтобы Adjif научилась говорить. вот тут здесь описание задачи распознать цифры на спине не знаю наверное многие играли в эту игру детскую когда один ребенок на спине рисует а другой не видит нарисованная и пытается угадать что ему на спине нарисовали что делать если обучение цифрам произошло по одному канал одны данные глаза требуется распознать по другому каналу спина то есть тут казалось бы входные данные разнотипные то есть один канал это зрение другой канал сильное ощущение на спине и на самом деле обучение произойдет не на сетчатке глаз и зрительной кореи а синтезируется ветка бер управляющий движением глаз то есть когда у нас на спине что-то рисуют мы просто в это же время как будто бы двигаемся глазами по этой траектории и за счет распознавания вот этой траектории движения глаз мы можем понять что у нас нарисовано на спине более сложные картинки если нарисовать там допустим разными красками естественно мы распознать в принципе не можем потому что мы здесь распознаем только движение то есть сравниваем две траектории движение глаз и движение там пальцы по спине эта ветка DR будет инвариантной к изображению на спине, на щетке глаз. То есть делая многомодальные системы, мы можем каким-то более сложным способом распознавать входные данные. То есть мы можем решать не только вот такие простые задачи, но и какие-то намного более сложные. задачи обучения чему-нибудь в этом слайде я хочу показать что от жив она потенциально может учиться любым задачам ее можно научить решать любые задачи Из архитектуры отжива видно, что данная система потенциально может научиться решать практически любые задачи. Почему? Потому что образ требуемого результата ничем не ограничен и может быть сколько угодно сложным. Теория результатов ничем не ограничивается и может быть сколько угодно большим и сложным. На самом деле, наверное, не дерево результатов, а лес результатов. я просто описываю дерево чтобы сконцентрировать внимание вот только на отдельном кусочке дерева чтобы но лес уже очень трудно представить потому что это скажем так очень сложный образ многомерный ветка dr это фактически привычный всем алгоритм имеющий ряд ограничений для более простого его использования то есть допускает реализацию на любой привычной компьютерной архитектуре здесь тонкость в том что вот такая простая структура данных она очень просто реализуется и так как у нас современные процессоры стали уже очень быстрые и многоядерные это все очень легко распараллеливать намного ядер и можно не использовать какие-то специальные ускорители там графические к примеру можно все делать на обычных процессорах и это будет работать достаточно быстро ну скажем так быстро для того чтобы это можно было использовать на практике чтобы это было полезно Реализация блока сравнения входных данных с требуемым результатом. Здесь большой плюс в том, что блок сравнения можно реализовать самыми разными способами. Он может быть реализован просто как сравнение двух многомерных множеств, то есть это просто обычная стандартная функция в компьютерах сравнить два множества. Сложность реализации будет зависеть от того, сколько различных параметров требуемого результата надо извлечь из входных данных. Например, для человека требуется извлекать много параметров. Сложность зрительная кора для лягушки мало, для мухи еще меньше. По сути, на этом слайде мы можем понять разницу между интеллектом разных живых существ. у чека блок сравнения очень сложный потому что у нас очень сложное зрение цветное стереоскопическое мы за ограниченное количество времени, какие-то доли секунды исходных данных, извлекаем огромное количество параметров своей зрительной корой. Так как у лягушки тело намного проще, ей не нужно много данных, и у нее система зрения намного проще, и блок сравнения тоже намного проще. Ну, у мухи там вообще фосейчатый глаз, там совсем всё просто работает. Во всех случаях от GIF одинаков, меняются только способы реализации отдельных модулей. То есть, смысл в том, что архитектура, она постоянная и одинаковая у всех. Но если сравнивать с живыми существами, это пока недоказуемо, но я предполагаю, что у всех живых существ архитектура интеллекта, она одинаковая. То есть меняется только сложность отдельных модулей. К примеру, система зрения по сложности у всех очень сильно разная. Реализация предсказаний в дереве результатов. Основной способ планирования будущего в DR это синтез новых веток DR на основе предыдущих успешно выполненных. Это выглядит как продвижение зоны внимания от кончиков веток к корням деревьев. Зона внимания – это часть DR, которая находится во временной памяти. То есть у нас есть некая большая основная память. Она меняется не так часто. по сравнению со временной есть два модуля временной памяти где у нас постоянно что-то крутится вертится но это то что воображение там постоянно все меняется до тех пор пока мы не синхронизируемся с реальностью то есть до тех пор пока не получим требуемый результат так как ветки dr порядочные то части предыдущих веток могут быть использованы как параметры определяющий выбор направлений для синтезируемых последующих то здесь вот эта фраза достаточно важная потому что она предполагает только целенаправленный пояс но и когда мы знаем какие-то предыдущие параметры с предыдущей истории берем то мы можем менять направление дальнейших действий тот момент когда мы еще не знаем сможем ли мы достигнуть требуемый результат либо нет но это примерно как в сказках налево пойдешь коня потеряешь направо пойдешь там еще чего-то и так далее когда есть выбор но мы не знаем какой вариант выбрать мы используем предыдущие знания для того чтобы сделать выбор не обязательно от выбор будет правильный но тем не менее это хоть какое-то решение будет Многомодальная реализация будет выглядеть более интересно, потому что пересечение различных вариантов предсказания позволяет блокировать синтез заведомо нереалистичных предсказаний. То есть многомодальная реализация будет давать более точные прогнозы. Но здесь, опять же, основное свойство работает. Нельзя получить родительский результат без достижения всех дочерних результатов. То есть если у нас часть каких-то предсказаний, скажем так, не попадает в требуемый результат, то мы их отбрасываем и получаем более правильные предсказания за счет оставшихся. Реализация GIF для систем реального времени. С принципиальной схемы GIF видно, что наиболее ресурсоемкий компонент это блок сравнения входных данных с требуемым результатом. В живом мире прослеживается прямая зависимость сложности блока сравнения от сложности организма. У простых организмов простая реализация, у сложных сложная. Таким образом, всегда можно выбрать такую реализацию отдельных компонентов поджива, которая обеспечивает решение требуемых задач в требуемое время. Здесь идея в том, что... архитектура анжи фа позволяет под какую-то конкретную задачу выбрать такие компоненты которые гарантированно смогут выполняться в реальном времени здесь нет никакой проблемы как бы когда мы подключаем какую-то нейросеть и она там думает там целый день допустим до чего-то делает учиться или там еще что-нибудь мы соответственно если нам нужно реальное время мы эту нейросеть просто не будем использовать мы будем использовать другой компонент который нам даст гарантированное реальное время вот собственно и все то есть Здесь мы не зависим от компонентов, от существующих, а наоборот под задачу выбираем требуемый компонент. Здесь идеология опять же обратная, то есть есть архитектура, которая в целом работает и дальше задача стоит в том, чтобы выбрать компонент, заранее известным известной производительностью и все и дальше будет все работать так как требуется здесь идея этого слайда в том что когда я спроектировал ну вот это как бы вот такую архитектуру это было достаточно давно у меня появились мысли каким же образом может придаваться память по наследству если у нас информационная емкость днк ограничена И при этом видно, что простые существа сразу приспособлены к выживанию, а сложные, наоборот, совершенно беспомощные, без родителей не могут выжить. То есть на чайке это как раз очень сильно заметно, то что человеческий ребенок рождает совершенно беспомощный, то есть он вообще не умеет ничего практически, за исключением там нескольких инстинктов, которые обеспечивает его базовую выживаемость. И наоборот, более простые существа, они только родились, сразу побежали. Поэтому гипотеза, что может передаваться посредством ДНК. Если есть механизм синтеза промежуточных действий, как ланджифа, то в ДНК достаточно запомнить только ствол дерева результата, состоящий из компактных образов стволовых требуемых результатов. То есть мы корень дерева запоминаем, а все остальное нам необязательно запоминать, потому что алгоритмом синтеза мы все равно получим то, что нам требуется. И эта гипотеза, она, в принципе, очень похожа на правду, потому что, ну, может быть, ДНК не в виде дерева результатов запоминает и как-то иначе, какой-то там более правильный какой-нибудь способ существует. наверняка вот сам процесс очень похожи то есть мы запоминаем какой-то корень и все остальное нам мы не запоминаем и в процессе роста организма мы все нужное нам синтезируем кстати говоря когда организм растет, он использует то же самое правило терриорезультатов, пока нельзя получить родительский результат без дотяжения всех дочерних результатов. когда организм растет он допустим в росте останавливается какой-то момент может остановиться в росте чуть раньше или чуть позже то есть но в любом случае он когда срабатывает сравнение то чего получилось той формы которая получилась тем образом требуемого результата который нужен то есть он где-то записан днк то тогда рост организма прекращается ну и соответственно могут быть какие-то отклонения то есть большую или меньшую сторону там у кого-то это может естественно сломаться сравнение и организм перестанет расти раньше чем положено то есть вот это вот это правило но здесь тоже работает и когда мы к примеру повреждаем тело поцарапали к примеру то клетки начинают заполнять ранку опять же подчиняясь этому правилу то есть когда ранка будет заполнена и блок сравнения некий до условный непонятно как реализованный скажешь что мы достигли требуемого результата и пора прекращать рост клеток на этом рост остановится то есть здесь опять же есть синтез есть сравнение и есть требуемый результат которые нужно достичь. И, соответственно, если мы запоминаем только ствол, дерево, результатов, то мы, по сути, можем решить вот эту задачу, передать память по наследству. Таким образом, чтобы этот объем памяти поместился на большую молекулу ДНК. И последний слайд. Здесь коротко предыстория от GIF. Вот эта архитектура, которую я здесь описал, она возникла достаточно давно. и я там некоторые компоненты тоже достаточно давно проверил и так как я одиночку это все естественно сделать не смогу в таком объеме то я сконцентрировался на маленьком маленькой задачи которую называет самодоста проект самодостаточно и и этот проект называется ли бастер это следующий шаг после отжима то есть полностью самодостаточный саморазвивающийся разум то есть это то есть уже не аджиф, а следующий шаг, но при этом принципы, которые заложены в аджифе, они в самодостаточном и тоже используются. То есть это представление данных в виде DR, многомерные образы требуемых результатов, распознавание через синтез и все решения время на время, то есть там требования клейбастера все должно работать в реальном времени потому что это как бы компонент который должен управлять некими живыми условно живыми существами но роботами живыми роботами почему живыми потому что они способны к саморазвитию вот как так на этом все я теперь готов ответить на все вопросы либо вернуться к отдельным слайдам и рассказать более подробно 

S05 [01:06:33]  : Виктор, спасибо. У меня вопрос, знаете, какой? Может быть, если меня поддержат, то, прежде чем мы перейдем к дискуссии, обычно народ жалуется, что у нас приходят теоретики, которые рассказывают некоторую теорию, как должно быть на самом деле, а на самом деле у них ничего не работает. То есть, это все теоретические построения. Насколько я понимаю, то, что вы рассказываете, как должно быть, вы еще некоторым образом проверяете на практике. Соответственно, видите ли вы целесообразность, и, может быть, там сообщество тоже сейчас выскажется, завершить ваш доклад какой-то демонстрацией чего-то работающего, с соответствующими комментариями. Или вы просто отошлёте к видео по этим ссылкам, чтобы желающие ознакомились. Просто было бы на самом деле интересно, чтобы весь этот доклад выглядел логичным именно с некоторыми комментариями. Потратить какое-то время на демонстрацию каких-то типичных... Давайте тогда с вашими комментариями. Парочку, троечку примеров. А у вас, видимо, расшаривается только презентация, а не весь экран, поэтому мы сейчас ничего не видим. Вам надо или перерасшарить, или расшарить весь экран, предварительно убрав открытые окошки с паролями. Вот сейчас видно? 

S03 [01:08:37]  : Ну, в общем, вот как это работает. еще раз подчеркну что самодостаточный интеллект это вот экстремальный совершенно вариант потому что не скучно заниматься простыми вещами я занимаюсь сложным вот поэтому я вот придумал себе такую тему что вот создать компонент который управляет некими живыми роботами. И к этим роботам есть список требований. Я на Зен-канале перечислил все эти требования. 

S05 [01:09:18]  : Может быть вы сейчас пократко озвучите. Первый вопрос, что находится на вершине дерева результата у этого товарища, которого мы наблюдаем. И какие требования, какие ограничения вы закладываете в эту историю? 

S03 [01:09:38]  : Самое сложное требование, которое я закладываю в этот компонент самодостаточный, это обучение без учителя. Это самодостаточный интеллект, он должен выжить сам. Из этого следует, что должна быть полностью пустая база данных, вообще пустая и единственное что я какие данные я передаю это передаю вот данном вот данной модели я передаю даю на вход всего лишь два образа требуемого результата то есть это занять высоту над поверхностью земли и координаты точки куда нужно попасть Когда я рассказывал про ДНК, что хранится в ДНК, вот это как раз по сути оно и есть. То есть я даю ему всего два образа требуемого результата, то есть корешки деревьев, и он должен выполнить эти задачи. 

S05 [01:10:53]  : А сразу вопрос, то есть с точки, куда он должен попасть, понятно, а зачем высота? 

S03 [01:11:00]  : Высота для того, чтобы он шел, а не полость по земле. То есть для того, чтобы это выглядело более презентабельно. То есть можно высоту не задавать, тогда он придумает какой-то способ перемещения по поверхности земли. но для того чтобы это выглядело хоть как-то похоже на живое существо я еще даю высоту чтобы он сначала поднялся на нужный уровень над землей а дальше начал перемещаться Вот представьте, рождается существо, у него всего два корешка в памяти его ДНК и больше ничего нет. Об окружающем мире он вообще ничего не знает, база данных у него полностью пустая, у него есть только ферентный синтез, больше ничего. 

S05 [01:11:58]  : корешка вы имеете ввиду вот этих вот вершин дерева результата или корня дерева результата всего два образа требуемых результата А вот сразу вопрос, с конца начнем. Евгений Бабарыкин спрашивает, у Вас сейчас показана начальная стадия обучения страуса, а есть примеры того, как он уже марширует бодро? То есть, он в состоянии до такого уровня дойти? 

S03 [01:12:30]  : Еще раз можно, а тут просто поменьше. 

S05 [01:12:33]  : Есть ли у вас примеры того, где страус уже научился ходить и более уверенно шагает? 

S03 [01:12:39]  : У меня есть разные варианты, но там, где он совсем очень красиво шагает, у меня таких нет. Совсем красиво. Почему? Потому что человек ожидает свое понимание, как правильно шагать. Страус шагает несколько непрезентабельно. Поэтому, скажем так, людям не всегда это нравится, потому что они считают, что это ничего не работает. На самом деле у меня задача несколько другая, то есть у меня создать систему, которая самодостаточная, то есть она способна выжить, но не обязательно это будет красиво с точки зрения человека. 

S05 [01:13:27]  : Здесь, знаете, какая мысль есть, прежде чем мы вернёмся и пойдём вопросам по порядку идти сначала. Под впечатлением семинара, который был в группе у Григория Сапунова на прошлой неделе, я не знаю, смотрели вы его или нет, но у них там тоже разные такие существа, похожие на ваши, только без крыльев, учились ходить и даже двигать предметы в заданную точку. Но у них там была конкуренция. То есть, там у них не нужно было задавать высоту. Потому что даже если ты не задаешь высоту, но таких страусов много. то те, которые научатся ходить, а не ползать, они будут решать задачу быстрее. И в результате естественного отбора останутся только те, кто умеют ходить. А те, которые умеют только ползать, они в конечном итоге не оставят потомства. А из тех, кто умеют ходить, те, которые будут ходить стройно и уверенно, бодрым шагом, а не скакать в припрыжку, они опять-таки получат конкурентные преимущества, потому что они будут достигать своих точек быстрее. А те, которые подпрыгивают несуразно, они тоже отсеются в процессе эволюции. Таким образом, у нас реализуется тот принцип, что красота на самом деле – это эволюционная эффективность. И вот как раз коллеги в той статье, которую обсуждали, они это демонстрировали в качестве эксперимента, по-моему, в той же самой Unity. Это в Unity уже у вас сделано, да? Да. 

S03 [01:15:12]  : Антон, здесь у меня несколько расходятся с мейнстримом, моя позиция. требования к самодостаточному и система должна быть одна то есть она вот родилась она должна выжить но это не запрещает сделать тысячу таких страусов причем с обменом знаниями между собой они легко могут передавать то, чему научились друг другу. То есть если, допустим, тыщу запустить таких страусов, то наверняка один из тысяч им будет очень красиво бегать. Но просто я решаю задачу, чтобы он именно один выжил. То есть с генетическими алгоритмами там все просто, ты надел миллион нособей, кто-нибудь да выживет. будет двигаться красиво, но это не очень правильно, потому что все-таки особь одна, и она должна как-то суметь существовать. Почему? Потому что это более практическая задача, когда одна. Представьте, там на Луну прилетает робот, он один, луноход. И что? То есть там нет их ста тысяч луноходов, понимаете? 

S05 [01:16:31]  : Нет, это абсолютно понятно. Я просто зацепился за то, что вы задали вот эту пресловутую высоту, и это, с точки зрения идейной чистоты, выглядит как некоторый костыль. То есть, вы не хотите, чтобы он ползал, а хотите, чтобы он ходил, и вот даете ему некоторую подсказку. даете ему дополнительный корешок, который на самом деле не нужен. То есть, может быть, если бы вы смогли бы организовать среду таким образом, чтобы эта среда давала ему естественным образом некоторый фидбэк или некоторую обратную связь, что вот если он будет ползать у него что-то будет хуже, то ему будет больно от того, что у него туловище терется об землю, и поэтому он будет стараться избежать неприятных соприкосновений с землей и постепенно научится ходить без этого костыля в виде дополнительного корешка. Я вот к этому подвожу. 

S03 [01:17:27]  : Вот этот фидбэк – тереться об землю – это еще больше костыль. Вы предлагаете один кастинг на два других. 

S05 [01:17:41]  : Ну ладно, это уже тогда дискуссия начнется. Давайте сейчас перейдем тогда к вопросам. Вопрос первый от Евгения Бабарыкина. В каком формате данные у вас хранятся? То есть, технически, как я понимаю, реализация. 

S03 [01:17:57]  : В формате. Ну то есть деревья. Деревья результатов. 

S05 [01:18:04]  : Ну это какой-то ваш собственный формат или ваша собственная база данных? 

S03 [01:18:08]  : Ну да, свое собственное. Самодостаточные мои, я там не использую ничего стороннего. 

S05 [01:18:20]  : То есть, ваш собственный... И, соответственно, база данных тоже какая-то ваша собственная. Какая-то сериализация ваших собственных объектов. Хорошо. Вот здесь я сразу записался на несколько вопросов, но я их позже буду задавать. Первое. Когда вы задавали вопрос про распознавание, что распознавание – это, на самом деле, коферентация. Я правильно понимаю, что вы реализуете то, что в других местах называется активное распознавание, то есть, active perception? То есть, мы распознаем что-то только через взаимодействие с этим? Или об этом о другом речь идет? 

S03 [01:19:05]  : Еще раз, не все слова понятны. 

S05 [01:19:09]  : Есть такое понятие active perception или активное восприятие, когда мы воспринимаем реальность только через взаимодействие с этой реальностью. И что то, что мы видим и то, что мы чувствуем – это результат просто нашего воздействия на окружающую реальность. 

S03 [01:19:26]  : то есть группы но я не по понятен вопрос или нет но в целом да но просто он немножко все усложняет наверное маджика я предлагаю более простой вариант то есть есть синтез есть блок сравнения и собственно все то есть и это все работает простым понятным способом то есть синтезируем сравниваем результат с тем что приходят на на вход и делаю вывод насколько это похоже то есть это все очень просто 

S05 [01:20:03]  : А синтез идет от вот этого исходного корешка, правильно? Да. 

S03 [01:20:08]  : Хорошо. Смотрите, чтобы понять, как, нужно в правилах гериорезультатов разобраться. То есть, с одной стороны, от корешка, а точнее, более правильно сказать, к корешку. 

S05 [01:20:22]  : Ну, это понятно, это смотря с какой стороны смотреть. Хорошо, следующий тогда вопрос про корешок. Я правильно понял, что в терминах предыдущего докладчика про загадочные модуляторы, вот там, где у него нарисованы вот эти вот кружочки с модуляторами, у вас как раз находятся корешки. 

S03 [01:20:47]  : я смотрел эту презентацию но я вот прям так аналогию наверное не смогу провести потому что у него там очень мутная схема но я не хочу критиковать просто вот прям напрямую нельзя провести аналогию 

S05 [01:21:04]  : Окей. Еще один вопрос. Вы сказали, что у вас структурированное хранилище. У вас структурированное хранилище с взвешенными связями и структурами или не взвешенными? То есть, я что имею в виду? У вас есть вероятностные какие-то оценки или нечеткие оценки силы или значимости этих структур или нет? Если нет, то как быть с нечеткими знаниями, которые имеют статистическую выраженность? 

S03 [01:21:41]  : явном виде этого нет я когда на слайде про нормальное распределение объяснял как это происходит там вот статистические результаты они как раз вот дают множество деревьев которые находятся рядом и они пересекаются вот эти корешки они дают нормальное распределение и Вероятность здесь не требуется считать, потому что нам не нужна вероятность, нам нужен образ требуемого результата с достаточной точностью. Это большая разница. Представьте, хирург управляет своими пальцами с какой-то вероятностью, но это очень странно. Это вообще такого быть не может. вот хирург он смотрит в микроскоп который например нервы оперирует он видит увеличенное изображение и он свои пальцы двигает совсем по чуть-чуть то есть там нет никаких вероятностей там исключительно высоко точные движения точность движений можно достичь только приближением образу требуемого результата с нужной точностью я понятно объясню нет 

S05 [01:23:08]  : Понятно, есть вопросы, но давайте я отдельно потом задам, если время останется. Есть дальше вопросы у Юрия Бабурова, точнее комментарии, но я его тоже превращу в вопрос. Он пишет, что для такой задачи не нужен C++, поскольку C++ просто замедляет разработку и добавляет трудновыявляемые ошибки. Соответственно, с чем вызван C++? Вам на этом удобнее делать или требования по производительности, или какие-то другие соображения есть? 

S03 [01:23:46]  : ну основные компоненты наверное можно писать не только на си плюс плюс но и на чем-то другом но какие-то ресурс кай ресурсоемкие задачи наверное все-таки си плюс плюс там вариантов просто нет но у вас это у вас ресурсоемкость требуется вот в том что вы сейчас делаете в самодостаточном и требуется. Если мы говорим о каких-то более сложных задачах, то есть там, например, распознавание речи или изображение в реальном времени, то там, наверное, тоже нужно эффективно использовать процессор, а не просто как обогреватель воздуха. 

S05 [01:24:36]  : Хорошо. Про блокчейн. Блокчейн это дань моде или есть какие-то реальные применения с вашей точки зрения? Насколько я понимаю немножко в сторону вопросу, раз уж вы упомянули, то здесь Юрий Бабуров тоже спрашивает. 

S03 [01:24:53]  : Я много видел вопросов и обсуждений применения искусства интеллекта на базе блокчейна. Несколько лет назад я тоже был в недоумении, для чего это нужно и так далее. Там на самом деле больше маркетинга, чем реальные пользы. требуется делать какие-то базы данных, которые тяжело подделывать и они не требуют высокой скорости доступа к данным, то блокчейн в принципе тоже нормальный вариант. И дерево результатов его в принципе тоже можно записывать на блокчейн, но достаточно эффективно. То есть это как вариант для тех, кто очень просто хочет на блокчейне поднять искусственный интеллект от дерева результатов подходящего инструмента. 

S05 [01:25:57]  : Хорошо, то есть это просто такая база данных. 

S03 [01:26:01]  : Но она медленная, кривая, но, тем не менее, на блокчейне можно сохранять результат. 

S05 [01:26:08]  : Дальше здесь вопрос от Владимира Смолина. Я не очень понял его про муравьев. Что у муравьев тоже есть нейроны, около одного миллиона. Вся передача сигналов по нейронам химическая у всех животных. Чем муравьи не такие, как все? 

S03 [01:26:30]  : чем муравьи не такие как все. – Я не понял, честно говоря, вопрос, при чем здесь муравьи и… – Смотрите, в самодостаточном интеллекте я тоже иногда говорю про муравьев. потому что это муравейник и по сути распределенная система искусственного интеллекта. То есть это один большой супермозг, стоящий из маленьких деталей, которые еще и ползают. Но современным программистам это легко представить, потому что сейчас уже все в облаках, а что такое облако, никто друг другу объяснить не может. Облако и все. А здесь по сути муравейник. Но в реальности, если совсем уж провести аналогию муравейника и страуса, то страус это тоже муравейник, потому что его компоненты независимы друг от друга. То есть это не одна система, а множество компонентов, которые взаимосодействуют друг с другом. То есть это такой экстремальный вариант. муравейника, который еще и ходит и крыльями машет. 

S05 [01:27:42]  : Ну хорошо, у муравьев все-таки есть матка, которая каким-то образом, значит, отдельный вопрос, каким муравьями управляет. 

S03 [01:27:52]  : А она ли управляет муравьями? Мне кажется, что совсем нет. Она свою функцию исполняет, а муравейники, наверное, все-таки сам по себе. 

S05 [01:28:07]  : Хорошо, но все-таки кто является носителем этого центрального корешка? 

S03 [01:28:16]  : у каждого у каждого узла есть центральный корешок но смотрите если у нас есть в каждом уровне процессы синтеза какие-то да там понятно что у него память ограничена он не может там сделать там какой-то супер дерево он может построить там маленькие кустики соответственно обмениваясь муравьев друг с другом химическими веществами они могут вместе выстроить нечто большее то есть это дерево вырастет за их пределы смотрите соответственно соответственно она как бы не материальное получится но как сущность она будет существовать то есть чисто вот из программу реализовать которые между собой сигналами обменивается много-много программок маленьких им друг друг с друг другом обменивать сигналами выращивать структурированные какие-то деревья и в результате и получится некая такой большой лес деревьев, который все в целом управляет муравейником. 

S05 [01:29:27]  : У каждого будет свой кустик в соответствии с его ролью. У вас у страуса у пятки один кустик, у коленки другой кустик, а у правого крыла третий кустик, у четвёртого крыла четвёртый кустик. Правильно? Но какой-то кустик должен в конечном итоге упираться или расти из этого самого первичного корешка. Соответственно, у Вас есть какие-то кустики, которые приращены изначально при инициализации системы к этому базовому корешку, или у Вас в конечном итоге все кустики из этого базового корешка растут, и все к нему стремятся? Просто дополнительные веточки друг с другом выращивают? 

S03 [01:30:16]  : Нет, нету никакого общего дерева. Смотрите, тут не так нужно думать. Есть образ требуемого результата. Он общий. Высота одна для всех. По аналогии с муравьями… 

S05 [01:30:37]  : И точка тоже одна для всех, конечная. Да, да. Все, понятно. 

S03 [01:30:41]  : То есть, у всех ураньев… Это общая цель для всех. 

S05 [01:30:45]  : Ну, то есть, точно так же, как, скажем, у каждой человеческой клетки, то и у каждого нейрона тоже, можно сказать, предположительно, есть одна общая цель, а как они в целом, как организм ее достигает – это вот уже предмет их распределенного взаимодействия. Да. Принято. А вот здесь вопрос от Юрия Бабурова. Превращаем его в вопрос, что у вас есть заблуждение про коррекцию ошибок, что все не будет работать, а будет попадать в локальные минимумы и не выбираться оттуда. Мне кажется, что если бы так были бы локальные минимумы, то страус застревал бы на подвернутом крыле. и не вылезал, прокомментируйте про локальные минимумы. 

S03 [01:31:33]  : Локальные минимумы это беда всех оптимизаторов, но так как здесь нет алгоритма оптимизации, у меня тут локальные минимумы возникают только тогда, когда я допускаю ошибку в программе. вот как так то есть он как бы иногда попадает в локальный минимум но если я ошибся в реализации алгоритма это такое у меня часто бывало раньше теперь я вроде теперь понимаю как правильно писать чтобы двигаться дальше не попадая минимумы 

S05 [01:32:11]  : Еще есть вопрос от Юрия Милова. Не понял, он по теме или нет. Что Вы скажете про мультимодальные нейроны и зеркальные нейроны? Они у Вас как-то имеют отношение? Зеркальные нейроны? Да. Мультимодальные нейроны. или у вас это не актуально? 

S03 [01:32:32]  : Для GIF это, наверное, не актуально, потому что может быть там где-то какой-то маленький компонент может быть. потребует использования вот этих вещей. Может и нет, но в целом архитектура не предполагает наличие каких-либо таких специализированных нейронов и так далее. 

S05 [01:32:58]  : Ну хорошо, тогда вот следующий вопрос от Юрия Бабурова, который я, честно говоря, не очень понял в свете. Ваших последних комментариев про муравьёв и общую цель у каждого сочленения Страуса. Вопрос такой, что поскольку нет ИИ, нам никто не придумает корректирующее действие. Проблема называется Duex-машина и появляется, когда рисуют систему из блоков, один из которых более мощный, чем вся система. Соответственно, считаете ли вы, что у вас действительно есть один из блок, который более мощный, чем вся остальная система? Может быть, Юрий Бабуров сам пояснит свой вопрос. 

S04 [01:33:48]  : Я не уверен, что у меня звук работает. Слышно мне, нет? 

S05 [01:33:51]  : Слышно, Юрий, да. 

S04 [01:33:55]  : Смотрите, блок коррекции результата слишком интеллектуальный. Если этот блок будет не интеллектуальным, будет рандомным или как-то перебирать, то сложные действия система сделать не сможет. Она сможет делать достаточно простые перебрать действия. Действия типа читать-писать условно говоря не требуют. с символным мышлением заниматься, не требует очень сложных взаимодействий, операций. Причем результаты не сразу очевидны. Поэтому если система будет реально интеллектуальной, то вот этот вот блок коррекции результатов, он должен быть тоже суперинтеллектуальным. Иначе система не сможет создавать каждый раз результаты, которые будут вместо попадания в локальные минимумы, какие-то тупые очевидные, вместо каких-то очевидных действий, линейных, кондитивных, чтобы вместо этого что-то происходило более сложное. 

S03 [01:35:01]  : Юрий, в деле результатов знания структурированы, то есть там сложность возрастает по мере продвижения от терминальных узлов. к корню дерева и соответственно вот этот блок корректирующий действия ему он не должен быть супер интеллектуальным то есть он может на своем уровне выполнять простые операции с ветками дерева простейшие и по мере как бы роста дерева оно растет вверх ногами то есть к корням она растет, а не к кончикам. По мере роста дерева сложность будет увеличиваться и таким образом просто нет такой проблемы. там, скажем так, сложность этого блока не должна быть супер сложная, там наоборот очень простой блок такой же как и все остальные хорошо, может я вас неправильно понял тогда, но кто эти блоки добавляет? 

S04 [01:36:15]  : кто решает какие блоки добавить, какие не добавить 

S03 [01:36:19]  : Не, я описал общую архитектуру от GIF. 

S04 [01:36:23]  : Ну да, вот я и спрашиваю, кто вот эти блоки добавляет? Вы их фиксируете в начале и потом система работает и все? 

S03 [01:36:31]  : Или кто-то может блоки добавлять в систему? Не, блоки, как я их нарисовал. А, вы про узлы? Смотрите, процесс синтеза постоянно добавляет новые узлы дерева. На чем основывается? На основе предыдущих, ниже лежащих деревьев. 

S04 [01:36:58]  : Значит, ему понравился какой-то узел, он его добавляет или как? Как понравилось определяется, кого добавить или всех подряд? 

S03 [01:37:08]  : смотрите изначально мы всегда стремимся к получению требуемого результата то есть у нас всегда есть требуемый результат просто непонятно что добавить система не сможет то есть она добавляет только то что приближает ее к требуемому результату и соответственно весь рост деревьев он целенаправлен соответственно мы в процесс роста как это представить это можно провести аналогию с обычными растениями то есть обычные растения они растут к солнцу Результат у них какой, то есть подсолнух за солнцем поворачивается. Почему он поворачивается за солнцем? Он максимизирует, ну как бы, лучи света, которые на него попадают. То есть, не знаю, там тепло, например, какие там у него есть ощущения у подсолнуха. И, соответственно, движется в сторону света. Таким же образом работают вот эти блоки синтеза. Там единственное, что блок корректирующих действий, он немножко отличается от синтеза, потому что он производит изменения тоже как бы в ветке дерева целенаправленно. То есть вот есть веточка, он начинает уже существующие комбинировать для того, чтобы получилась отличная от него веточка, так, чтобы результат был ближе. То есть там все функции очень простые, там не нужно их скучно усложнять. 

S04 [01:38:47]  : Вот аналогия у меня такая, что вот у вас марионетка на ниточках, вот у вас положение крыла, значит, это там одна точка, к которой ниточка привязана, а с другой стороны вы привязываете его к целевой точке и говорите, вот это вот расстояние должно уменьшаться тогда и на хорошее действие, правильно? 

S03 [01:39:07]  : а нет хорошего действия плохого 

S04 [01:39:10]  : Вы же говорите, что добавляются узлы какие-то только определенные, которые ведут к хорошему. 

S03 [01:39:15]  : Но есть же у нас блок сравнения, он сравнивает. Что он сравнивает? Блок сравнения, он сравнивает результаты друг с другом, насколько сильно они отличаются друг от друга. 

S04 [01:39:26]  : А как он их сравнивает? Как он для крыла будет действовать? 

S03 [01:39:33]  : Давайте конкретные вещи не будем про крылья, потому что мы слишком сильно в детали углубимся. Просто… Так иначе понятно. 

S05 [01:39:41]  : Вы в общем виде настолько в общем объясняете, что абсолютно непонятно… Виктор, на самом деле действительно на примере страуса, на примере его коленки или на примере какого-нибудь пальца или крыла было бы хорошо, если бы разобрать конкретно, как это работает. 

S03 [01:40:00]  : Просто вопрос изначальный был в сложности блока. То есть я попытался объяснить, что там нет ничего сложного в этом блоке. Значит, я вас неправильно понял. Единственное, что может быть, проблема какая может быть. То есть требуемый результат, он может оказаться недостижим. То есть если условия так сложились, что невозможно получить требуемый результат, он и не будет получен. Но это не означает, что ничего не работает. Жизнь сплошь и рядом так происходит. 

S05 [01:40:37]  : А вот тогда дайте еще какой вопрос. Вот эти блоки, они где? Вот у нас Strauss на экране. У него где-то есть блок, который занимается этим сравнением. Он сканирует все свои суставы, пятки и крылья и для каждого из них сравнивает. Или у каждого агента или у каждого муравья, из которых собран этот страус, у него есть свои блоки, которые этим занимаются индивидуально. И у каждого в своей собственной картине мира. 

S03 [01:41:23]  : Есть у каждого индивидуально. Я вот там рисовал схему. 

S05 [01:41:30]  : А тогда сразу вопрос, правильно ли мы понимаем, что топология в соединении этих самых элементарных агентов, из которых собирается страус или нервная система страуса, Она задается вами. Вы, грубо говоря, говорите, что у моего страуса будет 32 нейрона, или 32 муравья, или 32 агента, которые должны будут научиться совместно на нужной высоте добираться в нужную точку. Или по ходу дела могут возникать дополнительные муравьи или агенты. 

S03 [01:42:10]  : в данном случае конструкция астрауса задается конструктором то есть мы предполагаем что есть тело робота оно уже имеет как бы все моторы датчики там все что у него есть но то есть это все как в жизни то есть таким существо как родилось оно такое есть то есть оно не может изменить самого себя И, соответственно, что имеет на борту, то имеет. И вот с этим оно должно выжить. Поэтому топологию задаёт конструктор. 

S05 [01:42:48]  : Если я правильно понимаю, если провести аналогию тогда с жеребёнком, про которого Евгений Евгеньевич Витяев рассказывал на своей лекции, что когда жеребёнок пробуждается, первого фу прождается, вываливает, падает на землю из мамы. то первым делом он встаёт на ноги, а вторым делом он идёт к титьке маминой. Соответственно, у вашего страуса тоже есть два врождённых инстинкта. Один – это подняться на нужную высоту, а второй – прийти в нужную точку, как у того же ребёнка. Правильно? А как это делать? Он уже по ходу разбирается. 

S03 [01:43:27]  : Да, он сам придумывает, как достичь образ требуемого результата. 

S05 [01:43:32]  : Хорошо, давайте дальше тогда. Вопрос от Евгения Бабарыкина. Как выстраиваются недостающие решения, чтобы продвинуться вверх к корню? 

S03 [01:43:48]  : там достаточно просто то есть дерево результатов оно состоит из одинаковых стандартных компонентов и соответственно если у нас как бы словарь ограничен каких-то действий, то, соответственно, из этого ограниченного словаря все узлы и создаются. То есть это то же самое, что в ДНК там есть набор хромосом, и из них, соответственно, создаются комбинации. И здесь то же самое. Если сконструировали систему таким образом, что она может выполнять, допустим, 20 каких-то действий, то из этих действий это все и комбинируется. Единственное, что этот процесс не случайный, а целенаправленный. 

S05 [01:44:39]  : Спасибо. Ещё вопрос от Виктора Казариного, который задаёт следующее. АГИФа работает с открытым или закрытым миром? Это первый вопрос. И второй вопрос. Чем АГИФа отличается от обычных планировщиков? 

S03 [01:44:58]  : Предполагается, что GIF с открытым миром работает, то есть я на одном из слайдов говорил, что выполняются непрерывные действия, действия влияют на окружающую среду, окружающая среда изменяется, соответственно поступают новые входные данные и так далее по кругу, то есть цикл. 

S05 [01:45:22]  : Сразу уточняющий вопрос. Если мы говорим про страуса, то вроде как у самого страуса в целом среда не меняется от того, что он по ней ходит. Говорим про конкретного агента или узел, из которого состоит этот самый страус, то для него внешний мир меняется, потому что меняются ответные реакции других узлов, с которыми он связан. Правильно? 

S03 [01:45:53]  : Ну да, то есть он же смотрит за окружающим миром через свои датчики. Соответственно, что мы на входе имеем, то мы считаем окружающим миром. Все остальное не существует. 

S05 [01:46:09]  : Спасибо. И второй вопрос от Виктора Казариного. Чем АГИФ отличается от обычных планировщиков? 

S03 [01:46:18]  : но что значит чем буквально всем наверное то есть здесь система в комплексе описано как она должна выглядеть и обычные планировщики они решают другую задачу 

S05 [01:46:36]  : Спасибо. Здесь еще было много вопросов от Юрия Милова про зеркальные нейроны. Но, действительно, это не по теме. Эти доклады, эти вопросы можно в группу задать в Фейсбуке или в Телеграме. Дальше идем. Что у нас еще есть по вопросам? Если я правильно понимаю, Евгений Бабарыкин пишет, то суть работы – это построить полный граф знаний. Как вы к такому утверждению отнесетесь? 

S03 [01:47:07]  : Что значит полный граф знаний? Я не очень понимаю. Нельзя же познать мир целиком. И полный граф построить тоже нельзя. 

S05 [01:47:20]  : Ну я-то это интерпретирую так, что задача каждого агента это построить полный граф знаний, описывающий картину его жизненного опыта. 

S03 [01:47:31]  : Ну, наверное, все-таки не так, потому что я же говорил, типичная задача Аджифа, вот про падающий ключ, там нельзя построить полный граф знаний, там все время траектория поднятие ключа разные, они все время разные. И с точки зрения формальной эти знания тоже разные. То есть можно, конечно, схитрить и сказать, что как бы обобщить эти траектории, как бы там 150 траекторий считать как одну, и это считать единицей знаний. Но это опять же костыль. То есть по сути это все разное. То есть каждый раз эти знания создаются заново, чтобы решить задачу. Но новые знания опираются на уже существующие, проверенные. 

S05 [01:48:27]  : Следующий вопрос от Евгения Бабарыкина. Правильно ли считать то, что вы рассказали, чем-то вроде экспертной системы с постоянным дообучением через подкрепление? 

S03 [01:48:40]  : Но что значит дообучение через подкрепление? То есть тут суть системы совсем не в этом. Тут, во-первых, нет подкрепления, во-вторых, задача с падающим ключом, еще раз повторюсь, там нет дообучения, там чему обучаться, там невозможно ее решить дообучением. она решается поиском новых траектория поднимания ключа то есть это синтез чистый синтез новых траекторий это не до обучения спасибо 

S05 [01:49:23]  : Дальше следующий вопрос. Есть ли у вас в реализации объектно-ориентированное программирование? Да. Насколько интенсивно вы используете IFA? 

S03 [01:49:40]  : Как программа без IFA? 

S05 [01:49:44]  : я не знаю, может быть тут ирония такая, что Виктор, у вас все на ифах строится? ну действительно, да, еще можно было спросить, не на битах ли случайно у вас все строится? или в крайнем случае на байтах? Так, значит, да, наверное, все-таки на битах, на байтах и на ифах. Без них никак. И даже с методом электричества используется. Вот вопрос, еще голосом Игорь просит задать. Пожалуйста. 

S00 [01:50:16]  : В машинном обучении принята практика ставить какие-то бейслайны перед решением задач. Хороший пример – это Jim Environment. У нас есть какие-то цели, задача 200. 200 очков и за сколько это раз мы ее решим. Когда вы ставите задачу, например, с Траусом дойти до цели и говорите, вот он как-то дошел, ковыляя, и эта задача решена, никаких локальных минимумов, то это, как по мне, является не совсем правильным ее решением, потому что у нас нет какого-то безлайна, с которым мы можем сравнить. То есть, грубо говоря, потому что это новая среда, никто на ней не использовал, вы не знаете, какие результаты будут самыми эффективными. Как по мне, сначала надо с помощью каких-то простых функций, с помощью физики определить скорость, как поставить две ноги, определить скорость, как поделенную на массу, посмотреть вообще, за сколько оно дойдет. а потом уже делать систему, которая будет пытаться добить этот результат. Как говорил Антон, эволюция, красота возникла как эволюционное решение. быстрое эволюционное решение какой-то задач, точно не помню. В общем, суть в том, что, например, если у нас будет какой-то страус, который, например, шагая в припрыжку, может намного быстрее дойти до цели, то, значит, он эту задачу выполняет быстрее, и, значит, Прямая ходьба является наиболее эффективным решением этой задачи. У вас нет никаких, грубо говоря, бейслайнов, у вас нет никаких наиболее эффективных способов решения задачи, и вы говорите, вот Страус как-то дошел, и это и есть решение задачи. Если он не дошел, значит, он эту задачу решить не может. Но, как по мне, это является каким-то таким обманом самого себя. Потому что вы говорите, что если, например, у нас, если страус пришел к цели, там, не знаю, за сколько, за 50 терраций, за 100, неважно. то это значит, что есть решение задачи, а не локальный минимум. Но если, например, какой-то другой алгоритм может решить эту задачу за 5 итераций, а при этом в Австраусе ее решает за 10 и считает ее единственным правильным решением, то это и есть локальный минимум. Значит, что он решает задачу неправильно. Почему я веду? Ставили ли вы перед собой какие-то бейслайны, какую-то такую функцию, какой-то такой результат, который должен был побить ваши задачи обучения? Грубо говоря, неважно как. Если это своя среда, то это, конечно, довольно сложно сделать. Для этого и делаются такие среды, как Jim Environment или датасеты, на которых уже другие люди пытались решить свои задачи, давали свои результаты, и потом мы на этих же задачах пробуем свои алгоритмы, чтобы видеть, побивали мы этот результат или нет. Вопрос в том, есть ли у вас какие-то цели, пробовали ли вы свои алгоритмы на каких-то таких задачах, которые уже решались с другими? 

S03 [01:53:45]  : Смотрите, я на последнем слайде указал, что самодостаточный E это следующий шаг после аджифа, то есть то, что касается аджифа, там мне лично все понятно, что делать, как это будет работать, какие там есть ограничения и так далее. Вот то, что касается самодостаточной, и там для меня еще очень много вопросов. И у меня цель не состоит в том, чтобы сделать конкурентоспособное решение, а цель моя состоит в том, чтобы сделать саморазвивающийся разум, который самодостаточный. И для него там важна не скорость достижения результатов, а сам принцип, чтобы это все работало. То есть там проблемы какие изначально появились? То, что система разрушалась после какого-то периода обучения. как бы все работало но через некоторое время накапливали знания и это все схлопывалось это достаточно быстро происходило потом я сделал как бы понял в чем проблема сделал как бы следующий шаг все стало ломаться чуть позже ну и так далее то есть это как звуковой барьер то есть но делаешь делаешь учишь учишь вроде там сутки ходит а потом раз и все поломалось вот Важно в первую очередь именно это. Чтобы система проработала год, два, три, пятьдесят лет и продолжала работать. Это более важно, чем достижение цели заранее за данное время. Понимаете? Немножко акценты совершенно другие. 

S00 [01:55:50]  : Да, я понимаю, но контраргумент можно привести в том, что медуза или бактерия в одну клетку – это тоже система, которая как-то живет, но все, что она может делать – это питаться и размножаться, и пользы от нее мало. 

S03 [01:56:09]  : Просто если система работает так, как положено, а пока она еще не идеальная, то вот эти все мелочи, они потом очень просто решаются. То есть под конкретную какую-то задачу Добавляются там дополнительные какие-то образы требуемых результатов, еще там что-нибудь добавляется. Где-то можно поставить какие-нибудь костыли для решения совершенно конкретной задачи. Это тоже допустимо. То есть если нужно решить конкретную задачу, то все способы хороши. А я решаю абстрактную задачу. То есть, когда она будет решена в полном объеме, то все частные задачи, они будут решаться совсем просто. 

S00 [01:56:56]  : Хорошо. Ну, я, в принципе, ответ понял, просто хотелось бы тоже комментарий. Говорил его создатель DeepMind или DeepBlue, я не помню. Тот, кто создал программу, которая обыграла Каспарова в шахматах, он говорил, задача научить машину играть в шахматы довольно легкая, но для этого потребуется все время вселенная. То есть о том, чтобы создать достаточную систему, мы можем просто перебором перебирать все возможные варианты. Другое время на то, сколько на это время уйдет. Для этого может не хватить всей жизни человечества. Спасибо за ответы. 

S05 [01:57:37]  : Спасибо. Виктор, еще вопрос есть. Можете ли как-то соотнести то, что Вы делаете с теорией Анохина и Эшби? 

S03 [01:57:49]  : Анохина – Петр Кузьмича? Я думаю, что да. Да, именно на его теории функциональных систем все и строится. В моем понимании. Я вообще же не теоретика-программист. Вся теория от Анохина. А то, что касается практики, тоже мое. 

S05 [01:58:16]  : А про Эшби что-то можете сказать? 

S03 [01:58:20]  : Про Эшби я больше только его фамилию знаю, а вот детали, наверное, ничего не скажу. 

S05 [01:58:29]  : Так, вопрос от Игоря был. Так, от Юрия Бабурова вопрос. Если мы поставим перед Страусом по дороге к цели полукруглую стенку, сможет ли он дойти до цели? 

S03 [01:58:44]  : Я думаю, да. Я знаю, как решается такая задача, когда я сумею найти решение более сложных проблем, с которыми я столкнулся. Обойти стенку. Это уже очень просто. 

S05 [01:59:05]  : То есть эта проблема будет не более сложной, чем проблема в стать в конечном итоге с точки зрения алгоритмической сложности. 

S03 [01:59:12]  : Да, это вообще не сложно. Но это же все в обычном игровом интеллекте все прекрасно решается давно уже. 

S05 [01:59:23]  : Так, еще вопрос к Виктору от Виктора Казариного появился. Как влияют друг на друга итерации поиска решений для построения полного ДР? Возможно, это было в вашей презентации, но я опоздал и не успел посмотреть сначала. Так, еще раз можно? Вопрос. Как влияют друг на друга итерации поиска решения для построения полного дерева решений? Ну, может быть, Виктор, может быть, вы голосом поясните вопрос? 

S03 [01:59:57]  : Я не очень просто понял, то есть слова знакомые, вот суть не могу ловить. 

S01 [02:00:05]  : Здравствуйте, меня слышно? Да-да. Ну, я немножко, может быть, не точно выразился. 

S02 [02:00:10]  : Ну, как происходит процесс обучения в итоге? оно же в итоге строит конечный результат, чтобы дойти до цели. И у вас я на видео вижу, что тысячи итераций делаются, даже сейчас на видео. Сначала встает, падает, еще раз падает, потом через какое-то время начинает достигать задач. То есть это все внутри одного цикла решения, построения дерева результатов? Или это разные? совершенно разные задачи, которые как-то дополняют друг друга. И в итоге уже этот опыт появляется в виде конечного дерева результата с помощью вот этих множества итераций. 

S03 [02:00:56]  : То есть тут, наверное, аналогия с генетическим алгоритмом, где много копий. Да, я спрашиваю, вот поэтому у вас это как-то… Нет, здесь только одно дерево, одно дерево. 

S02 [02:01:06]  : То есть у меня вот отличие моего… А итерации, у вас одна итерация, вот включил один запуск, сделал, и оно пошло, мучается, мучается, в итоге все понятно. 

S03 [02:01:16]  : Так вот я и спрашиваю насчет сравнения с планировщиками. 

S02 [02:01:29]  : Ему ставится задача, у него есть исходные данные и способ набора простейших элементарных действий. Все, кинул, и он ищет разные алгоритмы. Либо от обратного, либо звездочка решения алгоритма и так далее. То есть оно ищет решение, а потом выполняет, если оно найдено. 

S03 [02:01:51]  : да, там, где происходят операции с деревом, там можно использовать стандартные логарифмы планирования. с этим нет никаких проблем вообще. 

S02 [02:02:03]  : я спрашиваю, насколько сильно оно отличается от обычных планировщиков? который работает, кстати, в замке. 

S03 [02:02:11]  : Это отличается набором правил для дерева результатов. То есть, если мы ограничиваем стандартные алгоритмы планирования набором вот этих правил, которые я озвучил, то вот это и есть отличие. 

S02 [02:02:29]  : А у вас что, безграничное количество правил? 

S03 [02:02:31]  : В смысле? Нет, я же их причислил, там всего несколько штук. 

S02 [02:02:36]  : Но я говорю, я не видел, я, к сожалению, полтора часа опоздал на презентацию. Была случайность такая. Ну хорошо, понятно. 

S05 [02:02:47]  : Еще у меня вопрос тогда. А вот как быть, значит, у вас есть такие ситуации, когда, скажем так, возникают альтернативные деревья для с учетом того опыта, который имеется в данный момент у совокупности агентов или у одного агента, когда возникает ситуация, что для достижения образа результата можно выполнить либо это дерево, либо это дерево. Вот. И может быть, их даже может быть больше, чем два. Некоторое количество. Как решается проблема с тем, какое дерево выполнять? И есть ли вообще такая проблема в вашей парадигме? 

S03 [02:03:36]  : наверное нету такой проблемы какой дерево выполнить там просто есть же образ требуемого результата мы всегда выполняем пытаемся выполнить ту ветку которая наиболее ближе к требуемому результату то есть мы просто сравниваем ветку если она подходит 

S05 [02:03:59]  : если есть две ветки, если есть три ветки, которые одинаково подходят. 

S03 [02:04:06]  : такого не может быть, чтобы совсем одинаковые были. 

S05 [02:04:10]  : почему? 

S03 [02:04:11]  : но если они одинаковые, то одна ветка не совпадает. 

S05 [02:04:16]  : Не, ну как, я могу встать утром с левой ноги, могу встать с правой ноги. А результат не получится. Да, соответственно, с какой ноги вставать он будет? Нет, мы же заранее не знаем, что результат получится. Может быть, если я не с той ноги встану, я под машину попаду. А если встану с другой – не попаду. 

S03 [02:04:38]  : но тут смотрите тут просто еще контекст наложит свои ограничения то есть вы же не просто так с левой ноги будете вставать значит вы просто занимали какую-то позу такое которая была предшествовала вот статью с левой ноги или с правой ноги то есть у вас видимо предшествующее положение было отлично и соответственно в зависимости от этого вы стали либо с левой либо с правой ноги 

S05 [02:05:13]  : Ну то есть у вас не возникает такой ситуации, когда есть неоднозначность, которую там надо разрешать каким-то случайным, например, образом бросать кости. 

S03 [02:05:21]  : Нет, вообще нет. Никогда таких ситуаций не возникает. Просто если вы посмотрите на правила создания дерева результатов, там вообще все однозначно. Это вот прям как алгоритм. Просто можно программу садиться и писать. То есть если есть дерево, его можно запрограммировать. там все посмотрите однозначно посмотреть вы говорите у вас проект с открытым кодом или с закрытым кодом вот смотрите от живо это проект предполагается с открытым кодом то есть я просто решил вот в таком видео преподнести потому что я смотрю как бы люди Разрозненные хотят как-то объединиться, делать что-то совместными усилиями. Вот я предлагаю такой проект, чтобы можно было совместно его сделать с открытым кодом. А вот проект, который называется Самодостаточный интеллект, это чисто мой проект, это код полностью закрытый. Ну, я не знаю, может, когда-нибудь потом заживем, что будет... Ну, а как они связаны? Ну, пока я просто еще не доразвивал его до такого состояния, чтобы я понимал, как его закончить. 

S05 [02:06:41]  : Тогда уточните, пожалуйста, как эти два проекта связаны. То есть Аджифа – это некоторая теория, а Ливбастер – это некоторый код, который на основе этой теории написан. Правильно? Ну да. Но для Аджифа кода нет. Для Аджифа кода нет. 

S03 [02:06:56]  : То есть я предполагаю, что если кто-то захочет его написать, то я могу в этом поучаствовать и помочь это сделать. А так я просто изложил теорию, как он может выглядеть. То есть я в принципе могу более детально написать, какие-то компоненты проработать более детально, чтобы кто-то мог их реализовать. в виде теории останется, потому что я лично развиваю только самодостаточные, у меня просто больше сил не хватит. 

S05 [02:07:32]  : Но эта теория у вас в нем реализована. Я правильно понимаю, что эта теория у вас уже реализована? 

S03 [02:07:37]  : По сути да. То есть вот Аджифа, если общими словами, как я в презентации рассказывал, по сути она реализована. но естественно со спецификой следующая шага, то есть с учетом вот этих ограничений таких экстремальных, то что там база данных пустая, там реальное время и так далее, там специфика реализации очень такая, скажем так, не знаю как сказать, но в общем там очень сложно все. 

S01 [02:08:15]  : Там чисто программирование. 

S03 [02:08:16]  : Там не теория, а программирование. 

S05 [02:08:20]  : Вы говорите, что вас пока не интересуют бейслайны, потому что есть более серьезные задачи. Вы можете поделиться, какие у вас сейчас задачи принципиальные стоят, которые вы решаете? 

S03 [02:08:36]  : но вот самая главная задача которая очень тяжелая это с течением времени саморазвивающийся интеллект не должен разрушаться. То есть, это очень тяжело дается. Я буквально, может, полгода назад только получил систему, которая может сутки прожить и только улучшаться, а не ухудшаться. 

S05 [02:09:06]  : Это не история про переобучение? 

S03 [02:09:09]  : Ну, нет. Наверное, нет. Там немножко другое. 

S05 [02:09:13]  : И не про lifelong learning? Скорее, чисто алгоритмически. 

S03 [02:09:24]  : Некоторые вещи просто не понимаю, как правильно сделать для того, чтобы они корректно работали долгое время. 

S05 [02:09:32]  : Но, насколько я понимаю, эволюция тоже ничего не придумала, и поэтому мы в какой-то момент все время умираем. Хотя, правда, эволюция, может быть, как раз это придумала по другим причинам. Здесь тоже можно порассуждать. 

S03 [02:09:47]  : Я не могу сказать за эволюцию. Там можно только гипотезы какие-то делать, как это все. 

S05 [02:09:56]  : Еще есть пара комментариев по поводу бейзлайнов. Один комментарий – это то, что бейзлайны нужны, чтобы понять, что те алгоритмы, которые мы придумали, дают результат лучше, чем просто сделать какой-нибудь прямой перебор. Или чем просто просчитать все прямые обратные кинематические задачи, а что у вас получается более эффективное решение. И мне с этой позиции еще какой вопрос есть. Если я правильно понимаю, по определению AGI, дополненному Искусственный интеллект – это не просто способность адаптироваться в разных средах, но и делать это ещё с условием ограниченных ресурсов. То есть, нам мало прийти в конечную точку. Нам надо прийти в конечную точку раньше, чем у неё придёт конкурент. Или если мы на Луне или на Марсе в одиночестве, то раньше, чем у нас кончится еда. Чтобы нам успеть подкрепиться. 

S03 [02:11:06]  : вот я понимаю то есть со временем я к этому тоже вернусь просто сначала должен сделать некоторые другие вещи и потом уже вот этими более простыми вещами заниматься 

S05 [02:11:20]  : У меня конкретный вопрос. Вы в какой-то момент сказали, что вы строите полное дерево. Для того, чтобы получить необходимые действия, вы простраиваете полное действие, которое приведет вас к максимальному приближению. соответствие ожидаемого результата с текущим образом результата действия. И здесь вы строите полное дерево. И вопрос такой, что у вас не возникает таких ситуаций, что в какой-то момент можно строить не полное дерево для того, чтобы получить какую-то загрубленную оценку, но получить ее более дешево или более быстро. Или сейчас у вас всегда полные деревья строятся? Или, может быть, их просто нельзя в принципе строить неполными по вашей методологии? 

S03 [02:12:13]  : Я просто не очень понимаю, что такое полное дерево. Там смысл в чем? независимые компоненты должны в определенный момент времени достигнуть требуемого результата там может быть то что вы называете полным деревом но как раз начинает мешать то есть там они же должны достигать с разной скоростью все компоненты двигаются разной скоростью должны прийти в одну и ту же точку в одно и то же время и здесь как раз вот синтез помогает то что мы в реальном времени можем выстроить так, как бы траекторию, что они все сойдутся в одной точке. И тогда как бы система не разрушится. То есть понимаете, нет, о чем я? 

S05 [02:13:14]  : Я правильно понимаю, что когда мы говорим про дерево, мы говорим не про то дерево, которое в голове у конкретного агента, а то дерево, которое распределенно существует в поведении системы агентов. 

S03 [02:13:28]  : Ну да, оно распределённое. 

S05 [02:13:30]  : А, всё, нет, нет, всё, тогда принято, всё. Тогда принято. Да, всё. У меня нет больше вопросов коллеги. Ещё у кого-нибудь есть вопросы к Виктору? Вопросов нет. Хорошо, Виктор, тогда спасибо вам огромное. 

S03 [02:13:51]  : Мне было очень интересно. Спасибо всем. Спасибо, коллеги. 

S05 [02:13:56]  : И еще вопрос такой ко всем окружающим, как раз к вопросу о бейслайнах. И зачем они нужны, и какие они должны быть. У нас планируется через две или три недели, по-моему, через три, семинар как раз по тестированию системы AGI. Соответственно, Виктор, если вам это интересно, поучаствовать и высказать свою точку зрения, то я бы вас пригласил поучаствовать в качестве спикера. И если кому-то еще интересно, высказать свою точку зрения и высказаться по поводу именно проблемы бейслайнов и тестирования для системы AGI, то, пожалуйста, пишите в Телеграме или в Фейсбуке. Хорошо, подумаем. 

S03 [02:14:41]  : Хорошо, спасибо. Спасибо всем еще раз, до свидания. 






https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html

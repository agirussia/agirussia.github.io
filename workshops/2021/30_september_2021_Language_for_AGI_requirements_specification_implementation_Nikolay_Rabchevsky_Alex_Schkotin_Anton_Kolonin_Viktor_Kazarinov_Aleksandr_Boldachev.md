## 30 сентября - Язык для AGI - требования, спецификация, реализация - Николай Рабчевский, Алекс Шкотин, Антон Колонин, Виктор Казаринов, Александр Болдачев — Семинар AGI
[![Watch the video](https://img.youtube.com/vi/FrDK1fkbhaY/hqdefault.jpg)](https://youtu.be/FrDK1fkbhaY)

Суммаризация семинара:

ТЕМА:
- Семинар посвящен разработке специализированного языка для агентной системы, который позволяет более естественно и гибко моделировать сложные взаимодействия между различными субъектами.

СУТЬ:
- Основные идеи семинара касаются создания языка, который может декларативно, функционально и даже логически событийно представлять взаимодействия, делая акцент на четкость и недвусмысленности сообщений.
- Востребованность человекоориентированности языка подчеркивается участниками в контексте сравнения с другими языками программирования и протокольными системами, где потенциал естественной инициативы и взаимодействия увеличивается с учетом таких средных функций как текущий поддержанный функциональный стандарт согласованный с человеческим локализованным перцепом и целостным структурированным интеллектом.
- Отмечается, что предложенный подход менее человекоориентирован по сравнению с предыдущим вариантом языка, что требует последующей дополнительной коррекции и визуализации для удобства пользователя.

ДЕТАЛИ:
- Практическая демонстрация процесса подписания соглашения между несколькими контрагентами показывает, как может быть автоматически загружена и визуализирована базовая семантика используемых атрибутов, экшенов и отношений, формируя конкретный сценарий сегментов взаимодействия со стороны повышения специфицированной реализованной пользовательской семантики.

РЕЗУЛЬТАТЫ:
- Результатом семинара является понимание того, что потенциал существующих подходов ЕСП и CEP технологий сторонними функциями включенными в модифицированные схемы использования креативных моделей языка и кодировки каналов прямоторговых виртуальных взаимодействий превышает скромные предысторические требования традиционных высокопроизводительных реляционных клиент-серверных статично структурированных систем интеграции и синтеза запросов и словарей.






S02 [00:00:12]  : Коллеги, всем добрый вечер. Я надеюсь, что мы уже в эфире. И позволю небольшое вступление. есть такое высказывание или такая точка зрения, что каждый уважающий себя программист должен написать или как минимум постараться написать как минимум один язык программирования за свою карьеру. Экстраполируя, можно сказать, что каждый разработчик системы искусственного интеллекта должен постараться написать, или хотя бы постараться написать как минимум один язык для разработки систем искусственного интеллекта, или общения их между собой, или внутреннего употребления этих систем. Собственно, первый вопрос как раз о том, что вообще нужен ли такой язык. Если нужен, то зачем? То ли он нужен для того, чтобы программировать EGI, потому что нам не хватает C++ или Python, или модной ныне Джулии, то ли этот язык нужен для того, чтобы взаимодействовать с системой AGI, давать ей какие-то целеуказания, получать у неё какие-то разъяснения, а может быть, чтобы разные AGI-системы могли общаться друг с другом и делиться накопленным опытом. Ну и, наконец, Александр Соколов настоял, чтобы рассмотреть гипотезу, что этот самый язык нужен для внутреннего общения самообслуживанию AGI. Тут тоже могут быть разные гипотезы. То ли это нужно для того, чтобы разные модули в рамках одной системы AGI говорили между собой, что является одной из фич ряда известных проектов. Либо это вообще что-то более фундаментальное. Я вспоминаю, был такой проект Neuronet. Может быть он даже есть. И там одно из основных направлений на старте этого проекта была так называемая нейросемантика, где предполагалось, что нейроны говорят друг с другом на каком-то языке, и нужно взломать этот язык и, соответственно, строить на основе этого взломанного языка межнейронного взаимодействия какие-то практические приложения. Бизнес-приложения даже. Соответственно, если такое, нужно ли оно? И если нужно, то должен быть это какой-то существующий язык или нужно изобретать новый? Вторая тема, второй круг вопросов более фундаментальный. Что это должен быть язык? То ли это язык программирования, то ли это естественный язык, то ли это какой-то контролируемый язык, так называемый. Должна ли быть грамматика context-free или context-sensitive? Имеет ли это какое значение? Если имеет, то почему? Далее. Если мы говорим о том, что этот язык является необходим для работы с каким-то внутренним представлением, То можно ли считать внутреннее представление языком? Если мы хотим что-то выражать через какой-то текстовый или звуковой язык, какое-то внутреннее представление, то вообще само внутреннее представление в отрыве от визуального текстуального или аудиального представления, оно вообще является языком? Может быть вообще есть некоторый внутренний язык, который мы можем переводить на язык знаков, язык символов, язык звуков, язык цветов и так далее. И тут сразу возникает вопрос, что есть язык вообще. Тоже на эту тему и в Телеграме, и в Фейсбуке были довольно жаркие дискуссии. Соответственно, как это внутреннее представление, если оно есть у системы AGI или системы NI, Natural Intelligence, если у него есть какое-то внутреннее представление, которое отображается в языке, то имеется оно какое-то отношение с антологиями и грамматиками? Нужны ли нам антологии для внутреннего представления? Или онтологии нужны только для того, чтобы оформлять какие-то сообщения во внешнее пространство с тем, чтобы эти сообщения доходили другим агентам, которые используют одну и ту же онтологию. Нужны ли, опять-таки, грамматики только для формирования сообщений вовне и трансляции сообщений извне, а внутри никакие правила упорядочивания вот этих внутренних представлений, с которыми работает интеллект, не нужны? Соответственно, внутри грамматики нам не нужны. Соответственно, логически, следующий вопрос. Как это внутреннее представление отображается на внешней интерфейсе? по входу и по выходу, какова структура данных вот этого внутреннего представления. Интересный вопрос, когда мы описываем либо это внутреннее представление, либо внешнее выражение этого внутреннего представления, должны ли быть меры нечеткости, или вероятности, или расплывчатости каких-то знаний, или каких-то сообщений, или каких-то конструкций, или каких-то команд. быть частью структуры языка. То есть, должны ли они быть встроены в язык, как, например, это сделано в Нарсе. В Нарсе у Пи Иванга true value – это просто-напросто элемент любого стейтмента, который отдельно выражается в синтексе функцию пунктуации либо вероятностные меры они выражаются средствами самого моего языка как русском языке можем мы можем сказать мне кажется что или я уверен что Наконец, можно ли сказать, что язык внутреннего представления – это, по сути, просто некоторая разметка элементов в соответствии с некоторым лексиконом. То есть, у всех у нас есть внутреннее представление столов и стульев, но когда мы выплёскиваем наружу свои знания о столах и стульях, мы на них просто развешиваем этикетки. И упорядочиваем сообщение в соответствии с некоторой общей грамматикой. Либо же всё гораздо сложнее. И во внутреннем представлении всё совсем не так, как что прошлое. Внутреннее представление – это не просто размеченная структура, отображаемое внешнее пространство. Наконец, является ли язык ограничителем когнитивных способностей? То есть, есть ли у нас такое, что насколько у нас богат и мощен язык, настолько мы можем хорошо мыслить? Допустимо ли автоформирование собственного языка внутри AGI? То есть, может ли быть AGI, у которого сначала языка нет, а потом он сам возникает? И если этот язык возникнет, то чем он будет отличаться от нашего языка? Ну и, собственно, главный вопрос, с которого, может быть, имеет смысл начать. То есть, по усмотрению спикеров, на самом деле, все вопросы, которые тут есть, на них можно, на самом деле, не отвечать. Или отвечать выборочно, или отвечать в любом порядке. Но вот самый главный вопрос – это вот чем предлагаемый вам язык крут, в чем его особенности, ну и, собственно, почему вы хотите его предложить сообществу. Николай, пожалуйста. Спасибо. 

S00 [00:07:06]  : Я начну с ответов на перечисленные вопросы. Нужен ли специальный язык? Ну, для программирования, то есть для кодирования, собственно, системы, конечно, не нужен. Есть хорошие языки программирования, с моей точки зрения, наиболее подходящие это C++, поскольку он универсальный и высокопроизводительный, широко распространен и так далее. Для взаимодействия с разработчиками и теми, кто обслуживает систему, безусловно, нужен некий язык обмена информацией. То есть язык, на котором оператор или исследователь в процессе работы тестирование будет с этой системой общаться для того, чтобы произвести интроспекцию, коррекцию каких-то внутренних данных и так далее. И это, в общем, общее требование для почти любой программной системы, поэтому он, безусловно, нужен. Второй вопрос – какой именно язык? Для обмена сообщениями системой обычно применяют язык, который на уровне синтаксиса является контекстно независимым. для того, чтобы парсинг делать более простым. Но при этом язык в целом оказывается контекстно зависимым, и вслед за этапом парсинга каких-то текстов следует этап семантического анализа, на котором могут выявляться ошибки, которые не отражены синтаксисом. И эта ситуация практически везде одна и та же. Тут вот есть такой момент. Если язык предусматривает обмен данными, то он, вообще говоря, контекстно независимым не может быть, потому что те данные, которые мы в него вставляем, они составляют тот самый контекст, от которого все зависит. Третий вопрос – является ли внутреннее представление предметом описания языком или это есть язык? Нет, внутреннее представление напрямую не связано, и больше того, разумно делать его достаточно независимым. Внутреннее представление должно быть универсальным, оно должно быть эффективным с точки зрения вычислительной и соответствовать тому языку кодирования, который выбран. Коммуникация должна быть удобна для человека. И это, в общем, разные вещи. Поэтому нет никакого смысла связывать одно с другим и выбирать внутреннее представление в соответствии с языком или наоборот язык в соответствии с внутренним представлением. Следующий вопрос – что есть язык вообще? С моего глубокого убеждения на дискуссиях, форумах я его отстаивал. Язык – это средство коммуникации, и только средство коммуникации. Поэтому все требования к нему из этого и вытекают. Как связано внутреннее представление с антологиями и грамматиками? А никак не связано. Этот вопрос еще немножко выглядит нечетко, потому что, в общем, что такое антология, не очень четко формулируется. Скажем, для себя я не мог найти утверждение о том, может ли, скажем, функция быть элементом онтологии. Подразумевается ли под онтологией нечто стабильное или подразумевается нечто… перманентно модифицируемое, как скажем, внутреннее представление о том, что система знает. Поэтому тут, так сказать, сложно сказать насчет антологии. С грамматиками внутреннее представление уж точно никак не связано. Должно ли внутреннее представление отображаться на внешние интерфейсы? Ну, тут опять-таки я не очень понимаю, что надо понимать под отображением. Скорее всего, нет. Какова внутренняя структура хранения данных? Ну, я выбрал и считаю это… более подходящим вариантом. Такое представление, когда логические связи, то есть семантика, хранятся в виде ориентированного графа. Информация о последовательности хранится именно как последовательность. а количественные данные и текстовые данные, то есть имена, строки, проливали, хранятся как в обычной базе данных, то есть либо хэштаб лица, либо реляционная база данных. То есть нет одной единой системы, а разные типы данных хранятся так, чтобы обеспечить эффективность этого хранения. Должно ли мера нечёткости быть как бы составной частью языка? Нет. Нет смысла, потому что для большинства логических элементов либо единица, либо неизвестно. Поэтому в моем подходе выбран вариант, когда вероятность, если она не дефолтная, то она хранится, как все остальные атрибуты, наряду там с весом, шириной, длиной, скоростью и так далее. Можно ли сказать, что язык внутреннего представления есть разметкой элементов в соответствии с лексиконом? Ну, я бы сказал, что наоборот. Вот если у нас есть внутреннее представление и у нас есть лексикон, то элементы лексикона помечены как ссылки на некие сущности. При этом, если мы хотим обеспечить многоязычность, а это обычное требование в настоящие времена, то лексиконов будет несколько. И то, что в одном лексиконе может быть одним словом, в другом лексиконе может быть комбинацией слов и так далее. Поэтому одно и то же внутреннее представление может соответствовать разным соответствиям между внутренними понятиями лексическими конструкциями. Ну и, наконец, чем крут предлагаемый язык и особенности. Я тут, с вашего позволения, расшарю тогда картинку. Видно? Видно-видно. Ага, хорошо. Значит, то, что сейчас видно, это вот тот технологический язык, который я предполагаю использовать и использую в экспериментах. имея в виду, что им пользуются разработчики, технический персонал, который понимает внутреннюю логику и структуру системы. Требования к такому языку вытекают в основном из удобства для пользователя, то есть он должен быть лаконичным, не таким, как, скажем, XML, где нужно писать много всяческих закорюг для того, чтобы простые вещи передать. Он должен, с моей точки зрения, не содержать ключевых слов, потому что если мы имеем некие ключевые слова, то мы должны выбрать заранее язык, на котором они… И при использовании другого языка в качестве интерфейса мы будем получать комбинацию, скажем, ключевых слов на латинице со словами на кириллице, и это никакого удобства не представляет. Поэтому у меня выбрана ситуация, когда операции задаются символами не алфавита, а специальными символами, знаками припинания. Второй момент – это… быть более или менее похожим к общепринятой грамматике, математике и наиболее распространённых языках программирования, чтобы людям не приходилось всё время переключаться с одного характера текста на другой. Следующий момент, важный для эффективной работы, это чтобы реальная система использовала подсветку синтакса для того, чтобы указать на возможные ошибки и так далее. Вот у меня, скажем, сделано так. Если человек набрал некий текст, то перед тем, как интерпретируется этот текст, производится синтаксический анализ, и если там присутствуют слова, которых система не знает, они показываются другим цветом. Если пользователь хочет, чтобы система приняла этот оператор, он говорит «да, выполняй», и тогда слова, которые не представлены пока что, становятся элементами системы. Если это выделено цветом слова «неизвестная система просто потому, что я опечатался», то, соответственно, я не выполняю оператор, а корректирую текст. Следующий элемент. Если такие ошибки есть, то должна быть хорошая система диагностики. То есть система должна показать, где ошибка, в чем она состоит, и таким образом подсказать, как ее править. Ну и по возможности синтаксис должен как можно больше на себя брать в анализе семантики, ну то есть, скажем, отличать атрибуты от понятий или логических сущностей и так далее, с тем, чтобы уже на синтаксическом анализе можно было найти как можно больше ошибок. Формальная грамматика, она контекстно независимая, но при этом на следующих этапах, как обычно, выполняется некий анализ на предмет семантики. И третий этап, когда этот текст окончательно интерпретируется, то есть, можно сказать, выполняется, то могут возникнуть, так сказать, еще runtime ошибки, которые тоже должны как-то интерпретироваться. Ну, тут на картинке показано три варианта. Я думаю, они, в общем, достаточно хорошо иллюстрируют подход, то есть запрос на определение или модификацию, удаление, запрос на поиск по налоге, и запрос на поиск по комбинации признаков. Важный момент еще является то, что этот технологический язык, он содержит часть операции, которая окончательному конечному пользователю. Она не нужна и не только не нужна, а ему нужно запретить ее использовать. Ну, например, когда производится правка какая-то, возникают иногда ситуации, когда есть две сущности, которые потом оказываются на самом деле одной. Ну, скажем, у нас есть некая понятие, которое позволяет идентифицировать человека по картинке, и есть некая информация о человеке, которая говорит о том, какая у него профессия, адрес, имя и так далее. А потом мы обнаруживаем, что Эти две сущности – это на самом деле одна и та же, то есть мы идентифицировали. Их нужно слить вместе, то есть объединить признаки одной, признаки другой, и, возможно, они обе будут именованы и так далее. То есть вот операция слияния понятий есть. Есть понятие «переименование понятий». А конечному пользователю, возможно, это и совершенно не нужно. Ну, теперь следующий момент. А нужно ли естественный язык давать или почти естественный? Ну да, в зависимости от миссии системы, естественно, язык может быть полезным, как в полновесном таком варианте, так и в ограниченном, некомформализованном. Но с моей точки зрения, Удобно использовать двухуровневую систему, которая на картинке показана, когда естественный язык сначала преобразуется к этому формальному технологическому, который к этому моменту уже отработанный, хорошо показывает свою способность. Ну и обратная система, то есть когда система что-то должна возвратить в качестве результата на естественном языке, то ядро системы передает информацию на формализованном языке, а некий составитель текста на естественном языке уже переводит его в естественный язык. При этом грамматические правила перевода туда и сюда, из естественного в технологический и наоборот, они, естественно, будут разные для разных языков. как лексикон, так и набор правил. И нужна технологическая цепочка, которая позволит лингвистам пополнять набор правил или корректировать их, модифицировать с тем, чтобы все работало как надо. Ну и разработка в целом получается тоже двухступенчатая, то есть на первом этапе разработки мы делаем систему с технологическим языком, которое может быть не очень удобно для конечного пользователя, а потом делаем надстройку, когда все остальное уже работает. И таких надстроек может быть несколько для разных языков. Ну вот, это, пожалуй, всё, что я могу сказать по этому поводу. 

S02 [00:27:02]  : Николай, спасибо. На самом деле, короткий комментарий очень близко к тому, как у меня всё предполагается и делается. Но это я потом скажу более подробно. Когда до меня речь дойдёт, у меня несколько вопросов. Коллеги, если у кого-то вопросы есть, то, пожалуйста, пишите тоже по порядку. Значит, во-первых, вы сказали не содержать ключевых слов. А что значит не содержать ключевых слов? Откуда вообще ключевые слова могут взяться? Можете пояснить, что такое ключевое слово? 

S00 [00:27:33]  : Ключевое слово, когда мы говорим в языке программирования, то там есть слова, которые включены в синтаксис. Ну, скажем, «определение функции на питоне». Значит, def – ключевое слово, значит, если оно встретилось, то след за ним будет идти определение функции. If-then-else. Практически во любом языке есть, так сказать, такого сорта конструкции. «Фо», то есть «цикл». Вот эти ключевые слова я имел в виду. То есть те слова, которые являются элементом формальной грамматики. и которые поэтому не могут быть использованы в другом смысле. 

S02 [00:28:42]  : – То есть, имеется в виду, что у вас в языке есть некоторые предопределённые ключевые слова, то есть, они всё-таки есть, и выражения на вот этом языке, они их не могут включать, правильно? 

S00 [00:28:57]  : – Нет, их нет. То есть, нет аналога. 

S02 [00:29:02]  : А, то есть язык не предусматривает ключевых слов. А можно тогда сразу вопрос? Потому что у меня другой вопрос по этому поводу был. У меня идеология похожая, но я старался как раз избежать непонятных всяких значков. Мне у вас глаз резануло, как раз красным цветом выделены некоторые значки, которые неинтуитивны. Если я правильно понимаю, у вас эти значки играют роль ключевых слов? 

S00 [00:29:36]  : Да, но их немного. Я сейчас вернусь сюда. 

S02 [00:29:43]  : Можно конкретный вопрос? Самое плюс к тому, что вы сейчас поясните. Вот, например, вам нужно действительно сказать DEF. Что у вас вместо DEF? 

S00 [00:29:52]  : А вместо DEF у меня… DEF – это означает, что я делаю определение функции. И она имеет имя, так? Значит, я напишу имя функции. Ну, скажем, синус я хочу определить. Значит, я пишу синус двоеточие. Двоеточие означает, что у меня слева есть объект, а справа есть то, что я хочу о нем сказать. А дальше я напишу, что это функция. 

S02 [00:30:35]  : А вслед за этим напишу в квадратных скобочках последовательность операций, которые… То есть, у вас все-таки будет слово «функция» или «фаншин», но это слово будет не ключевым словом, а оно будет содержаться частью лексикона, правильно? 

S00 [00:30:53]  : Да, совершенно верно, оно будет частью лексикона, то есть есть некое количество предопределенных понятий, которые всегда присутствуют, но они являются частью лексикона, то есть понятия предопределенные, а слово, которое соответствует понятию, оно зависит от лексикона. На английском будет функция, на русском будет функция, на китайском еще что-то. 

S02 [00:31:24]  : Да, понял, как говорится, Бинго. Спасибо. Еще два вопроса. У меня один еще вопрос, точнее комментарий с вопросом. Мне ужасно понравилось то, что вы говорите про корректировку. и визуализацию для удобства. И возник вопрос, а что вы думаете, если для удобства пользователя вообще сделать так, чтобы редактирование было не во фритексте, а в каком-нибудь структурированном редакторе тогда уж, чтобы пользователь, в принципе, не мог сделать ошибку. То есть, там, где надо надбивать слово, А там, где нужно выбирать между каких-то слов из лексикона или те, которые соответствуют семантике, то дать возможность только жёсткого выбора? 

S00 [00:32:14]  : Ну, я думаю, что это, в принципе, очень удобно могло бы быть, но это сложно, и поэтому я не пытался это сделать. 

S02 [00:32:26]  : Я просто в качестве комментария, мне все очень нравится, потому что я говорю очень похоже, как у меня, но у меня проблема такая, что как раз пользователю непонятно, что вводить, потому что всего очень много. Все понятия в голове не удержатся, тем более, если новый пользователь. А вот такое вот выделение, оно бы очень помогло. А в другом проекте, значит, похожем, была, значит, давно такая история, что пользователя была опция. То есть, когда ему нужно что-то ввести, у него есть текстовое окошко, а есть вот этот вот структурированный редактор, где можно вводить только то, что можно вводить. При этом у пользователя есть свобода редактировать либо там, либо там. И когда он редактируется в свободном тексте, то автоматически фиксируется вот эта жесткая структура, расширяется. А когда он редактируется в структурированном редакторе, то автоматически генерится текст. И пользователь может прыгать из одного места в другое и набирать и там, и там. В принципе, кстати, в свободном тексте то же самое можно делать с автокомплитом. 

S00 [00:33:28]  : По поводу этих специальных символов, типа пустое множество там или вот там, где запрашивается определение, то есть есть там четыре или пять, я не помню точно, специальных символов юникодовских, которые можно набирать. У меня они высвечиваются в начале и им соответствуют клавиши F1, F2, F3 и так далее. И при этом не просто соответствие символ-клавиша, а символ-клавиша и смысл операции. Это вот некая подсказка, она не столь автоматизированная, как то, о чем только что вы говорили, но, так сказать, какой-то аналог, более простой. 

S02 [00:34:34]  : Понятно, спасибо. Прям жалко, что мы с вами не над одним проектом работаем. Еще вопрос от Владимира Смолина. Можно ли пояснить, в чем отличие от СУБД? 

S00 [00:34:45]  : От системы управления баз данной? Да. Ну, система имеется в виду в смысле языка? 

S02 [00:34:56]  : Владимир, поясните ваш вопрос, я тоже не понял. 

S05 [00:35:01]  : Мне кажется, что все, о чем рассказано, вот система управления базами данных вполне реализует. Или что-то есть такое, что она не может реализовать? 

S00 [00:35:13]  : Ну, система базы данных, она не приспособлена для хранения семантической информации, во-первых, а во-вторых, в системе баз данных все операции, которые мы хотим делать, мы должны описать сами этими функциями. То есть, если мы хотим, скажем, найти Вот как тут написано «найти аналогии». Мы должны написать на SQL или на другом языке, если это не религионная база данных, как именно мы будем искать шаг за шагом. А здесь речь идет о том, что мы говорим, что нужно найти, а алгоритмы зашиты внутри. То есть, здесь язык не программирует, а выбирает одни из тех операций, которые уже реализованы внутри. 

S05 [00:36:27]  : Ну, я так полагал, что есть базы данных, а есть система управления базой данных. Вот система управления базой данных как раз все это зашчивается. Вот в чем отличие? 

S00 [00:36:39]  : Ну, в этом смысле можно сказать, что отличия в интерфейсе, наверное, несущественны от баз данных. Но главное отличие это в том, что здесь интерфейс служит только для того, чтобы что-то спросить у системы или получить от нее информацию. А в промежутках между коммуникациями она работает и выполняет свою работу. В то время как в базе данных, если я в нее не спросил чего-то, она стоит и ждет. 

S05 [00:37:26]  : Можно пояснить, а какую работу она выполняет, если ничего не спрашивать? 

S00 [00:37:30]  : Какую работу? Она опрашивает сенсоры, принимает решения и передает команды на актуаторы. То есть это автоматическая система управления. Если мы представим себе, что она управляет автомобилем, то это означает, что мы можем отдать команду ехать куда-то и потом ничего дальше не спрашивать. Она едет себе и едет. В какой-то момент мы можем спросить, а сколько нам осталось до... прибытия, она ответит, но при этом она продолжает ехать и везти машину. 

S05 [00:38:12]  : Ну, то есть, только про часть рассказали про интерфейс, а про то, что там какая-то есть еще большая часть, просто сегодня не удалось рассказать. 

S00 [00:38:18]  : Сегодня про язык интерфейса, а про... Да, да, здесь только о языке интерфейса, а там есть как бы перманентно работающая система управления тем объектом, ради которого она создана и для выполнения тех миссий для которых она создана. 

S02 [00:38:42]  : Николай, тогда уж последний провокационный вопрос раз про СУБД зашла речь. А чем ваш язык лучше СКЛ? 

S00 [00:38:53]  : Чем лучше СКЛ? Ну, тем, что он специализированный. 

S02 [00:39:03]  : А в чем именно специализация? Потому что с помощью SQL тоже можно создавать новые объекты данных и тоже можно транслировать те структуры, с которыми оперирует SQL в графовую структуру, можно SparkQL использовать. 

S00 [00:39:21]  : Ну, я не знаю, как легко можно реализовать, ну скажем, вот простая вещь, поиск по неименованной сущности. Неименованная сущность, которая задается двумя или тремя там признаками. В принципе, реляционной базой данных можно имитировать эту работу, и можно граф держать в реляционной базе данных. Но язык, который здесь предложен, он больше соответствует смыслу понятия, поэтому он более лаконичный. и он не требует, в отличие от SQL, описания того, что я хочу делать. То есть, если я делаю запрос на SQL, то так или иначе я подразумеваю формат данных, какая таблица, откуда что взять. Значит, здесь всего этого нет, нет понятия таблицы. Откуда я должен брать в SQL данные? Из какой-то таблицы, правильно? Здесь мне этого не нужно указывать. Значит, текст получается более коротким. И не просто более коротким, а аналог каждого из этих операторов на SQL будет десятки строк, вообще говоря. 

S02 [00:41:06]  : Спасибо, Николай. Мы уже выкладываемся из регламента, но вот есть очень жесткий вопрос, очень важный. У вас время есть в языке? 

S00 [00:41:16]  : Время не просто есть, а время есть существенный элемент, но это отдельная эпопея. То есть на уровне языка время – это всего лишь текущее время или атрибут, а внутри системы время есть и есть зависимость параметров от времени как от функции. 

S02 [00:41:52]  : Ну то есть, время есть в системе, но в языке время не является чем-то отличным от света или координат и от веса. Правильно? Да, да, да. Хорошо. Именно так. Хорошо. Николай, спасибо. Здорово. Теперь следующего, пожалуйста, Алекс Шкотин. 

S06 [00:42:17]  : Так. Мне тут надо что-то получить или нет? А, могу, могу. Сейчас я найду, вот оно. 

S02 [00:42:26]  : Вам нужно, наоборот, отдать, а не получить. 

S06 [00:42:30]  : Да. Даю. Хорошо видно? Да, да, да, прекрасно. Значит, коллега, у меня как бы другой будет, может быть, даже задача или идея. Вот есть такой проект, создание контролируемого русского языка как средства и так далее. И вот я тут написал ТТТ – тактико-технические требования. Но, конечно, это слишком жёсткое утверждение. А вот поделиться некоторым маленьким опытом, в том числе состояние дел в этой области, Вот почему. Потому что контролируемого русского языка нет, вот с моей точки зрения. Есть пара-тройка попыток его сделать, а самому его нет. В отличие, например, от контролируемого английского, которых примерно 50. Вот, значит, вот тут идея Лебница, я ее привел для того, чтобы, так сказать, понять весь объем задачи по точной записи знаний, науки, техники и законодательств на некотором формальном языке, обеспечивающем математическую обработку. Вот Лебнец, ему было, по-моему, 25 лет, и он в дневнике у себя написал вот эту цитату, которую я нарыл где-то в интернете. Это как бы задача в целом. Соответственно, если мы на нее смотрим по-простому или по-хорошему, вот так же, как Николай говорил, и все мы знаем, нужен контролируемый русский язык, И нужен формальный язык. Я тут ссылаюсь на свой любимый ЯФЛ, который расцифровывается как ЕТНАДО formal logic language. Но это как бы, простите, может быть любой другой. Так вот, контролируемый русский язык предназначен для взаимодействия людей с информационными системами, моделирующими реальность. В Яффле, вот коротенько, на нём можно записывать формальные теории и модели для этих теорий. Ну и почему бы не поговорить об этих моделях и о том, что записано в формальных теориях на русском языке. Вот одно из важнейших тактики технических требований, по которым мы, кстати, разошлись с Юрием Петровичем Миловым, а он тоже энтузиаст, КРЯ. Что КРЯ – это подмножество предложений классического литературного русского языка. Например, некоторые тексты Саши Соколова он не пройдет. Вот тут я повторяю, что основная идея – это не охватить весь спектр, в том числе применение языка, поэтических и так далее. А нам нужны точные знания о науках, техниках и нормативных текстах. Эта работа идёт по всем этим направлениям. Формализация. Но не на русском. То, что такие чекеры есть, мы знаем. Винворд-чекеры есть. Так вот, что важно, правила грамматики выписываются русского языка, всем известный, который мучает и ужесточается. Но это остаётся русский. Ну, как обычно, у него будет лексический анализатор, синтаксический анализатор. Вот тут важный момент. Это второе основное требование. Оно состоит в том, что дерево синтаксического подчинения Это то, как лингвисты представляют себе предложение русского языка, когда они его рисуют структурно. Так вот, синтаксический анализатор его и должен строить. Ну а генератор кода, то есть трансляция формальной языки или вербализатор формальных языков назад – это, так сказать, само собой. Вот я тут немножко расскажу, что если бы мы делали кре для яффл, то нам понадобились бы следующие подъязыки. Язык ведения структур. То есть некоторые структуры мы можем строить и можем ими манипулировать, в том числе, например, задавать значение функций. Язык запросов – свой структур. В том числе аксиома предметной области – это фактические свойства. У нас формально это свойство, которому должна удовлетворять структура. То есть мы должны запрашивать, уметь запрашивать структуру. Извините, я, к сожалению, немного простой. Язык задания определений – это для построения хорошей теории. Аксиомы и теоремы – это частные виды определений. И, конечно, если говорить о теоретических знаниях, то нам нужно в идеале доказывать теоремы. Для этого есть средства, кок-холл, 4TPTP и так далее. Вот пример дерево-синтаксического подчинения, которое, так сказать, вы все знаете, и Ленграмма его знает, и так далее. Тут сразу вот гладкий, у него в книге приводится так называемая синтаксическая амонимия, когда можно по-разному понимать одно и то же предложение, простое. Так вот, процессор, который обрабатывают контролируемый русский язык, он должен либо уметь распознавать, ну и, например, обращаться к тому, кто написал, что, мол, ты понимаешь, что тут есть два варианта того, как это понимать, какой ты имел в виду, либо жестко ограничивать правилами, жестко ограничивать, что вот раз школьники и старецы, значит, все, дорогой, школьники и старецы. Это значит «дерево синтаксического подчинения». Это термин лингвистический натуральных лингвистов. Вот это просто пример дерева синтаксического подчинения а-ля Сим-Син. Это питерская разработка Боярского. Антон Германович знает про него, насколько я помню. Так вот, ну это просто пример. Вот ДСП выглядит примерно так, и в СимСинг ставится вот вопросики, прямо в дереве ставится. Вызывает что, вызывает как, и поехали. Другая – это классическое «может быть». Дерево разбора вывода контекстно-свободной грамматики. Но у меня нет в грамматике контекстно-свободной контролируемого русского языка. Тут просто пример. Так сказать, известны не терминалы, не терминалы, не терминалы, упорядоченные дети – тоже не терминалы. А, тут кусочек, который до терминалов даже не доходит. Это, кстати, один из недостатков дерева – разбора вывода, что там только в листьях сами тексты предложений, которые мы разбираем. Что, кстати, даёт произвол. И ещё один вариант – это синтаксическое дерево. Оно ещё компактнее, чем дерево подчинения и линграма, потому что это дерево, устроенное только из слов предложений. То есть слова предложения расположены и в узлах дерева, и на стрелках. Ну, это, так сказать, просто симпатично. Кстати, для естественного языка расположить глагол на стрелке тоже хорошо смотрится. Это просто разные варианты того, что хотелось бы получить. Вот тут я хочу кратенько показать следующее. Когда мы базу данных пробы, это геологическая база данных образцов, разгружали в тексты на естественном языке, и там утверждалось следующее, что вот база данных, сама революционная, Позгорец там и так далее, что именно разгрузив ее в тексты того или иного шаблона, это само собой, мы получаем и зафиксировав вот эти вот виды высказываний, мы получаем все те знания, которые реально есть в этой басе, потому что там накручено было программистами еще куда больше. А вот сформировать на кря, я не знаю, видно или нет, вот тут, например, ПАП есть в статье. Год издания статьи ПАП есть 1946, или ничто. Название статьи ПАП есть, ну и, соответственно, название. И так далее. Довольно простые предложения. С чего бы им быть сложными? Контролируемого русского языка, если бы он у нас был. Вот в этой колонке это предложение на английском, на языке эйс, на контролируемом английском языке, который давным-давно сделал в Цюрихе профессор Фукс, и который имеет, как говорится, компилятор. Некоторые предложения ACE, например, вот эти, специально старался, подбирал, транслирует в AU, в L2, то есть уже в формальный язык. Ну, а то, как та же самая информация, точнее так, знания, представляются на first to the logic, т.е. исчисление предикатов с числами, скажем так, ну и на моем любимом Яффле, это не столь важно, т.е. здесь важно на самом деле следующее. Вот этот вот кря, Я, когда у нас появились все высказывания, и мы, кстати, с владельцем базы данных, мы ему предъявили эти виды высказываний и спросили, что как бы мы все знания вытащили из базы данных, ничего не забыли, он сказал, нет, всё, да, вот это всё, что там есть. Это не то, что здесь на экране, там предложения много разных, потому что это геологическая база. Ну так вот, некоторые из этих предложений я попросил разобрать и вернуть мне дерево разбора Симсин Боярского. К сожалению, часть этих деревьев была разобрана неправильно. Причем, что обидно, вот какова там нет никакой синтаксической амунимии. Это просто некоторые предложения русского языка. А дерево подчинения почему-то не построилось. Но ответ был простой. Да, многие разобрались, или большинство, скажем так, правильно. Но ответ был простой. Конечно, все это можно подкрутить. У него тогда было более 50 правил разбора построения деревьев. Но, мол, нужно финансировать, ребята. Я это в том числе хочу подчеркнуть. То, что контролировал русский язык, можно сделать, тут сомнений нет. Вот Боярский со своей командой мог бы его и сделать. Но заказа такого, чтобы профинансировать людей, такого нет, хотя очень многие, ну, не очень многие, кое-кто в этом направлении близко. Ну, вот, значит, процессоры языка, штука, которая умеет общаться на этом языке, лексический анализатор, синтаксический анализатор, включая World Formless Constraint, вот то, что Николай говорит, то есть там есть дополнительные требования, конечно. Исполнитель, работающий на дереве синтаксического подчинения в прошедшем статической проверке, у него уже база, которая содержит структуру задачи, Ну и отображение предложений, это то, что я уже говорил. И вот последняя идея, она тоже всем известна, но для завершения. Когда мы имеем картинку и мы ее структурируем, то у нас там появляется граф, у нас по идее появляется граф. Мне для полного счастья нужно две вещи. Вот чтобы по картинке мне выкатили помеченный граф, грубо говоря, совокупность геометрических фигур, помеченную отношением между ними, ну и желательно классом фигур тоже пригодится. А с другой стороны, дерево синтаксического подчинения. Вот когда кто-то сказал, котенок лежит на мате около двери. Сопоставление этих двух структур, вот тут есть чем заняться математикой. Вот это вот как бы такая основная песня. Теперь заключение. Значит, вот где-то году в 1915, может быть, раньше родилась идея, что ребята, давайте сделаем, у нас такой централизованный государство, давайте сделаем государственный стандарт. контролируемого русского языка. И постепенно всех убедим, что очень хорошо на нем писать, по крайней мере, в государственных учреждениях тексты. Их можно будет обрабатывать процессором. Так вот. Ну, этого в свое время было сообщение, вот его Фукс писал там в своей группе, что его эйс, attempt to control English, был где-то как-то Европейской комиссией принят там для чего-то. Ну, как бы вот таких вот прям сообщений, что да, чиновники там начали писать на эйс, такого не было. Вот это в некотором смысле загадка. То есть широкого внедрения контролируемых английских нет, про них не слышно. И вот тут моя такая простая гипотеза, что какого-то снукшибательного эффекта, ведь там более 50, они применяются в тех или иных, скажем так, конторах, от какого-то сногсшибательного эффекта от применения контролируемых языков. Это не значит, что контролируемый русский не надо делать, тем более для АГИ. Пока нет. А вот, скорее всего, это происходит потому, что сами формальные языки, они не очень-то пока, скажем так, мощные, Потому что такая насущная проблема, как доказательство свойств программ, в общем-то, тоже пока индустриально не идет. Ну и даешь один интерфейс на кря. Так, сейчас я минуточку посмотрю. А, ну тут ссылки. Поэтому вот я, по идее, могу посмотреть вопросы и сказать, как нам всем будет хорошо, если у нас будет контролируемый русский язык. Но, по-моему, это и так очевидно. Так что хуй я все сказал. 

S02 [00:58:40]  : Алекс, спасибо. У меня есть несколько вопросов и комментариев. Вот здесь от Сергея Терехова хороший вопрос. Можно ли корректно разобрать кря автоматически, если система не понимает смысла сказанного? Речь идет о разборе цепочек из связанных предложений. 

S06 [00:59:02]  : Как всегда, там есть несколько фаз. Потому что одно дело, и вот то, с чего мы начинаем, это построение, это грамматический разбор, когда строится либо дерево вывода, либо строится вот это дерево синтаксического подчинения. Вот в контролируемом русском языке дерево синтаксического подчинения будет построено всегда, он так задумал. После этого, когда вот это очередное предложение, а там до этого много приходило, и вот в данный сеанс много приходило, когда оно пришло, оно, конечно, сверяется со всеми, если сказать так грубо, разобранными предложениями, и там может возникнуть много разного. Поэтому… Это большой процесс. Процесс обработки контролируемого русского языка, он, грубо говоря, возьмем какой-нибудь атлатчик, какой-нибудь IDEA, она выполняет очень серьезную работу не только по по строению информационной системы на каком-то языке программирования, ну и по ее отладке, и, в конце концов, по ее запуску и эксплуатации. Вот представьте, что вы работаете с ней на кре. Вот и все. Там возникнут все те же самые вопросы. 

S02 [01:00:38]  : – Алекс, а можно к кошке вернуться? 

S06 [01:00:41]  : – К кошке? Сейчас. 

S02 [01:00:42]  : Да, я хочу еще уточнить вот этот же вопрос, но отталкиваясь от кошки. Окей. Вот смотрите. А что если мы хотим сказать про то, что эта кошка, например, серая, а мат дырчатый? вот мы можем сказать что котенок лежит на мате около двери он серого цвета он серого цвета а точь а то наш на чем он лежит дырчатая или хотя бы вот первое утверждение хотя к референс и анафоры там разрешаются говорится хороший вопрос 

S06 [01:01:22]  : Вот существует трюк, который надо обсуждать, скажем так, с разработчиками, когда в языке разрешаются переменные, а анафора запрещается. И вот котенок X лежит на мате Y, А икс там серый, а мат дырчатый. 

S02 [01:01:45]  : Но это уже будет не русский язык. Это уже будет шаг к логическому языку, к формальному языку. 

S06 [01:01:53]  : Мертвые души Гоголя начинаются в городе Эн-Эн. Бричка выехала в ворота города, гостиница, трактир, не помню, города Эн-Эн. Это не русский язык? 

S02 [01:02:06]  : Да, у нас еще есть, что первому второму, значит, он сказал, Вася сказал петь, и первый дал второму по носу. При этом вам первый – это Вася, а второй – это Петя. 

S06 [01:02:20]  : Окей. Понимаете, идея в том, что разработка контролируемого русского языка, вот этих его правил, может быть, особенность. Я, например, за переменную. И я написал Фуксу, спросил, а русский нельзя ли сделать? Вот он английский сделал. Он говорит, нет, ты чего, я потратил столько лет на английский, кто потратит столько же на русский? А второй, я его попросил сделать переменное, по-моему, я сейчас точно не буду говорить, что-то. Он сказал нет, и так пойдет. Детали разработки контролируемого русского языка, безусловно, это непросто. Да, запретить анафору – это серьёзно. Ну а это один из вариантов. И ввести локальные переменные. 

S02 [01:03:11]  : Ну, на самом деле, анафору тоже можно считать переменной. Просто мы говорим, что в одном контексте может быть не больше одной переменной. Ограничить количество переменных. Хорошо. Ну это ладно, я понял. Это уже надо обсуждать. Конечно. Вопрос ещё от Александра Петрова. Контролируются утверждения или знания? 

S06 [01:03:36]  : Вот идея контролируемого русского языка в том, что его грамматика настолько простая, что структура предложения может быть получена без особых проблем, скажем так. Нужно ли при построении структуры предложения знать некоторые, как это сказать, такие семантические особенности тех или иных слов – это открытый вопрос. Например, вопрос, связанный с так называемой полиморфой допустимых, мы в некоторых языках программирования, на которых естественный язык просто держится, он держится на полиморфе, на том, что одно и то же слово, один и тот же термин имеет кучу разных значений, и на какой-то теории типов. То есть построение для общего случая не будет простым, и какие-то знания, конечно, будут. о том, что собой представляет термин, что это. Ну, например, типы его аргументов, глаголов. Это будет где-то и как-то записано вот в том, что было там упомянуто, как «Wealthfulness Construct». Ну, где-то они там есть. То есть это, безусловно, будет. 

S02 [01:05:04]  : Спасибо. Еще один вопрос по поводу хода. Хороший вопрос, тоже я хотел задать. Насколько создание кря объективно сложнее, чем для английского? Скажем так, насколько я знаю, в большинстве английских языков не нужно возиться с морфологией контролируемой, а может быть и во всех. Там морфология не нужна в силу особенностей английского. А вот у вас котенок лежит на мате. Почему котёнок лежит на мате около двери, а не котёнок лежит на мат около дверь? 

S06 [01:05:42]  : Потому что это литературный русский. А вот те, кто ориентируется на ОВЛ, или на… ну, на увейль на самом деле. Им на это, грубо говоря, наплевать. Так вот, дело в том, что вот этот вопрос о том, что там и насколько это сложно, если бы мы это стали, так сказать, развивать, это надо было бы спросить Кирилла Боярского. Вот он это умеет делать. И я говорю, у него в его системе когда-то было от 50 до 70 правил. Да, это сложнее, чем в английском, но это преодолимо. Это не Бином Ньютона. Это может быть кропотливая работа, может быть еще как-то, но чекеры это делают. 

S02 [01:06:36]  : А, кстати, вот насчет того, что Боярский не смог разобрать ту таблицу, которую вы показывали, если можно к ней вернуться. Там у вас есть какая-то странная, значит, странная конструкция. 15 дробь ничто. Вот я бы, честно говоря, тоже не разобрал. Не то, что Боярский. 

S06 [01:06:51]  : Нет, коллеги, не так. Вот я сказал следующее. Пара-тройка предложений, которые я выкатил Боярскому, они были неправильно разобраны. большинство были разобраны правильно таблицы это просто пример меня вот что значит такое что значит 146 дробь ничто то есть год издания он может быть здание статьи есть ничто а при чем здесь 1946 ну или тут не знаю насколько видно 

S02 [01:07:23]  : Я понимаю, а почему или? А как так может быть, что год либо 46-й, либо ничто? Это как? 

S06 [01:07:28]  : А это когда в базе данных нету... А почему тогда 46-й? 

S02 [01:07:32]  : Нет, если нет, я понимаю, если был год издания, есть ничто, или если был год издания статьи, есть 1946-й. А почему через дробь-то? 

S06 [01:07:43]  : – Согласен. Вот мне захотелось… А, слушайте, я уже сам забыл всю гениальность языка. Это назначение, а через слэш – снятие. Вот если я пишу год издания статьи есть 1946, Это приказ системе запомнить, что год издания этой статьи – 1946. А если я после этого пишу год издания статьи есть ничто, то она должна забыть. – А что она должна забыть? – 1946. Она должна забыть 1946. После этого вопрос – какой год издания статьи? 

S02 [01:08:31]  : Тут есть вопрос, насколько это литературный русский язык, когда больше похоже на… Да, конечно, конечно. 

S06 [01:08:41]  : Это отдельный вопрос. Чем-то он чуть-чуть, наверное, будет отличаться. Например, год издания статьи там есть, надо будет писать «Неизвестен». Вот на чисто литературном русском языке год издания статьи «Папа там так-так» «Неизвестен». Да, согласен. 

S02 [01:09:07]  : Хорошо. Александр, спасибо. К вам ещё много вопросов, но поскольку нам надо укладываться в регламент, если сможете, то в чате, пожалуйста, ответьте тем, кто вопрошал к вам. Переходим к следующему докладчику. Им, по-моему, являюсь я. Если мне память не изменяет, если изменяет – поправьте. И я покажу свой достаточно старый доклад. По нему я быстро пробегусь. История того языка, которым я не то чтобы занимаюсь. То есть, он у меня сейчас используется в продакшене. Хотя он не полностью разработан. Скажем так, где-то примерно на середине заморожен. в силу объективных причин. Но идея языка заключалась в том, чтобы сделать некоторый язык, на котором бы в первую очередь общались бы люди с искусственным интеллектом и системы искусственного интеллекта друг с другом. То есть, мотивация, в принципе, наверное, похожая на ту мотивацию, которая у Николая и у Алекса, ну плюс, значит, у меня была ещё идея, что системы искусственного интеллекта тоже будут на этом языке друг с другом общаться таким образом, что люди смогут понимать, о чём они общаются. То есть, чтобы они там не морзянкой друг к другу что-то посылали, значит, и не на каких-то, или не QR-кодами обменивались, а чтобы человек мог перехватить сообщения двух искусственных интеллектов и понять, о чём у них идёт речь. В качестве гипотез того, какой язык используется, можно использовать языки низкого уровня, какие-то сетевые протоколы, можно использовать языки программистские, но это не очень удобно. Вот. И потому что тем более, что английский, латчбан, эсперанто – это все языки, которые являются неоднозначными, они требуют достаточно сложного разбора, поэтому языки программирования и формальные языки, они сложные для простого пользователя, поэтому вот как раз была идея, что нужно создать тот самый контролируемый язык, про который рассказывал Алекс, где язык ограничен, во-первых, набором грамматических конструкций, во-вторых, лексиконом. При этом, как и в случае, про который говорил Николай, лексиконы будут доменспецифические. Более того, лексиконы могут загружаться. То есть, мы, в принципе, систему, работающую в одной и той же предметной области, можем Имея одну и ту же грамматику языка, мы можем для этой системы перезагружать лексиконы и таким образом русифицировать систему. Сразу, забегая вперед, скажу, что, естественно, в этой ситуации по-английски будет cat lies on mat, а в русском это будет кот лежать на мат. Примерно так, как говорят люди, плохо владеющие чужим языком. Ну вот, собственно, примеры. Про мотивацию я рассказывать не буду, она понятна. Вот пример того, как, например, взаимодействие с одним и тем же умным термостатом может быть описано на русском и на английском. На английском оно звучит более natural language. Умный термостат говорит человеку. MyIsApplianceAgentThermostatDevice. Сразу в пику Николаю скажу, что мне кажется, что мой синтекс более интуитивен, потому что я использую запятые, привычные в natural language, а не какие-то значки, а не скобки, которые у него используется для этой цели. Хотя, в принципе, идея примерно та же самая. Ну и вот то же самое на русском. То есть, мы просто перезагрузили лексикон, имеет ту же самую структуру грамматическую. На морфологию падежей и склонения мы забили. Но, тем не менее, информацию мы можем передавать на любом из этих языков. Значит, как Николай уже сказал, язык у нас является просто способом отображения некоторого формального графа. Последовательность символов. Граф у нас непоследовательный, граф у нас н-мерный. Мы его пытаемся выложить в линейку. В данном случае простой граф, связывающий конкретный совершенно термостат с конкретным значением параметра влажность. В семантическом ВЕБе он может быть описан как номер 13 некоторого термостата, у которого есть свойство влажность, и это свойство является номером. То есть мы говорим, что вот у термостата есть некоторое свойство, которое является численным значением. Это свойство влажность. Ну и вот это выражение мы можем транслировать через разные namespaces. в русский язык, либо в английский язык, получая прозрачно выражение на контролируемом русском, либо английском языке. В этом языке есть четыре наклонения. Первое наклонение – это interrogation. Здесь бирюзовым цветом приведён пример того, как мы задаём вопрос в рамках этого языка. Мы фиксируем некоторые вершины термостата кухни с помощью имён. Дальше мы фиксируем то, что эти вершины должны быть связаны с неизвестной вершиной через свойство наследования и через свойство положения, что это термостат и это кухня. Место расположения неизвестно. А дальше мы говорим, что у этого неизвестного нам интересна температура которая сейчас и та температура, которая у него установлена. Какую температуру он должен достигать. Вот как это выглядит в бирюзовом цвете на нашем языке. Важно здесь, что в отличие от Усквеля где задавая запрос на SQL вы получаете просто строчку в таблице через запятую, через табуляцию, через точку с запятой. На нашем языке вы получаете на самом деле выражение на том же самом языке. То есть если SQL с точки зрения схемы использования клиент-серверный язык, он асимметричный, то здесь язык симметричный. Есть два агента, где как человек, так и машина могут задавать вопросы друг другу, могут давать декларативные выражения друг другу, могут давать интеррогативные. утверждение, делать друг другу. То есть, всё происходит симметрично, как это происходит в человеческом языке. Соответственно, вот жёлтым светом есть декларация, которую в данном случае умный термостат даёт человеку, что у термостата, расположенного на кухне, реальная температура 30, целевая температура 25. После чего человек хочет изменить ситуацию и даёт директиву. Директива, потому что в конце восклицательный знак, декларация, потому что в конце точка, интеррогация, потому что в конце вопросительный знак. То есть, директива имеет такую же грамматическую структуру, как декларация, но только есть восклицательный знак, который говорит, что это то состояние, в которое нужно перейти. Вот пресловутая грамматика. Хороший вопрос, является ли эта грамматика контекст-фри или контекст-сенситив. И грамматика двойная. То есть, на самом деле, одну и ту же конструкцию, одни и те же конструкции подобного рода можно строить без специальных структурирующих знаков припинания, такие как скобки. трех видов, а можно и строить со скобками. Если выражение строить со скобками, вот здесь вот есть специальные скобки, фигурные скобки, круглые скобки, квадратные скобки, чем они отличаются, я чуть позже скажу. Если мы эти скобки не используем, то мы получаем возможность выражение на этом языке отдавать устно. То есть, в чем прелесть естественного языка, не используя специальные символы, которые есть у Николая, и почему я старался по максимуму избегать специальных символов, ограничив их количеством только вклюцательным знаком. вопросительным знаком и точкой, потому что, значит, интеррогацию мы можем, конечно, тональность, через тональность звукового сообщения мы, значит, вопрос, наклонение вопросительное или повелительное или декларативное можем распознать по голосу, вот, а структуру мы голосом никак не передадим. Поэтому идея заключается в том, что мы должны иметь возможность простые выражения и простые конструкции передавать без всякой структурирующей разметки. А для программирования, когда мы хотим задавать какие-то сложные структуры, которые голосом не передаются, то используются те механизмы, которые позволяют строить сложные эротические структуры. Иерархические структуры могут строиться через вложенное множество, это перечисление, это дезюнктивные наборы через OR, то есть если мы объединяем элементы языка или statement в фигурной скобке, то это мы строим дезюнкцию, если мы в круглой скобке объединяем, то мы строим конъюнцию, если мы объединяем элементы в фигурные скобки, то это мы строим последовательную конъюнцию, то есть это мы, по сути, генерируем последовательность, говорим, что элементы должны следовать в строго определенной последовательности. Например, если мы даем директиву, то мы можем В фигурных скобках последовательно выразить тот набор команд или инструкций, которые система должна выполнить. Вот примеры того, как на данном языке мы можем задавать вопросы, отдавать директивы. Допустим, на естественном английском языке слева, на естественном русском, где тональностью мы подчеркиваем Собственно, повелительное наклонение, вопросительное или декларативное. Соответственно, в естественном английском это определяется порядком слов. Здесь у нас это все определяется вопросительным знаком точкой или восклицательным знаком в конце. Вот здесь как раз пример, как мы работаем со структурами. Мы можем для кодирования структур В контекст-фри варианте, со скобками, мы можем создавать структуры, объединяя некоторые элементы деканьюнцами и дизюнцами. Вот здесь, например, не используя «and» и «or». А если мы хотим распринимать конструкции на этом языке из устной речи, то мы используем более сложную, более длинную нотацию, мы не используем скобки, мы используем «and» и «or» или, соответственно, в русском «и» или «или». Ну и вот сравнение того, как одни и те же конструкции могут быть записаны на нашем языке и в логике термов или на тортле, который используется в Semantic Web. Есть более сложные варианты того, как этот язык может использоваться для программирования каких-то триггеров или логических условий. Некоторая программа, управляющая на этом языке, написанное для данного умного термостата. Как мы можем указывать время. работать со временем, с координатами. Вот пример того, как это работает в продакшене. То, что мы сейчас видим на экране – это выхлоп интеграционного теста системы. Все функции, которые в нашем проекте по персональному агенту для работы с интернетом, реализовываются все эти функции. Они доступны не только с помощью пользовательского интерфейса. Все эти функции, они доступны с помощью языка агентов и, собственно, интеграционной тест-системы, которая выполняется с каждым билдом. Он просто по скрипту. На агентском языке прогоняет все возможные действия, которые возможны с точки зрения бизнес-логики и функционирования системы. Классификации, разборы. Анализ веб-страниц, извлечение сущностей, создание новых сущностей, извлечение каких-то отношений между ними. То есть, всё, что можно сделать в системе, оно кодируется с помощью языка, и вот, собственно, тест это дело проверяет. При этом, собственно, взаимодействие между этими элементами системы, оно тоже делается на данном языке. То есть, как раз тот самый случай, когда мы используем язык внутри системы, но он используется не для того, чтобы система думала на этом языке или совершала на нем какие-то операции мыслительные. Внутри все делается, у Николая это делается на C++, у меня это делается на Java. Но для многомодульных систем, когда система представлена, например, из некоторых суперпозиций агентов, где одни агенты ответственны за анализ веб-страниц, другие агенты ответственны за анализ баз данных, третьи агенты направлены на анализ блокчейна, и они как-то между собой должны обмениваться этой информацией. Вот такой обмен информации может делаться через конструкцию на этом языке. В данном случае, например, в случае веб-приложения, взаимодействие веб-клиента с сервером, оно тоже делается на этом языке. То есть все, что мы видим на пользовательском интерфейсе, это результат того, что JavaScript слой дает запросы на языке агентов на сервер, а сервер на языке агентов дает декларативное утверждение клиентскому ядру на JavaScript, который отображает это все в виде графических элементов. Переходя теперь к вопросам. Переходя теперь к вопросам. Нужен ли специальный язык для программирования EGI? Соглашусь, Николаем, скорее всего, не нужно. Но хотя, опять-таки, если мы предполагаем, что взаимодействие с EGI включает в себя какое-то программирование, если мы сделали некоторое ядро системы и мы хотим это ядро обучить чему-то другому, то с одной стороны мы это можем обучить за хардкоде в какую-то базовую логику, введя какие-то дополнительные в том числе базовые понятия в системное ядро, а мы можем той же самой логике научить систему в процессе взаимодействия с ней, создавая какие-то новые сущности, добавляя новые атрибуты существующим сущностям, дописывая какие-то функции с помощью тех элементарных действий, которые агент может совершить, в этом случае можно сказать, что мы программируем. То есть, мы на самом деле и людей можем программировать. с помощью естественного языка. В этом смысле, конечно, высокоуровневое программирование может осуществляться с помощью этого самого языка. Для внутренних операций самого AGI, я не уверен, что оно нужно внутри каждого отдельного модуля, но если у нас система распределенная из специализированных модулей или модулей, выполняющих одни и те же функции в рамках балансировки нагрузки, почему они не могут взаимодействовать между собой. На самом деле, одна из мотиваций разработки этого языка, вот конкретно в данном проекте, она возникла из того, что захотелось написать достаточно гибкий интерфейс для того, чтобы этот интерфейс можно было переконфигурировать на лету без каких-либо серьезных изменений, не прописывая эксэмэльские схемы для протокольных взаимодействий. То есть идея была такая, что можно сделать интерфейс, который будет гибким, что на лету можно было создавать новые функции, описывать новые функции, добавлять к этим функциям новые атрибуты и в рамках системы, работающей в реальном времени, чтобы можно было переопределять интерфейсы межсистемных взаимодействий. Дальше, возвращаясь к вопросам, является ли внутреннее представление предметом описания языка или это и есть язык? Внутреннее представление, в моем понимании, это граф. Есть отдельный вопрос, какой это граф. То ли это граф, то ли это гиперграф, то ли это метаграф. У меня в моем случае сейчас это граф. не гиперграф, хотя, как мы знаем, с помощью графа можно описывать любые гиперграфы, но это делается через дополнительные сущности. Соответственно, языком это считать нельзя, потому что в моем понимании язык – это все-таки предполагает некоторый лексикон и предполагает некоторую грамматику. Говорить о том, что у графа есть грамматика, это немножко бессмысленно. У графа есть топология, а грамматика есть у языка. Что есть язык вообще? Язык, в моем понимании, это способ отображения какой-то информации в последовательность символов, где символы являются элементами некоторого лексикона. И правила сопоставления различных типов элементов лексикона определяются некоторыми грамматическими правилами. Как связано внутреннее представление с антологиями и грамматиками? В грамматике, в моем понимании, смысла не имеет, потому что грамматики связаны, нужны для языков, для внешнего отображения внутренних представлений. Антологии, очевидно, нужны, нам элементы внутренних представлений должны быть связаны с антологиями, как минимум для того, чтобы можно было их отображать во внешнее представление. В остальном, в чистом виде антологии, как мы их понимаем, наверное, не нужны, потому что антология предполагает все-таки какое-то развешивание каких-то этикеток. А когда идет процесс мышления, то мы работаем, собственно, с функциями объектов, а не с их именованиями. То есть, в моем понимании, онтология предполагает какое-то именование. Соответственно, во внутреннем представлении именования и грамматики нужны только для внешнего отображения. Должно ли внутреннее представление отображаться на внешнем интерфейсе? Да, конечно. Как? С помощью онтологии и грамматики, которые позволяют как транслировать внутреннее представление на выход, так и декодировать его на вход. Какова структура хранения данных? В моем понимании, я, честно говоря, не знаю. У меня был семинар из двух частей про структуры данных для AGI. Там были разные аргументы, должна ли эта структура быть графовой или гиперграфовой. Я понимаю аргументы Николая, что достаточно просто. направленного графа, где сложные сущности могут быть представлены с помощью представления дополнительных вершин. И никакие графы не нужны. Есть гипотеза, что все-таки для повышения производительности нужно вводить гиперграфы и в явном виде работать с атрибутами отдельных связей. То есть, на каждую связь в каких-то случаях или на какие-то определенные типы связей все-таки, наверное, навешивать атрибуты должна быть возможность. Должно ли быть выражение нечеткости внутреннего представления? Ну вот, склонен согласиться с Николаем, что в большинстве случаев либо мы не знаем вероятности связи, Либо мы эту вероятность можем считать единицей, а во всех исключениях мы это можем решить отдельными механизмами, либо дополнительными атрибутами, либо с методами гиперграфов, либо вообще созданием дополнительной вероятностной настройки на вот этим внутреннем представлении. То есть первый слой внутреннего представления – это про структуру, А второй слой внутреннего представления – это уже про вероятности. А уже и транслятор, и отдельный… и вот здесь возникает некоторый костыль, каким образом вот эти два разных слоя представления вероятностей данных, структурированные на одном уровне и вероятностные на другом уровне, как это все будет транслироваться в языковые конструкции, когда мы говорим о том, что языковые конструкции, они должны отображать просто внутреннее представление. То есть, если у нас вероятность находится на другом системном уровне, то здесь уже прозрачности не получается и здесь, на самом деле, у меня готового ответа нет. Можно ли сказать, что из внутреннего представления есть разметка его элементов? Если не брать время, про которое хороший вопрос задавал Сергей, со временем у меня тоже нет четкого решения, что делать. И если не говорить про вероятности, то можно сказать, что это просто некоторое форматирование и навешивание этикеток на вершины. и ребра графа, некоторые правила того, в каком порядке их упорядочивать при выводе в текстовую форму. Со временем и с вероятностью сложнее решение пока нет. Является ли язык ограничителем когнитивных способностей? Допустимо ли формирование собственного языка внутри AGI? Чем, по-вашему, он будет отличаться от нашего обычного языка? Здесь есть очень важный момент, на самом деле, про который, значит, возможно, мы с Николаем забываем, что если мы хотим, чтобы система могла сама дописывать свой код, то вообще говоря, есть возможность, как это предполагается, допустим, в системах написанных на LISP, когда система порождает некоторую функцию, которая загружается, собственно, в пространство, в тягущий контекст. то на самом деле нам язык нужен для внутреннего употребления системы, то есть система как бы подумала, система сгенерировала какой-то код и этот код сама в себя имплементировала. Но вот допустимо ли формирование собственного языка? Ну, я, честно говоря, не знаю. Если система придумает какой-то язык для общения с другими модулями системы, наверное, да. А для своего внутреннего употребления какой-то язык, я, честно говоря, не знаю и не могу сказать, чем он будет отличаться. является ли язык ограничителем когнитивных способностей? С точки зрения того, что, имея слабый выразительный язык, слабую грамматику и ограниченный лексикон, Ну, наверное, мы будем ограничены в потреблении информации из внешнего мира, в получении новых знаний и в обмене этими знаниями с окружающей средой. Соответственно, мы будем ограничены постольку, поскольку мы будем ограничены в получении информации о других субъектов социума а в остальном мне кажется язык не ограничивает потому что как бы на внутренний потенциал системы язык как средство коммуникации никаким образом влиять не должен все спасибо за внимание и переходим к вопросам Так, значит, Антону Колонину. Есть ли многословные слова, например, описание диагноза с пяти слов? Вот, прекрасный вопрос. Значит, вот у меня одна из приоритетных задач, на которую потрачено много ресурсов и на самом деле существенное существенное энергопотребление, ресурсопотребление при парсинге идет на то, что многословные слова, они поддерживаются. То есть, если у меня хочется сказать, что цвет серый, цвет грязно-синий, то мне не нужно грязно-синий брать в кавычки. Цвет грязно-синий. или я или там место проживания новая москва никаких кавычек не нужно вот место проживания это атрибут новая москва это от это значение атрибута все вот просто текст моя я место проживания новая москва пять слов и система должна понимать что место проживания и новая москва это вот эти пары слов обозначающие сущности причем не обязательно пары их может быть много до сергиев где кончается цепочка вот надо чтобы она поняла что я закончил многословное слово и перешел значит Короткий вопрос. Это зависит от контекста. Значит, реально это сделано так. Либо это знак припинания. То есть, если есть знак припинания, то стопудово кончается последовательность. А если знака припинания нет, то она считают цепочку до тех пор, пока не встретят очередное слово, которое соответствует свойству той сущности в контексте, который идет разбор. По его действия как раз возникает то, что Николай говорит, Потому что у разных сущностей разные цепочки могут быть разными, потому что у них разные атрибуты. То есть, грубо говоря, если у табуретки нет места проживания, то она будет разбираться так, как будто место проживания – это какое-то свойство табуретки. А если у человека есть место проживания, то место проживания будет разбираться как сущность. как свойства человека. На самом деле поддержка этого дается очень нелегко, но пока работает. Вы приводите примеры из информатики, запросы, AGI. Сергей, не понял вопрос. 

S03 [01:36:32]  : В основном все примеры, которые вы рассказываете, они касаются следующего, что вы сообщаете факты и дальше вы фактически задаете некие запросы. То есть то, чем занимается информатика, такая база знаний, которая может задать запросы. А если я правильно понимаю, IGI должен выполнять цепочки, размышления и так далее. То есть для тех приложений, на которые вы ориентируетесь, управление вебом, управление умными устройствами и так далее, там действительно достаточно запросов. 

S02 [01:37:04]  : Смотрите, значит, я здесь отвечу точно так же, как, мне кажется, ответил бы Николай, что мы делаем язык интерфейса к системе. А то, чем занимается система внутри, это как бы второй вопрос. То есть, это язык для… Это язык для взаимодействия с системой, который, с одной стороны, достаточно формальный, чтобы его система понимала с минимальными затратами, не требуя обучения в течение долгих лет жизни и знания грамматики и онтологии полных естественных языков. А с другой стороны, чтобы он был достаточно близок к пользователю. С моей точки зрения, вот тот язык, который я пытаюсь развивать, он с точки зрения, значит, находится где-то между тем, что рассказывал Алекс, и тем, что рассказывал Николай. Вот у Николая, мне кажется, язык менее интуитивный, потому что там есть какие-то символы, которые человек Слух голосом не произнесет и даже, может быть, не поймет, если не будет специально обучен. Но я, с другой стороны, не заморачиваюсь в морфологии, как Алексей. У меня там кошка-микроволновка, мяукать. Без всяких склонений и испоряжений. Вам язык нужен только для того, чтобы он мог сделать запись слов и мог потом считать и озвучить эти слова. Почему считать и озвучить? То есть, язык нужен интеллекту для того, чтобы получить информацию из внешнего мира, спросить у внешнего мира о какой-то информации и передать информацию во внешний мир. Причем внешним миром может быть также другой интеллект, естественный или искусственный, или, если система состоит из многих частей интеллектуальных, то для общения между частями. Для внутренней эксплуатации, вот мой язык, которым я занимаюсь, он не нужен. Так, Сергей Терехов, полезно формировать поименованные множества на лету. Это позволит последующие выражения сделать более точными. Ну, наверное, соглашусь. Да, я, наверное, согласен. Так, у вас вопрос с голосом еще есть? 

S03 [01:39:17]  : Да, он есть. Антон, вы последний выступающий или кто-то еще? 

S02 [01:39:21]  : Нет, у нас еще много выступающих, еще двое. 

S03 [01:39:24]  : А, тогда, наверное, я даже не знаю. Дело вот в чем. Вот все трое выступавших пока ничего не сказали о точности. С моей точки зрения, когда мы имеем общение с некой такой системой, то есть проблема донесения точного смысла того, что я хочу от нее. А вторая, еще более тяжелая проблема, это однозначное получение результата. Вот старые фантасты все время выдают из интеллектуальной машины перфоленту. Я все время думал, как же так? Туда вводится информация на естественном языке, обратно перфоленту. Что же они, не могли придумать обратно то ли язык, что ли? Нет, на самом деле они мудрые. Дело в том, что нужно максимально уменьшить когнитивные фильтры, которые на входе и на выходе. То есть нужно как можно точнее, без фильтрации через естественный язык, сообщить машине, что вы хотите, обратно не пытаться ретранслировать ее когнитивно сформулированный какой-то язык квази квази естественный что же она хочет вам сказать вот и в том пути и на том пути теряется очень много информации плод того что полностью искажается смысл Поэтому вот, ну это уже скорее комментарий. Извините, я просто думал, что Антон был последним. 

S02 [01:40:36]  : Да, спасибо. Ну, я согласен с вашим комментарием. Легезар Талипов, последний вопрос. Можете вы уточнить, при чем здесь Алиса и Сирия? Как они могут помочь облегчить задачу? Алиса и Сирия, они построены очень просто. Там все захардкожено, так же как у робота Софии или там у этого самого, как он называется. Евгения Гусмана, то есть там нету возможности с помощью языка сообщить системе что-то новое, кроме того, что туда заложили программисты. Причем здесь Алиса и Сирия? 

S01 [01:41:11]  : Ну вот вы приводили пример. Датчик температуры сообщает какая температура, какое состояние, причем сообщает это на налоговом языке. Но можно было бы сформировать более красиво с использованием этих технологий. 

S02 [01:41:32]  : Для того, чтобы делать это более красиво, у меня предполагается то же самое решение, как у Николая, что конструкции на контролируемом языке можно разукрашивать с помощью генератора НЛП, который будет в соответствии с пониманием контекста добавлять спряжение и склонение. Хорошо, коллеги, давайте двигаться дальше. Пожалуйста, Виктор, вы готовы? 

S07 [01:42:09]  : Виктор, это я, Казаринов. но я готов очень экспромтом. к сожалению, они не готовятся и не создал кучу всяких презентационных материалов. но кое-что есть. я могу расшарить экранчик. да, давайте. значит, сейчас секундочку. я его еще и не расшаривал никогда. так, я попробую. Так, что-то видно, нет? 

S00 [01:42:42]  : Да. 

S07 [01:42:43]  : Так, все это убрать, не знаю. Итак, у меня есть давно разработанный язык AIGL для языка искусственного интеллекта. Это видно, да? Да. Значит, он был разработан как язык, который в первую очередь предназначен для систем искусственной интеллекции, во вторую очередь только для человека. Тем не менее, это было учтено. Смысл какой? Вот я не совсем согласен с предыдущими выступающими некоторыми в том, что не нужно брать онтологии в качестве основы, И так далее. Вот смотрите, есть деньги. Деньги – это и платежное средство, и средство хранения, и средство накопления, и средство стимуляции труда и так далее. В очереди у него одно значение. Но это просто деньги. То же самое с языком. Язык должен выполнять не только одну функцию, допустим, коммуникационную функцию. Он должен выполнять еще и много функций, которые, ну, какую-то часть функций, которые автор этого языка или авторы закладывают в него. Вот у меня такая задача, первая, очень важная. То, что системы, которые я предполагаю, то есть моего представления, как будет построен АДЖИ, у него есть несколько секций антологии, то есть он построенный на антологическом способе обработки информации, не на нейросетевом. Соответственно, я уже такие системы делал, простые, более простые, и представляю, как все это работает. Поэтому в этой системе есть несколько секций. Первая – это таксономия базовых классов, которая дефолтная. Включаешь, она работает, она есть. Дальше идут там проблемные всякие и эксплуатационные секции и так далее. Но вот эта первая секция, она и является главной. Таксономия базовых понятий. И если мы Передаем извне, в терминах этой базовой, самой-самой базовой части антологии, этих базовых понятий, нам не нужно никаких многозначностей, мы передаем точный смысл, нам не нужно всяких парсингов сложных, нам ничего не нужно, мы просто прямую передаем. Другое дело, естественно, что такая система не будет в себя записывать это. она будет понимать это в правильном смысле, но может соглашаться, может и соглашаться с этим. Более того, эта антология может иметь версионность. Вот, допустим, самая первая версия, которая заложена при производстве, она такая. Дальше идет апгрейд системы, она добавляется. Так же, как в любых системах, можно версии создавать. Тем образом, это живая система, то есть язык будет живым. И, соответственно, система словарь. Это словарь, но он основан на связях. Это не просто набор терминов. Это таксономия классов, которые говорят о наших явлениях. Вот видно, что верхняя часть онтологии, она, допустим, что такое? Классы, атрибуты, персоны и так далее. То есть абстрактная физическая и так далее, ну очень крупные такие вещи разделяют в системе, определяют. Дальше идут более подробные вещи, там процессы, всякие частности и так далее. К ней, к этой базовой онтологии могут пристыковаться какие-то отраслевые, но это могут быть Какие-то в обычном языке этому эквивалент жаргоны, какие-то диалекты и так далее. Все это можно будет подстыковать к этому базу. Но самая верхняя часть, она маленькая. Она там меньше около тысячи, вот у меня здесь не больше тысячи терминов. Вот я им там название дал, это предыдущий вариант языка. И в этот язык от того, который я сейчас хочу вам, про который говорю, Вот у меня он называется AGCL, коммуникационный язык для искусственного интеллекта, для сильного искусственного интеллекта. Он еще только в самом начале разработки, поэтому мне сейчас и представить особенно нечего. Просто я все это представляю, знаю, но формализовать еще не успел. предназначен и для внешнего записи. Допустим, мы должны записать какие-то точные знания в книге, на диске и так далее. Этот язык должен этому соответствовать требованиям. Дальше он может представлять точные знания внутри системы. Дальше он может использоваться в обработке знаний внутри системы определенного типа, которые я, допустим, продвигаю в направлении искусственного интеллекта сильного. Дальше внутри такой системы отдельные модули тоже могут общаться, взаимодействовать, должны общаться на этом языке. Поэтому вот эти вот разные вещи, они должны выполняться и вполне нормально, но здесь вот, допустим, я еще придал им какие-то определенные слова, ой, здесь вот не везде заполнены они, вот, они К каждому понятию указано какое-то слово, оно довольно благозвучное должно звучать, но оно совершенно абстрактное, то есть оно не соответствует никакому слову, никакого естественного языка. Сам язык состоит, естественно, вот из словаря, который не просто так, куча слов, это устроенная система. Дальше и, собственно, грамматика. А грамматика у него примитивная. Каждое выражение состоит из трех слов. Субъект, предикат, субъект и объект, как обычно в триплетах антологических. Мы можем писать большие трактаты из всего, допустим, Маша ела кашу или я пошел гулять на русском языке. Кроме того, этот язык может иметь разные виды. реализации на разных языках. Можно вот на этом синтетическом языке, можно на французском, на русском словайте. Естественно, они не будут стыковаться по падежам, спряжениям, сложениям, а будут вот так же звучать довольно вычурно, как и в некоторых других языках в виде триплетов. вот это чисто по организации структуры но есть еще одна один аспект языка это его общая так сказать организация и вот допустим самое важное вот допустим у меня выражено выделено здесь 22 23 типа типа взаимодействия между двумя субъектами в диалоге. То есть сообщения все вместе должны быть теги начала и конца какого-то сеанса связи. Дальше идет ссылка на какую онтологию мы используем. Это, допустим, базовая или какая-то другая версия. Также, как в любом документе, в законодательном акте, посмотрите, вначале идет словарь, какие термины используются в законодательном акте, а дальше идет уже работа со статьями, которые ссылаются на этот словарь. То же самое здесь. Но здесь вот еще идет транспортный протокол, оболочка транспортная, про нее сейчас говорю. Она состоит, допустим, я отказался, я подтверждаю, не подтверждаю, все неправильно информирую, то есть это подлежащее предложению повествователям, там прокси передай другому, запросы там всякие и так далее, реквесты. Это все я сам придумал, это естественно из протокола ФИПА, взаимодействие агентов. Здесь у меня бинарная вещь, бинарные коды записаны в бинарном кодировке для вот этого языка, который я еще давным-давно начал прорабатывать. Но части из него, вот здесь вот я использую, то есть это оболочка транспортная. Дальше язык должен быть потокоориентированным. Если мы посылаем какую-то пачку информации и кусок обрезается последний, мы хотя бы начало могли легко восстановить. Нужно располагать информацию в каких-то абзацах так, чтобы целостность информации сохранялась. Это всё касательно оболочки. А что же внутри? Вот эти триплеты, о которых я говорил, они образуют на самом деле небольшие графы, связанные графы. которые говорят о чем-то одном. Допустим, что вот кошка лежала на сером мате, рядом смотрела в окно и так далее. Вот эту целую маленькую сценку можно в виде связанного графа. Причем и прошлое время, настоящее, будущее там подчесалось и так далее. Все это легко можно описать. Я сейчас не могу это представить вам в виде текста. в какой-либо аннотации на русском языке, ломанном русском, либо на вот этом языке, который я тут «птичьи» придумал, имеется в виду слова «птичьи». Но, тем не менее, суть та же самая. Ну, или бинарная кодировка для машины. Ну, там еще есть много вещей, связанных с протоколом. Ну, допустим, когда мы начинаем диалог, сначала, допустим, какой-то идет, хочешь ли начать сеанс, связи со мной. Хочешь, пацану, поговорить. А если мы делаем монолог, допустим, книгу какую-то пишется или посылаем письмо, то есть это другой тип оболочки транспортной получается для этого языка. Соответственно, ну все это пишется тоже на триплетах. Вот это все триплетами объясняется, то есть начало сообщения, конец сообщения, шапка сообщения, какая версия онтологии используется, и дальше идет взаимодействие. Да, это человеку очень громоздко получается, это почти как XML, но тут никуда не денешься, если мы хотим точности, потому что мы передаем точную информацию. Допустим, если мы говорим, что там, я уже говорил о таких вариантах, мама мыла раму, И можем указать еще, что мама – это, допустим, женщина или работница какого-то завода, мама какой-то девочки и так далее. Мы можем все это также триплетами пояснить, но все это должно соединяться в небольшие графы. Дальше мы можем разделять на блоки. Допустим, когда мы пишем одно сообщение, идёт след на другое. И мы можем создавать локальные переменные внутри языка и ссылаться на переменные внутри другого. Ну, допустим, человек пошёл в лес, а следующее предложение – он… там был одет в чёрное пальто. Вот «он» – это отсылка на… переменную в другом предложении. Соответственно, здесь все это тоже будет реализовано и делается легко обычными средствами. Единственное, что нужно, вот кроме самой структуры онтологической, еще вот это вот, как бы сказать, движок языка, то есть программный движок языка, который должен быть стандартизирован, то есть как обрабатывать эти сообщения, по какому протоколу. То есть существует транспортная часть, и нужно, чтобы был стандартный механизм обработки. На конечных автоматах он вообще-то делается, ничего сложного нет. Поэтому мы можем такие автоматические части системы размещать. системы, взаимодействующие на данном языке. Но этот язык, на нем можно программировать, программы создавать, художественные произведения писать, я так понимаю, что если можно будет, и передавать точные сообщения о предметах нашего мира, писать логи, Я вот не согласен еще с тем, что было с Николаем Ромчевским, что он разделил на самые разные сущности, числа в одну корзину, хронологию в другую, логию в третью. наклонные графы имеются во вторую. тут все соединено, все это можно делать в единой системе. почему это лучше? потому что у вас числа как бы оторвались, фактически данные, и все, они как умерли для этой системы, там непонятно что с ними, к чему они идут. Лог, он тоже очень важен, потому что он связан с тем, что, с кем, когда, что произошло. Нельзя его отрывать, этот лог событий, от более сложных вещей, которые можно в графе выразить внутри. Это речь идет о том, что внутри система делается. Но можно также описать это и текстом на бумаге, вот на этом языке. К сожалению, это единственный такой случай, когда я говорю со слагателем наклонения. Я должен был представить действующее что-то, но я уже честно написал, что я только анонсирую начало разработки. Я еще не готов к тому, чтобы... У меня просто не было времени для того, чтобы им заняться плотно. А сейчас, кстати, у меня это время появилось. Я сейчас собираюсь его сделать, чтобы программная система работала с ним не в продакшене, а может быть и в продакшене каком-то. Ну вот, в общем, так. Это было несколько экспромтом, сумбурно и не настолько слаженно и чётко. Поставлены сообщения. Я уже, может быть, на какие-то из этих вопросов ответил. Является ли внутреннее представление, система понятий, пространство экземпляра геи предметом, описанием, языком, или это есть язык? У меня внутреннее представление, в общем-то, практически совпадает с представлением внешним. То есть мы можем четко в какой-то части речь не идет о том, что все. Потому что внутри системы еще есть неименованные сущности. И вот Антон Колонин, мне кажется, не до конца понимает сущность антологии, когда он говорит, что это нужно только бирки, что это ярлыки. На самом деле их вообще можно выкинуть и просто с числами работать. В триплетах можно просто иметь числовые данные, три числа, уникальные. В следующем тоже три числа, но они не все уникальные, они ссылаются на уникальные идентификаторы. И тогда мы по ним, по этим триплетам, восстановим, легко восстановим структуры, которые требуются для работы. Не мы, а программа, на самом деле. Поэтому внутреннее представление, оно очень даже прозрачное, удобное для работы, ну, по крайней мере, в том виде, как это я себе вижу и уже пробовал кое-что. Что язык, что есть язык вообще, но тут я не буду вообще философствовать, это не для меня. Вот. Но вот у меня тут вот как раз с фонтологиями как раз все это и связано, поэтому я Даже про другие варианты я не говорю. Внутреннее представление именно онтологическое. Движок Инференс и Джины работает с онтологиями хорошо. Она там разруливает все. Но не только она, потому что там еще есть другие движки. Должно ли внутреннее представление отображаться на внешней интерфейсе по входу и выходу? Здесь оно просто берет и транслируется. Другое дело, что каждый элемент может разное обличие, разную нотацию иметь – бинарную, русскоязычную, англоязычную, но все равно это будут триплеты. Человеку это труднее воспринимать, но он тоже может небольшие, коротенькие графы в голове держать, потому что мы говорим, что там Сидоров пошел туда, который туда, а мы можем сложные предложения составлять. Вот это и есть маленький граф. Там еще есть и синтаксический граф, и семантический граф, а здесь мы можем уложить граф антологически в один. и передать это машине или получить от нее. Соответственно, у меня это графовое, не знаю, это мета или гипер, но антологическое представление. Значит, не чёткость, а для внутреннего представления вероятности. Но у меня система работает с вероятностью. То есть там, на самом деле, у меня четвёртый параметр добавляется к каждому триплету. И поэтому он определённым образом, в зависимости от обстоятельств, трактуется по-разному, вот эта величина. Но я об этом сейчас не буду распространяться. Поэтому он, в принципе, может и в грамматику выскочить на наружную в этот язык. Я же говорю, может быть, к триплету добавится четвертый параметр нечеткости. Это максимум, что добавится. 

S02 [02:01:04]  : В любом случае, давайте в минуту. 

S07 [02:01:07]  : Всё-всё-всё. Разметка. Ну, короче, я, в общем-то, всё и сказал. Вопросы? 

S02 [02:01:15]  : Да, спасибо. Несколько вопросов есть. Во-первых, чем Ваш язык отличается от тортла? Поскольку у Вас ничего кроме триплетов нету. Какие выигрыши по сравнению с РДФ или тортлом он дает? в кодировании триплетов. Во-первых, что в нем есть с точки зрения представления триплетов, а во-вторых, а как на этом языке задавать вопросы. То есть, если нужно спросить у системы что-нибудь, как вы это на вашем языке спросите? 

S07 [02:01:59]  : Так, значит, второй, к сожалению, я тут немножко отвлекся на секунду. 

S02 [02:02:04]  : Давайте первый вопрос. Чем, с точки зрения представления триплетов, лучше тортла или РДФ? 

S07 [02:02:10]  : Да, да, вот смотрите. Это составная часть, на самом деле, триплеты этого языка. Но я вам говорил еще о наличии конкретного вида токсономии, и она должна быть, то есть слова языка должны быть конкретными, а не просто так вообще. 

S02 [02:02:27]  : Тортл работает как РДФ, он работает с любыми схемами. 

S07 [02:02:33]  : Послушайте, правилами русского языка можно говорить со всеми другими словами, другие понятия вложить в правила русского языка, будто уже не русский. Отвечайте форму и содержание. Здесь еще добавляется содержание. Это первое. Второе. Я говорил о транспортной оболочке. То есть, о том, что это сообщение, оно весь диалог, допустим, или монолог, он имеет какую-то направленность, какие-то составные части. В этом формате только этого ничего нет. Это только внутренняя, это только составная часть этого языка. Вот и все, об этом говорю. 

S02 [02:03:11]  : Хорошо, а вопросы как задавать? 

S07 [02:03:13]  : Хорошо, если мне нужно это… Ну вот же я, смотрите, вот смотрите, еще раз говорю, видно, если экран, то я сейчас вам… Вот, смотрите, вот же у меня вопросы есть, вот смотрите, ну так, как он там, куэри, да? Вот есть же вопросы. Пропаганды, реквесты. 

S02 [02:03:33]  : А как с помощью триплетов задать вопрос? 

S07 [02:03:37]  : Я сейчас не могу точно сказать, а смысл такой. Реквесты имеют в этой же антологии языка. определенное слово или понятие, ну и ярлык, соответственно, к нему привязан, понятие, да, то есть мы пишем реквест, ну там, допустим, ля-ля-ля, тра-ля-ля, вот такое слово, значит, и он может быть указан здесь в конце, в начале и так далее, вот как раз в оболочечной части какое-то сообщение, в транспортной части, это транспортная часть, То есть, когда мы кому-то адресуем его, кроме содержания, допустим, небо синее, а потом его заворачиваем в эту оболочку. Это вопрос повествования или там еще какой-то. А как спросить, какого цвета небо? Я сейчас немедленно опять же не отвечу, про какого цвета. Очень просто. У меня там было, кстати говоря, небо имеет цвет. Небо имеет цвет. Вот триплет, да? Он заворачивается в вопрос. Реквест. Понимаете? Еще один триплет добавляется. Это был вопрос. 

S02 [02:05:00]  : Окей. Хорошо. В чем основная суть, которая нет в других языках? От Алекса Бура вопрос. 

S07 [02:05:08]  : Ну, я не знаю. Может быть, такие языки есть. Их вагоны и тележка. Я думаю, что как бы... 

S02 [02:05:17]  : Еще вопрос. Хорошо, спасибо. Еще вопрос, который, на самом деле, как всем спикерам хорошим надо было бы задать. Как быть, если онтология имеет много, десятков тысяч понятий и отношений? Как выбрать элемент в ней безошибочно? Возвращаемся к именам. 

S07 [02:05:37]  : Нет, смотрите, здесь, во-первых, мы можем Вот смотрите, какая вещь. Мы создаём вопрос. Мы создаём как SQL, да? SQL или SparkQL, задаём вопрос. Здесь тоже можно графом задать вопрос и завернуть его в слово вопрос, да, request. Вот. Так этот граф запроса, он идёт в систему, и там, соответственно, он должен обработаться как в запросе. Естественно, он по-другому не должен обработаться. А дальше уже зависит от способности системы, которая этот ответ формулирует. Либо это нужно найти просто внутри базы антологии своей, либо нужно поразмыслить, либо еще где-то поискать. Это же так и человек делает. Если это простой ответ, связанный с вытаскиванием из хранилища, как это делается с базами данных, то система просто загоняет его туда, как я делал, и мы смотрим сопряжение этого графа. Вот, допустим, цвет неба. И она выдает максимальное совпадение, с чем связаны эти элементы, если она цвет неба найдет в памяти. Соответственно, вчера она была зеленым, сегодня она черная, завтра она будет синяя. Можно тогда задать вопрос относительно какого времени, в какой обстановке вы хотите узнать, потому что у меня этих времен там цвета неба много. То есть не всё же выкидывать. Это уже диалог. Но можно всё выбросить, как это делать, в виде таблицы. Вот я знаю, что небо было красным, когда горело там такое здание, небо было такое-то далее. Вот, всё, эти ответы она может повыбрасывать в список, но это будет большой список. Я вот, допустим, задавал системе вопросы. Города. Какие, знаешь, города? И она мне все города мира там как начала выдавать. Я еле остановил. 

S02 [02:07:32]  : Сурьек-звёздочка, как в Эскуэле говорят. 

S07 [02:07:34]  : Ну да-да-да. 

S02 [02:07:36]  : Хорошо. Спасибо. Вопрос от Александра Петрова. Чего не хватает для формализации отчуждения Вашего подхода? 

S07 [02:07:45]  : Что значит отчуждение? 

S02 [02:07:48]  : Видимо, для того, чтобы Ваш подход могли использовать другие без Вашего участия. 

S07 [02:07:55]  : Это нужен труд. Я его, этот результат, тогда буду публиковать. У меня для него, кстати, есть отдельный сайт. Я даже... Где он у меня там? Где-то я его писал. icl.org у меня он есть. Зарезервировано это самое доменное имя. Я его сюда ретранслирую в ближайшее время на сайт. Ну, просто у меня костингов не так много. И, соответственно, там будет в открытом доступе с определенными... лицензионными определениями. Да, пожалуйста. Но мне кажется, вот эта система довольно мощная будет. Я представляю, потому что с предыдущей версией языка я поработал и с антологиями я поработал в системе. Я считаю, что это очень интересный вариант. Единственное, что он менее человекоориентирован. 

S02 [02:08:54]  : Ну вот с точки зрения человекоориентированности, мне кажется, вам нужно ответить самому себе и всем остальным на вопрос, чем это кручат Спаркуэль, РДФ и Тортла. 

S07 [02:09:05]  : Но вот смотрите, на нём уже можно эти языки... То есть можно декларативно, можно функционально, можно писать просто лог событий, как записную книжку, можно делать всякие вещи. Абсолютно всё, что мы можем с русским языком делать, только это более чёткое и недвусмысленное сообщение будет записано, понимаете? То есть нет многозначности такой. Если мы хотим указать, что это в таком смысле, а это в таком смысле, сразу и указывается, в каком смысле. 

S02 [02:09:34]  : Хорошо, Виктор, спасибо. Александр Балдачёв. 

S01 [02:09:41]  : Добрый день, господа. Уже время-то у нас. 

S02 [02:09:48]  : как мы поступим, потому что... Ну, смотрите, значит, если участники готовы заслушать, у нас, в принципе, мы выпадем из графика на 15 минут. Если все готовы к этому, то... А когда у нас график? 

S04 [02:10:05]  : Какой график? 

S02 [02:10:06]  : У нас обычно два с половиной часа, у нас сейчас получается каждый докладчик это 20 минут доклад и 10 минут вопросы. Соответственно из обычного рекламента мы выбиваемся на 15 минут, но это в принципе у нас такое случалось, поэтому я не вижу большой проблемы. 

S04 [02:10:25]  : Хорошо, если согласны, то я у кого-то эхо слышу. Александр, мы согласны. Хорошо, давайте, давайте. Я пропущу, наверное, все-таки теоретическую часть ответа на вопросы. Там у меня было более-менее что-то разработано, и интересно, чтобы не тратить время, я приступлю сразу к последней части. Из первой части вопросов я только отвечу все-таки на самый главный вопрос про язык. Мы сейчас именно обсуждаем язык. И я бы формально сформулировал так. Ну, прежде всего, язык – это система знаков. Всегда. То есть там, где у нас есть знаки. То есть, скажем так, если нет знаков, то и нет никакого языка. И эти знаки однозначно подразумевают, что если есть знаки, уже вот если мы сказали язык – это система знаков, что значит есть некие агенты, которые генерируют эти знаки, есть некие агенты или некие структуры, которые воспринимают эти знаки. И самое главное, они воспринимают эти знаки как знаки именно только потому, что они меняют свое состояние, при восприятии этих знаков, без энергетического воздействия. Основное, что мы должны знать о языках – это некая знаковая структура, которая способна менять состояние различных агентов без непосредственного физического воздействия. Конечно, следует добавить, что язык – это не просто любая система знаков. Как я написал по последнему тексте, текст – это тоже система знаков. Здесь, скорее всего, нужно еще акцентировать внимание на то, что это система знаков, используемая для управления некоторой деятельностью. Если у нас есть некоторая деятельность, хотя бы даже жизнь, и есть некая система знаков ДНК, и эти знаки используются для управления этой деятельностью, то мы говорим о наличии некого языка. И под управлением здесь можно понимать несколько знаковых ситуаций. Не только коммуникация. Есть указания, оповещения, хранения. И коммуникация – один из вариантов знакового взаимодействия. То есть нельзя сводить знаковое взаимодействие только к коммуникации. Потому что даже, скажем так, что если я использую свой родной русский язык для мышления, как знаки использую русского языка в процессе мышления, как некие идентификаторы, как некие указатели на понятия, то я здесь не коммуницирую ни с кем, но я использую язык. Или другой вариант. Я использую язык для того, чтобы выразить свои мысли. И формулирую в грамматике русского языка, вот сейчас я делаю, пытаюсь правильно произносить слова. То есть, в принципе, может поразуметься, что коммуникация. Я говорю вам и хочу от вас что-то услышать. Но я могу писать текст письменный, Этот текст может быть записан в моем личном дневнике и не подразумевает вообще, что кто-то это читал. Поэтому вопрос коммуникации здесь важный, один из важных, лежащий на поверхности. И дальше я больше не буду и про андалогии, и про внутреннее представление. Там много чего у меня понаписано было. Я перейду сразу же тогда к практической части. Ладно, я, наверное, пока сразу экран свой демонстрацию... Экран делится. В отличие от предыдущих докладчиков, мне есть что показать. Правда, не в полной мере, поскольку У меня есть зимний прототип движка, семантического движка событийного, который использует разработанный мной язык для моделирования деятельности. Случилось так, что мой программист летом сам переболел ковидом, переболел альгиной, плюс еще у него отец от ковида умер, и вот только он сейчас заканчивает уже прототип, пилот, а не прототип. Что вы видите? Вы сейчас перед собой видите именно движок, в котором есть событийный граф, Он представлен в виде списка. Связи здесь скрыты. Связи могут быть и через triplet, и через condition. Сейчас я объясню, что это такое. Есть некоторые... уже заведенные атрибуты изначально, несколько моделей. Это как раз базовый граф, Genesis-граф, в котором заведены основные модели. основные события. И я сейчас просто показываю для того, чтобы понятно, что это то, что я буду сейчас объяснять, что это работает, а не то, что я буду строить какие-то предположения. Я беру и загружаю сюда готовую демонстрацию процесса. подписание соглашения между несколькими контрагентами при участии менеджера, которую я сдавал в виде proof of concept для конторы, в которой сейчас работаю, и мы делаем уже филопилотную версию. Да, 164 события загрузить, и вместо 300 с чем-то событий сейчас получилось уже 163 события, которые я вводил руками. В принципе, их можно ввести за... 15-20 минут, наверное. Мы видим, что появились некоторые экшены другие, проекты, реестр персон и само действие соглашения. Появились атрибуты новые множество, отношения какие-то заведенные, куча индивидов появилась, и мы можем зайти Ну, это пилотная версия, она иногда глючит, поэтому непонятно по каким причинам, но бывает глючит. Так, это займет сейчас 15 секунд, не больше, даже 10, если же мы решили подождать. Загрузились. Соглашение. Есть некий индивид одного соглашения, который уже начался, и есть модель. модель соглашения, в которой расписаны все шаги, все события, которые должны быть. Сначала должен быть событие выбрать проект, проверить профиль инвестора, получить согласие от адвайзера, послушать согласие от стартапа, владельца стартапа, загрузить текст соглашения и в конечном итоге подписать И здесь есть еще пока коряво сделанные запросы, они должны быть в том же формате, просто сейчас нет, не сделано мнемоника. И плюс, если мы посмотрим, как это выглядит в интерфейсе, то есть это вот таким образом выглядит в интерфейсе, что есть некие поля, которые закрыты сейчас, поскольку не были совершены предыдущие события. Есть выбор акторов. Выбираешь актора, открывается поле, которое ему доступно, делаешь это событие, проверяется результат этого события валидатором, если все в порядке, записывается в граф. Даже сейчас любому актору доступно ввести имя. этого соглашения. Вот я его ввел, и мы можем посмотреть, что вот он в графе в конце, это имя, вот последнее событие. Так, я его ввел или я его не сохранил, наверное. 

S02 [02:19:27]  : Александр, извиняюсь, что стряну. Скажите, у нас будет возможность сдвинуться именно, собственно, к языку? Хорошо. Хорошо, всё-всё-всё. 

S04 [02:19:37]  : Давайте сдвигаемся к языку. Значит, теперь смотрим, в каком языке и как эта демонстрация записана. Вот модель. Вот написано на этом специальном языке. Это событийный язык. Сейчас я про него расскажу. Вот структура этой модели в виде диаграммы. Это тоже язык, и эта диаграмма абсолютно точная. То есть это не просто блок-схема. А по этой диаграмме можно запустить модель и отработать. Теперь переходим к самому языку. Откуда взялся язык? Прежде всего, это действительно специфический язык для записи данных, для записи фактов. То есть это язык типа РДФ, но РДФ записывает факты без привязки к времени, без привязки к событиям, без привязки к причинно-следственным связям, а просто отдельный факт. Событийный язык основан на энтологическом подходе, принципиально отличном от объектного подхода. И если, скажем, в объектном подходе кошка лежит у дверей, записана именно как некий факт, то любая фиксация факта записывается как событие. То есть событие зафиксировано каким-то актором. Это очень важно. Прежде всего, любой атрибут, любой акт, любое отношение записывается как фиксация события и записывает в унифицированном формате. Формат выглядит вполне понятно. Некий идентификатор, triplet, в котором есть базовое событие, на котором фиксируется это событие, тип события и значения. В формат входит condition. Condition определяет условия возможности фиксации этого события. То есть если не было совершено каких-то каких-то событий принципиально. Скажем, это легко показать на бизнес-логике какой-то. То есть мы спрашиваем Вася, когда ты должен приступить к лёгким макетам. Вася приступил к росту бакета. Он говорит, мне должны Петя картинки прислать, Маша текстом, и дать это Машке начальнику. В Condition записываются три события, три ссылки на события, условия, когда должно случиться это событие конкретное. И актор, и временные метки. Временные метки не используются антологически, они используются только для фиксации в базе данных. Для того, чтобы понять, каким образом работает Condition, здесь нам нужно обратиться к известной архитектуре компьютерной, которая называется Dataflow. То есть вы все знаете, что наши современные компьютеры, мой компьютер, который сейчас я проигрываю, он работает в архитектуре control flow, то есть когда последовательность некоторых операций выполняется строго заданному алгоритму, и следующая операция выполняется после завершения предыдущей. На заре компьютерных технологий, где-то даже в 70-х годах, даже чуть пораньше, появилась еще одна архитектура — data flow. И алгоритм там выполняется совершенно по-другому, расчеты выполняются. То есть есть некое дерево оперантов, У меня некое дерево событий, которые могут выполниться только тогда, когда к ним поступят данные для вычисления. Событие x и y возможно выполнить, оно автоматно выполнится тогда, когда будет введено x и y. И событие x, y, z вот это, оно ждет, когда выполнится это событие, еще поступит запись данных в z. Аналогично работает event flow архитектура. То есть есть дерево событий, которое я показывал, модель, которая сейчас рабочая, она вот так и работает. То есть в каждом событии это говорится о языке, это прямо в языке прописано. Я акцентирую внимание для Антона и для Николая. То есть это не внешние операции какие-то над данными, которые записаны просто триплетами, а это в самом событии записано, когда оно должно выполниться. Это формат языка, это синтаксис. И точно так же записано, что есть некое событие, в котором в condition прописано, что оно выполняется тогда, когда будет выполнено оба этих события, и это событие выполняется, когда выполнится это и это предыдущее. Совершенно как data flow. И для того чтобы подчеркнуть, что это не control flow, здесь стрелки показывают именно в обратном направлении. Что мы имеем, какие плюсы в языке, именно я говорю сейчас о языке. Ну, прежде всего. Когда мы описываем через события, мы описываем текущее состояние дел и можем описать не только атрибуты и отношения, мы описываем акты прежде всего, что не может сделать, скажем, РДФ. То есть именно акты. Можно записать, конечно, атрибуты и отношения, свойства, но прежде всего запись идет через акты, что минимизирует сам дамп событий. Вместо того, чтобы записать, что мама Маша – мать Саши, А Саша – сын Маши, мы записываем акт «Маша родила Сашу». Этим предопределяется и логика, и предопределяется то, что называется семантическим сахаром. Семантический сахар – это то, что он стал сыном – это семантический сахар. То, что кто-то стал дядей, тетей, дедушкой, бабушкой – это семантический сахар, который в граф можно не записывать и который по модели может быть восстановлен во время запроса. Очень четко в этом языке разделяется запись. То есть язык записи фактов, язык записи процессов, действий от языка запросов, которые осуществляются по моделям, по тем же моделям, по которым меняются акты, и дополнительным моделям, в которых прописывается семантический сахар. В событии семантики очень легко реализуются н-мерные свойства, чего в RDF, в принципе, сейчас появляется. Вот в RDF звездочка и есть, а изначально нет. То есть я могу записать, что событие зафиксировано, температура 39 градусов. На этом событии я фиксирую, температура растет. На следующем событии температура растет, фиксирую, событие растет быстро. И вот такая ступенчатая энумерная цепочка свойств, она легко записывается, легко интерпретируется при запросах к графу и вообще при работе с графом. Что еще интересно относительно языка дает нам событийная семантика? То, что мы имеем запись любой деятельности в виде последовательности событий. И это принципиально отличается от записи естественным языком. То есть, когда мы записываем свое предложение какой-то естественном языке, мы учитываем, прежде всего, в каком времени нахожусь я. Я нахожусь там, я говорю его из будущего, завтра, когда я буду там-то, я скажу, что он в прошлом году смотрел кино и сказал то-то. Вся сложная грамматика естественного языка основана на том, что мы всегда работаем со временами, где время, где проходит, где совершается само событие, которое мы хотим, где относительно этого события мы находимся сами. Извините, я спешу, чтобы время все-таки как-то успеть сказать. В событийном записи, в событийной семантике, в событийной грамматике мы всегда записываем любое событие только в прошедшем времени. То есть всё записывается только в прошедшем времени. Это само требование фиксации событий. Я не могу хоть что-то сказать о событии, если оно ещё не свершилось. То есть оно свершилось, следующее фиксирует. Это Маша родила Сашу. И даже когда мы говорим о будущих событиях, то есть о логике, то мы должны их зафиксировать именно в виде в прошедшем времени. Типа, скажем, вот здесь есть пример язык событийной логики, который реализуется на событийном языке. Вместо того, чтобы оперировать классами и говорить, что Сократ входит в класс людей, а этому классу присуща смертность Сократ классный, мы тогда говорим просто Сократ умрет. Есть события, да? Сократ умрет, поскольку он родился. Это событийная логика, где нет вообще никаких классов, а оперируются событиями. То есть все правила, которые логически записываются на этом языке, они записываются из событий, а не от соотношения классов. Классы вообще выделены в отдельный уровень и используются только для поиска и для классификации. И этих классов, различных классификаций, может быть множество на событийном данных. Но здесь, как я говорил, не может быть «Сократ умрет» используется в будущем времени, поэтому правильнее записать в событийной логике эту фразу так. Я утверждаю, что с неизбежностью в графе появится событие «Сократ умрет», поскольку в графе есть событие «Сократ родился». И, скажем, другой пример из логики, который заменяет импликацию, которая неоднозначная. Импликация в логике, в стандартной логике Аристотельской, логике предикатов, логике высказывания, она неоднозначна всегда, импликация. И нельзя сказать однозначно, импликация является истинной или ложной. Скажем, прошел дождь, поэтому асфальт мокрый. Истинно или ложно? Нет, потому что мы не знаем, а может быть там навес был, а асфальт сухой. Если мы говорим в обуславливающих событиях, как по идеологии дата флоу, эвент флоу, с обратной привязкой к обуславливающим событиям, я скажу, асфальт мокрый, поскольку прошел дождь. Это абсолютно истинное высказывание, потому что я указываю то, что я утверждаю – асфальт мокрый, а он мокрый, потому что я это утверждаю, и указываю обуславливающее событие – начался дождь. Я говорил про event flow, исполнение алгоритмов, и не акцентировал внимание, что у нас действительно язык исполнения моделей описывается на самом этом языке. Никаких дополнительных контроллеров, которые будут обслуживать событийный дамп, нет. В событийном контроллере, который сейчас работает, только взял события, проверил его валидность, и если все соответствует формату, соответствует всем условиям, является новое предметное событие, которое записывается. Дальше, по подписке, скажем, какая-то модель ждет вот это событие, она по подписке смотрит, да, вот, скажем, человеку свершилось 18 лет, он смотрит, да, это событие к условию выполнилось, и он генерирует новое событие, по которому, скажем, ему нужно и предоставляется возможность выходить замуж или жениться. То есть у нас получается в одном языке, и какие плюсы? Это язык описания деятельности. То есть мы описываем деятельность. Не положение дел, не фиксированное состояние, а именно деятельность. В итоге мы получаем препаральное хранилище данных. То есть все события, которые были зафиксированы акторами в ходе этой деятельности, зафиксированы по моделям, они сохраняются. Ничего из графа не удаляются, только добавляются листочки. Это направленный циклический граф. Языком программирования являются сами модели действия. То есть никакого другого языка программирования не нужно. На этом языке пишется и бизнес-логика. Это проверено. Пруф-концепт, который показывался в соглашении, заключение, и екатеринбургская компания. Был большой пруф-концепт по системе безопасности, то есть отработке бизнес-логики системы безопасности. тоже прошел, все приняли, то есть по итогу написана статья, по итогу в рецидивируемом журнале, и по итогу того, что сейчас рассказывал, тоже есть ссылка где-то там, у нас в Телеграме тоже вышла несколько дней назад статья. Также мы имеем, это язык логического вывода, То есть ничего другого не нужно для того, чтобы осуществлять логический вывод на этом языке. И в какой-то степени он легко представляется в виде какой-то записи. Типа вот так в модели представлено голосование. Она выглядит довольно просто, легко читается, видны кондишены, видны триплеты, которые должны выполниться. Такая простенькая бизнес-логика реализовывается на такой простой записи. В итоге получается граф, который содержит мультиграф, он двойной граф. То есть серыми линиями обозначены связи объектные, то есть на voiting был point, на point был reject, и на этом же point был accept. И синенькими линиями показаны темпоральные связи, связи через кондишн, связи обуславливающие. То есть показано, что до того, как свершится это событие, не будет создано событие, нельзя изменить статус. Когда будет изменен статус, тогда на preparation. Когда был изменен статус preparation, возможно ввести 0.1, возможно ввести 0.2. При этом 0.2 можно ввести только через 0.1. И через condition задаются и порядочные списки. Ну и так далее. Можно пройти по по темпоральному графу, направленному к циклическому графу, в котором в узлах будут события, а сами события между собой соотносятся через ID, которые прописаны в триплетах. Эти серенькие объектные связи – это обычные связи, как в RDEV. Так, наверное, всё. Сейчас я посмотрю, может, какие-то из... Нет, вряд ли, не буду занимать время. 

S02 [02:35:48]  : Да, у нас уже по времени всё. Всё честно, 20 минут. Значит, несколько вопросов есть к вам, Александрей. Спасибо. Значит, вопрос первый. Сергей Терехов, есть такой раздел Complex Event Processing. То есть, я как понимаю, то, что вы делаете, находится в рамках вот этой отрасли. Что-то вы можете по этому поводу сказать? Это так, или это больше, или это меньше? 

S04 [02:36:22]  : Смотрите, если вы возьмете статью, там есть целый раздел в статье, посвященный, на каких технологиях основана Event Flow архитектура. И там есть Event Process, и Data Flow архитектура, и Event Sourcing, и еще несколько архитектур, которые были, скажем так, неиспользованы. а именно которые реализуются на Event Flow. И основное отличие именно в том, что все существующие архитектуры, которые работают с событиями, они имеют алгоритмы, записанные на обычных языках. То есть у них есть какие-то workflow движки, которые реализуют бизнес-логику, а события используются только для обмена. для подписки на события. 

S03 [02:37:15]  : Александр, нет, нет, нет, нет. Это вы говорите сейчас просто о неком технологическом слое, который там есть. Комплекс Awareness Processing состоит в том, что там события являются First Class Citizen, то есть самыми главными сущностями, и взаимодействие их происходит все что угодно. Там нейросети могут использоваться, любая логика. Там фишка в том, что нет классов, а вместо них есть события. События объединяются в сложные события. Эти сложные события имеют структуру. Там есть авторы этих событий, получатели, время, предусловия, постусловия. 

S04 [02:37:54]  : Киньте ссылку. 

S03 [02:37:56]  : Ссылка есть прямо у нас в чате, но ключевое слово это СЕП. CEP – Complex Events Processing. Отличие, скажем, относительно всего, что заявлено было по технологиям, это то, что у меня семантическая технология. 

S04 [02:38:26]  : Именно описание идет на уровне семантики. Это РДФ плюс событийные потоки. То есть получается граф, направленный, циклический. Насколько исполняемые модели там есть, я не знаю. Исполняемых моделей нет нигде. Модели, которые могут исполняться и переписываться на лету. 

S03 [02:38:52]  : Это и есть суть этого подхода. Когда я мыслю с событиями и порождаю новое событие для кого-то другого. 

S04 [02:39:01]  : Значит, это пересекающиеся вещи. Спасибо большое. 

S02 [02:39:06]  : Да, а я ещё озвучу. Там Сергей тоже дал ссылку. Есть даже целый язык программирования для реализации вот этого подхода. И он используется там и мастер-кардом, и Uber'ом, и PayPal'ом, по-моему. Называется Sithi. В чате есть ссылка. Ещё, Александр, комментарий, что то, что вы делаете, слишком сильно сказано, что этого нигде нет, нет исполняемых моделей. Исполняемые модели есть у Свериденко и коллег в DSL-0. Вы можете посмотреть в ссылках к нашему Семантические модели. Семантические модели. Да-да, D-0SL. Там посмотрите, сверединка гумиров D-0SL, в ссылке на наше совещание там есть. И у нас тоже был похожий проект, реализованный в 1997 году, но вот он до 1998, точнее, до продакшена, к сожалению, не дошел, он там загнулся по ряду причин. Есть похожие вещи. Александр, еще на самом деле вопрос. За нас, за всех ответьте, пожалуйста. Тоже Сергей Терехов спрашивает. Движемся ли мы к AGI здесь? Посмотрите. 

S04 [02:40:23]  : Изначально, на том уровне, на котором сейчас работает EventFlow, это моделлер для деятельности, описание в бизнес-логике, но поскольку содержание самого графа, семантически определено вот этим конкретным языком, модели, по которым строится этот граф, исполняется в бизнес-классе, написан на этом самом же языке, то, возможно, и генерация моделей Возможно. Я знаю, как это делать. Генерация моделей по результатам анализа графа. То есть в некой деятельности, по неким неоднородностям поведения пользователей, по каким-то выборам пользователей, которые делают, можно будет вести дополнительные события, дополнительную сущность и включить их в модель. Или построить вообще новую модель. и что в моей терминологии будет уже определено как элементарное мышление. То есть если, скажем, у Антона в принципе это язык для декларации и для общения с внешним миром, если у Николая в какой-то степени тоже язык только фиксации, Но появление новых узлов подразумевает по анализу внешнего потока у него в большей степени, то у меня подразумевается появление новых сущностей по анализу самой деятельности внутри этого графика. И это уже возможность получения, скажем так, когнитивных каких-то функций, связанных с мышлением, когда мы сможем, оперируя несколькими моделями и плюс еще оркеструющими моделями, которые висят над этими моделями, получать какие-то выводы логические, которые не заложены в самих моделях. То есть прочерчивание в графе неких путей, построение неких структур, которые могут стать основой деятельности, по которой еще не была создана человеком модель. 

S02 [02:42:50]  : Спасибо. Я отчасти поддержу, отчасти ступлюсь за нас с Николаем. Я думаю, что у нас описание собственной модели и порождение новых моделей есть, просто они находятся не внутри языка. за рамками языка, используют язык как источник информации о существующих моделях и средства выражения для новых моделей. Просто мы про это не говорили, поскольку это как бы не была тема сегодняшнего доклада. 

S04 [02:43:17]  : Я подчеркиваю, что у меня язык один. То есть контроллер для этого универсальный. Его ничего не нужно переделывать. Каждый раз добавляются новые, то есть граф наращивается, появляются новые модели. Кстати, точно так же у Николая, то есть изначально нет ключевых слов никаких, они заносятся с начальной графтом 30, они руками вводятся по обычным моделям, как и последующие все сущности. 

S02 [02:43:44]  : Всё правильно. Я думаю, это общее свойство всех обсуждавшихся сегодня систем. Хорошо. Спасибо большое. Жалко, что не было Дмитрия Ивановича Свериденко с Delta 0 SL. Но, тем не менее, было очень интересно. И спасибо всем, кто высказался и кто задал вопросы. Да, я прекращаю запись. 










https://agirussia.org/
Мы ведем группы и организуем семинары русскоязычного сообщества разработчиков систем AGI (Artificial General Intelligence или Общий Искусственный Интеллект) или Strong AI (Сильный Искусственный Интеллект), а также - являющийся их частным случаем HLAI (Human-Level Artificial Intelligence или Искусственный Интеллект Человеческого Уровня).

Группы:
https://t.me/agirussianews (новостной канал)
https://t.me/agirussia (основная)
https://t.me/agiterms (вопросы терминологии)
https://t.me/agibots (разговорный интеллект)
https://t.me/agifintech (финансовые технологии)
https://t.me/collectivei (коллективный интеллект)
https://vk.com/agirussia
https://www.facebook.com/groups/agirussia (основная)
https://www.facebook.com/groups/socialintelligence (коллективный интеллект)
https://groups.google.com/g/agirussia

Онлайн-семинары идут по четвергам, в 18:00 по Московскому времени. Продолжительность два часа, обычно это либо доклад на один-полтора часа и последующее обсуждение на полчаса-час либо круглый стол с регламентом на усмотрение модератора дискуссии. Технические средства проведения, регламент и модерацию обычно обеспечивает инициатор конкретного семинара либо спикер и его коллеги.

Регистрация на семинары (внизу страницы):
https://aigents.timepad.ru/event/1412596

Программа следующих семинаров:
https://agirussia.org/workshops.html
